// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// DOM Module - Agent-Centric Design
// Simple element builders using VNode API
// No callbacks, no function types, no macros

invoke std·collections·HashMap;
invoke crate·core·vdom·{VNode, VElement, VText, VFragment};
invoke crate·core·events·EventType;

// =============================================================================
// Re-exports for convenience
// =============================================================================

// VNode builders are already in core::vdom, re-export them
☉ invoke crate·core·vdom·VNode;
☉ invoke crate·core·vdom·VElement;
☉ invoke crate·core·vdom·VText;
☉ invoke crate·core·vdom·VFragment;

// =============================================================================
// Key Event Data
// =============================================================================

/// Key event data for keyboard events
☉ Σ KeyEvent {
    ☉ key: String!
    ☉ code: String!
    ☉ ctrl: bool!
    ☉ shift: bool!
    ☉ alt: bool!
    ☉ meta: bool!
}

⊢ KeyEvent {
    ☉ rite new(key: &str, code: &str) -> Self! {
        KeyEvent {
            key: key.to_string(),
            code: code.to_string(),
            ctrl: false,
            shift: false,
            alt: false,
            meta: false
        }
    }
}

// =============================================================================
// CSS-in-Sigil: Style Builder
// =============================================================================

/// Inline style builder
☉ Σ Style {
    properties: HashMap<String, String>!
}

⊢ Style {
    ☉ rite new() -> Self! {
        Style { properties: HashMap·new() }
    }

    ☉ rite prop(Δ self, name: &str, value: &str) -> Self! {
        self.properties·insert(name.to_string(), value.to_string());
        self
    }

    // Common properties
    ☉ rite display(self, value: &str) -> Self! { self·prop("display", value) }
    ☉ rite position(self, value: &str) -> Self! { self·prop("position", value) }
    ☉ rite width(self, value: &str) -> Self! { self·prop("width", value) }
    ☉ rite height(self, value: &str) -> Self! { self·prop("height", value) }
    ☉ rite margin(self, value: &str) -> Self! { self·prop("margin", value) }
    ☉ rite padding(self, value: &str) -> Self! { self·prop("padding", value) }
    ☉ rite color(self, value: &str) -> Self! { self·prop("color", value) }
    ☉ rite background(self, value: &str) -> Self! { self·prop("background", value) }
    ☉ rite background_color(self, value: &str) -> Self! { self·prop("background-color", value) }
    ☉ rite font_size(self, value: &str) -> Self! { self·prop("font-size", value) }
    ☉ rite font_weight(self, value: &str) -> Self! { self·prop("font-weight", value) }
    ☉ rite text_align(self, value: &str) -> Self! { self·prop("text-align", value) }
    ☉ rite border(self, value: &str) -> Self! { self·prop("border", value) }
    ☉ rite border_radius(self, value: &str) -> Self! { self·prop("border-radius", value) }
    ☉ rite box_shadow(self, value: &str) -> Self! { self·prop("box-shadow", value) }
    ☉ rite flex(self, value: &str) -> Self! { self·prop("flex", value) }
    ☉ rite flex_direction(self, value: &str) -> Self! { self·prop("flex-direction", value) }
    ☉ rite justify_content(self, value: &str) -> Self! { self·prop("justify-content", value) }
    ☉ rite align_items(self, value: &str) -> Self! { self·prop("align-items", value) }
    ☉ rite gap(self, value: &str) -> Self! { self·prop("gap", value) }
    ☉ rite grid(self, value: &str) -> Self! { self·prop("grid", value) }
    ☉ rite grid_template_columns(self, value: &str) -> Self! { self·prop("grid-template-columns", value) }
    ☉ rite transition(self, value: &str) -> Self! { self·prop("transition", value) }
    ☉ rite transform(self, value: &str) -> Self! { self·prop("transform", value) }
    ☉ rite opacity(self, value: &str) -> Self! { self·prop("opacity", value) }
    ☉ rite cursor(self, value: &str) -> Self! { self·prop("cursor", value) }
    ☉ rite overflow(self, value: &str) -> Self! { self·prop("overflow", value) }
    ☉ rite z_index(self, value: &str) -> Self! { self·prop("z-index", value) }

    ☉ rite to_string(&self) -> String! {
        ≔ Δ parts! = Vec·new();
        ∀ (k, v) ∈ &self.properties {
            parts·push(format!("{}: {}", k, v))
        }
        parts·join("; ")
    }
}

// =============================================================================
// CSS Class Builder
// =============================================================================

/// CSS class builder with conditional classes
☉ Σ Classes {
    classes: Vec<String>!
}

⊢ Classes {
    ☉ rite new() -> Self! {
        Classes { classes: Vec·new() }
    }

    ☉ rite add(Δ self, class: &str) -> Self! {
        self.classes·push(class.to_string());
        self
    }

    ☉ rite add_if(Δ self, condition: bool, class: &str) -> Self! {
        ⎇ condition {
            self.classes·push(class.to_string())
        }
        self
    }

    ☉ rite to_string(&self) -> String! {
        self.classes·join(" ")
    }
}

// =============================================================================
// Quick Builders
// =============================================================================

/// Quick class builder
☉ rite classes() -> Classes! {
    Classes·new()
}

/// Quick style builder
☉ rite style() -> Style! {
    Style·new()
}

/// Create text node
☉ rite text(content: &str) -> VNode! {
    VNode·text(content)
}

/// Create fragment from children
☉ rite fragment(children: Vec<VNode>) -> VNode! {
    VNode·fragment(children)
}

// =============================================================================
// Tests
// =============================================================================

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_style_builder() {
        ≔ s! = style()
            ·display("flex")
            ·color("red")
            ·to_string();

        assert!(s·contains("display: flex"))
    }

    //@ rune: test
    rite test_classes_builder() {
        ≔ c! = classes()
            ·add("btn")
            ·add_if(true, "btn-primary")
            ·add_if(false, "btn-disabled")
            ·to_string();

        assert_eq!(c, "btn btn-primary")
    }

    //@ rune: test
    rite test_text_helper() {
        ≔ t! = text("Hello");
        ⌥ t {
            VNode·Text(txt) => {
                assert_eq!(txt.content, "Hello")
            }
            _ => {}
        }
    }
}
