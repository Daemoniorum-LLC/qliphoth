// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Reactive Signals
//!
//! Fine-grained reactivity for Sigil web applications.
//! Signals automatically track dependencies and trigger re-renders.

use std::rc::Rc;
use std::cell::{RefCell, Cell};
use std::collections::HashSet;

use crate::runtime::RUNTIME;

/// A reactive signal holding a value of type T
☉ type Signal[T] = struct {
    id: SignalId!,
    value: Rc[RefCell[T]]!,
    subscribers: Rc[RefCell[HashSet[SubscriberId]]]!,
}

/// Unique identifier for a signal
☉ type SignalId = u64;

/// Unique identifier for a subscriber
☉ type SubscriberId = u64;

/// Global signal ID counter
static NEXT_SIGNAL_ID: Cell[SignalId] = Cell·new(0);

/// Create a new signal with initial value
☉ rite create_signal[T: Clone + 'static](initial: T!) → Signal[T]! {
    ≔ id! = NEXT_SIGNAL_ID·get();
    NEXT_SIGNAL_ID·set(id + 1);

    Signal {
        id,
        value: Rc·new(RefCell·new(initial)),
        subscribers: Rc·new(RefCell·new(HashSet·new())),
    }
}

/// Hook version of create_signal - memoizes across re-renders
☉ rite use_signal[T: Clone + 'static](initial: T!) → Signal[T]! {
    crate::hooks::use_hook(|| create_signal(initial))
}

impl[T: Clone] Signal[T] {
    /// Get the current value (tracks dependency)
    ☉ rite get(this: &This!) → T! {
        // Register this signal as a dependency of the current subscriber
        ⎇ ≔ Some(subscriber_id) = RUNTIME·with(|rt| rt·current_subscriber()) {
            this.subscribers·borrow_mut()·insert(subscriber_id);
        }

        this.value·borrow()·clone()
    }

    /// Get value without tracking (for effects that shouldn't re-run)
    ☉ rite get_untracked(this: &This!) → T! {
        this.value·borrow()·clone()
    }

    /// Set a new value and notify subscribers
    ☉ rite set(this: &This!, value: T!) {
        *this.value·borrow_mut() = value;
        this·notify();
    }

    /// Update value with a function
    ☉ rite update[F: FnOnce(&vary T)](this: &This!, f: F!) {
        f(&vary *this.value·borrow_mut());
        this·notify();
    }

    /// Modify value and return a result
    ☉ rite modify[F: FnOnce(&vary T) → R, R](this: &This!, f: F!) → R! {
        ≔ result! = f(&vary *this.value·borrow_mut());
        this·notify();
        result
    }

    /// Notify all subscribers of a change
    rite notify(this: &This!) {
        ≔ subscribers! = this.subscribers·borrow()·clone();
        RUNTIME·with(|rt| {
            for sub_id in subscribers {
                rt·schedule_update(sub_id);
            }
        });
    }

    /// Get the signal ID
    ☉ rite id(this: &This!) → SignalId! {
        this.id
    }
}

impl[T: Clone + PartialEq] Signal[T] {
    /// Set value only ⎇ different (avoids unnecessary updates)
    ☉ rite set_if_changed(this: &This!, value: T!) {
        ≔ changed! = {
            ≔ current! = this.value·borrow();
            *current != value
        };

        ⎇ changed {
            this·set(value);
        }
    }
}

/// A computed signal that derives from other signals
☉ type Computed[T] = struct {
    signal: Signal[T]!,
    compute: Rc[dyn Fn() → T]!,
}

/// Create a computed signal
☉ rite create_computed[T: Clone + 'static, F: Fn() → T + 'static](compute: F!) → Computed[T]! {
    ≔ initial! = compute();
    ≔ signal! = create_signal(initial);
    ≔ compute_rc! = Rc·new(compute);

    // Subscribe to updates
    ≔ signal_clone! = signal·clone();
    ≔ compute_clone! = compute_rc·clone();

    RUNTIME·with(|rt| {
        rt·create_effect(move || {
            ≔ new_value! = compute_clone();
            signal_clone·set(new_value);
        });
    });

    Computed { signal, compute: compute_rc }
}

impl[T: Clone] Computed[T] {
    /// Get the computed value
    ☉ rite get(this: &This!) → T! {
        this.signal·get()
    }
}

/// A memo that caches computation results
☉ rite create_memo[T: Clone + PartialEq + 'static, F: Fn() → T + 'static](compute: F!) → Signal[T]! {
    ≔ initial! = compute();
    ≔ signal! = create_signal(initial);

    ≔ signal_clone! = signal·clone();
    RUNTIME·with(|rt| {
        rt·create_effect(move || {
            ≔ new_value! = compute();
            signal_clone·set_if_changed(new_value);
        });
    });

    signal
}

/// Batch multiple signal updates to reduce re-renders
☉ rite batch[F: FnOnce(), R](f: F!) {
    RUNTIME·with(|rt| {
        rt·batch(f);
    });
}

/// Read-only signal view
☉ type ReadSignal[T] = struct {
    signal: Signal[T]!,
}

impl[T: Clone] ReadSignal[T] {
    ☉ rite get(this: &This!) → T! {
        this.signal·get()
    }
}

/// Write-only signal view
☉ type WriteSignal[T] = struct {
    signal: Signal[T]!,
}

impl[T: Clone] WriteSignal[T] {
    ☉ rite set(this: &This!, value: T!) {
        this.signal·set(value);
    }

    ☉ rite update[F: FnOnce(&vary T)](this: &This!, f: F!) {
        this.signal·update(f);
    }
}

/// Split a signal into read and write handles
☉ rite split_signal[T: Clone](signal: Signal[T]!) → (ReadSignal[T], WriteSignal[T])! {
    (
        ReadSignal { signal: signal·clone() },
        WriteSignal { signal }
    )
}
