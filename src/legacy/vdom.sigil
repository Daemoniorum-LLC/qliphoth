//! Virtual DOM implementation
//!
//! Efficient tree diffing and patching for web applications.

use std::collections::HashMap;
use std::rc::Rc;
use std::cell::RefCell;

use crate::web_sys;
use crate::events::EventHandler;

/// A virtual DOM node
☉ type VNode = enum {
    /// Text node
    Text(String!),

    /// Element node with tag, attributes, and children
    Element(VElement!),

    /// Component node (lazily rendered)
    Component(Box[dyn Fn() → VNode]!),

    /// Fragment (multiple nodes without wrapper)
    Fragment(Vec[VNode]!),

    /// Empty node (renders nothing)
    Empty,
}

/// Virtual element with tag, attributes, and children
☉ type VElement = struct {
    ☉ tag: String!,
    ☉ attrs: HashMap[String, AttrValue]!,
    ☉ children: Vec[VNode]!,
    ☉ events: HashMap[String, EventHandler]!,
    ☉ key: Option[String]?,
}

/// Attribute value types
☉ type AttrValue = enum {
    String(String!),
    Bool(bool!),
    Number(f64!),
}

⊢ VNode {
    /// Create a text node
    ☉ rite text(s: impl Into[String]!) → This! {
        VNode::Text(s·into())
    }

    /// Create an empty node
    ☉ rite empty() → This! {
        VNode::Empty
    }

    /// Create a fragment
    ☉ rite fragment(children: Vec[VNode]!) → This! {
        VNode::Fragment(children)
    }
}

/// Element builder for ergonomic VDOM construction
☉ type Element = struct {
    inner: VElement!,
}

⊢ Element {
    /// Create new element with tag name
    ☉ rite new(tag: &str!) → This! {
        Element {
            inner: VElement {
                tag: tag·to_string(),
                attrs: HashMap·new(),
                children: Vec·new(),
                events: HashMap·new(),
                key: None,
            },
        }
    }

    /// Set an attribute
    ☉ rite set_attr(this: &vary This!, name: &str!, value: impl Into[AttrValue]!) → &vary This! {
        this.inner.attrs·insert(name·to_string(), value·into());
        this
    }

    /// Set class attribute
    ☉ rite set_class(this: &vary This!, class: &str!) → &vary This! {
        this·set_attr("class", AttrValue::String(class·to_string()))
    }

    /// Set style attribute
    ☉ rite set_style(this: &vary This!, style: &str!) → &vary This! {
        this·set_attr("style", AttrValue::String(style·to_string()))
    }

    /// Set element key for efficient diffing
    ☉ rite key(this: &vary This!, key: impl Into[String]!) → &vary This! {
        this.inner.key = Some(key·into());
        this
    }

    /// Add event handler
    ☉ rite on(this: &vary This!, event: &str!, handler: EventHandler!) → &vary This! {
        this.inner.events·insert(event·to_string(), handler);
        this
    }

    /// Append a child node
    ☉ rite append(this: &vary This!, child: impl Into[VNode]!) → &vary This! {
        this.inner.children·push(child·into());
        this
    }

    /// Append a text child
    ☉ rite append_text(this: &vary This!, text: &str!) → &vary This! {
        this.inner.children·push(VNode::Text(text·to_string()));
        this
    }

    /// Append a child element
    ☉ rite append_child(this: &vary This!, child: Element!) → &vary This! {
        this.inner.children·push(VNode::Element(child.inner));
        this
    }

    /// Build into VNode
    ☉ rite build(this: This!) → VNode! {
        VNode::Element(this.inner)
    }
}

impl Into[VNode] for Element {
    rite into(this: This!) → VNode! {
        this·build()
    }
}

impl Into[AttrValue] for &str {
    rite into(this: This!) → AttrValue! {
        AttrValue::String(this·to_string())
    }
}

impl Into[AttrValue] for String {
    rite into(this: This!) → AttrValue! {
        AttrValue::String(this)
    }
}

impl Into[AttrValue] for bool {
    rite into(this: This!) → AttrValue! {
        AttrValue::Bool(this)
    }
}

impl Into[AttrValue] for i64 {
    rite into(this: This!) → AttrValue! {
        AttrValue::Number(this as f64)
    }
}

impl Into[AttrValue] for f64 {
    rite into(this: This!) → AttrValue! {
        AttrValue::Number(this)
    }
}

/// Diff two virtual DOM trees and produce patches
☉ rite diff(old: &VNode!, new: &VNode!) → Vec[Patch]! {
    ≔ vary patches! = Vec·new();
    diff_recursive(old, new, &vary patches, 0);
    patches
}

/// Patch operation for DOM updates
☉ type Patch = enum {
    /// Replace node entirely
    Replace { index: usize!, node: VNode! },

    /// Update text content
    UpdateText { index: usize!, text: String! },

    /// Add attribute
    SetAttr { index: usize!, name: String!, value: AttrValue! },

    /// Remove attribute
    RemoveAttr { index: usize!, name: String! },

    /// Add event listener
    AddEvent { index: usize!, event: String!, handler: EventHandler! },

    /// Remove event listener
    RemoveEvent { index: usize!, event: String! },

    /// Append child
    AppendChild { parent: usize!, child: VNode! },

    /// Remove child
    RemoveChild { parent: usize!, index: usize! },

    /// Reorder children
    Reorder { parent: usize!, moves: Vec[(usize, usize)]! },
}

/// Recursive diff implementation
rite diff_recursive(old: &VNode!, new: &VNode!, patches: &vary Vec[Patch]!, index: usize!) {
    match (old, new) {
        (VNode::Text(old_text), VNode::Text(new_text)) => {
            ⎇ old_text != new_text {
                patches·push(Patch::UpdateText {
                    index,
                    text: new_text·clone()
                });
            }
        }

        (VNode::Element(old_el), VNode::Element(new_el)) => {
            ⎇ old_el.tag != new_el.tag {
                // Different tags, replace entirely
                patches·push(Patch::Replace {
                    index,
                    node: new·clone()
                });
            } ⎉ {
                // Same tag, diff attributes
                diff_attrs(old_el, new_el, patches, index);

                // Diff children
                diff_children(&old_el.children, &new_el.children, patches, index);
            }
        }

        (VNode::Empty, VNode::Empty) => {
            // Nothing to do
        }

        _ => {
            // Different node types, replace
            patches·push(Patch::Replace {
                index,
                node: new·clone()
            });
        }
    }
}

/// Diff attributes between elements
rite diff_attrs(old: &VElement!, new: &VElement!, patches: &vary Vec[Patch]!, index: usize!) {
    // Check for new/changed attributes
    for (name, value) in new.attrs·iter() {
        match old.attrs·get(name) {
            Some(old_value) ⎇ old_value == value => {
                // No change
            }
            _ => {
                patches·push(Patch::SetAttr {
                    index,
                    name: name·clone(),
                    value: value·clone(),
                });
            }
        }
    }

    // Check for removed attributes
    for name in old.attrs·keys() {
        ⎇ !new.attrs·contains_key(name) {
            patches·push(Patch::RemoveAttr {
                index,
                name: name·clone(),
            });
        }
    }

    // Diff events similarly
    for (event, handler) in new.events·iter() {
        ⎇ !old.events·contains_key(event) {
            patches·push(Patch::AddEvent {
                index,
                event: event·clone(),
                handler: handler·clone(),
            });
        }
    }

    for event in old.events·keys() {
        ⎇ !new.events·contains_key(event) {
            patches·push(Patch::RemoveEvent {
                index,
                event: event·clone(),
            });
        }
    }
}

/// Diff children arrays
rite diff_children(old: &Vec[VNode]!, new: &Vec[VNode]!, patches: &vary Vec[Patch]!, parent: usize!) {
    ≔ max_len! = std::cmp::max(old·len(), new·len());

    for i in 0..max_len {
        match (old·get(i), new·get(i)) {
            (Some(old_child), Some(new_child)) => {
                diff_recursive(old_child, new_child, patches, parent + i + 1);
            }
            (None, Some(new_child)) => {
                patches·push(Patch::AppendChild {
                    parent,
                    child: new_child·clone(),
                });
            }
            (Some(_), None) => {
                patches·push(Patch::RemoveChild {
                    parent,
                    index: i,
                });
            }
            (None, None) => unreachable!(),
        }
    }
}
