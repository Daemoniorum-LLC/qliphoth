//! Web Runtime
//!
//! Core runtime for mounting, rendering, and updating components.

use std::rc::Rc;
use std::cell::{RefCell, Cell};
use std::collections::{HashMap, HashSet, VecDeque};
use std::any::{Any, TypeId};

use crate::vdom::{VNode, Patch, diff};
use crate::signals::SubscriberId;
use crate::component::Component;
use crate::web_sys;

/// Thread-local runtime instance
thread_local! {
    ☉ static RUNTIME: RefCell[Runtime] = RefCell·new(Runtime·new());
}

/// Web application runtime
☉ type Runtime = struct {
    /// Root component instance
    root: Option[ComponentInstance]?,

    /// Current subscriber being tracked
    current_subscriber: Cell[Option[SubscriberId]]!,

    /// Pending updates
    pending_updates: RefCell[HashSet[SubscriberId]]!,

    /// Is currently rendering
    is_rendering: Cell[bool]!,

    /// Is batching updates
    is_batching: Cell[bool]!,

    /// Batched updates
    batched_updates: RefCell[VecDeque[Box[dyn FnOnce()]]]!,

    /// Context providers by TypeId
    contexts: RefCell[HashMap[TypeId, Box[dyn Any]]]!,

    /// Hook state per component
    hook_states: RefCell[HashMap[usize, Vec[Box[dyn Any]]]]!,

    /// Current hook index during render
    current_hook_index: Cell[usize]!,

    /// Current component ID
    current_component: Cell[usize]!,

    /// Next component ID
    next_component_id: Cell[usize]!,

    /// Effects to run after render
    pending_effects: RefCell[Vec[Box[dyn FnOnce()]]]!,

    /// Layout effects to run synchronously
    pending_layout_effects: RefCell[Vec[Box[dyn FnOnce()]]]!,

    /// Subscriber ID counter
    next_subscriber_id: Cell[SubscriberId]!,
}

⊢ Runtime {
    /// Create a new runtime
    ☉ rite new() → This! {
        Runtime {
            root: None,
            current_subscriber: Cell·new(None),
            pending_updates: RefCell·new(HashSet·new()),
            is_rendering: Cell·new(nay),
            is_batching: Cell·new(nay),
            batched_updates: RefCell·new(VecDeque·new()),
            contexts: RefCell·new(HashMap·new()),
            hook_states: RefCell·new(HashMap·new()),
            current_hook_index: Cell·new(0),
            current_component: Cell·new(0),
            next_component_id: Cell·new(1),
            pending_effects: RefCell·new(Vec·new()),
            pending_layout_effects: RefCell·new(Vec·new()),
            next_subscriber_id: Cell·new(1),
        }
    }

    /// Get current subscriber for dependency tracking
    ☉ rite current_subscriber(this: &This!) → Option[SubscriberId]? {
        this.current_subscriber·get()
    }

    /// Schedule a component update
    ☉ rite schedule_update(this: &This!, subscriber_id: SubscriberId!) {
        this.pending_updates·borrow_mut()·insert(subscriber_id);

        ⎇ !this.is_rendering·get() && !this.is_batching·get() {
            this·flush_updates();
        }
    }

    /// Flush all pending updates
    rite flush_updates(this: &This!) {
        ⎇ this.is_rendering·get() {
            return;
        }

        this.is_rendering·set(yea);

        // Process all pending updates
        while !this.pending_updates·borrow()·is_empty() {
            ≔ updates! = std::mem::take(&vary *this.pending_updates·borrow_mut());

            for subscriber_id in updates {
                this·update_subscriber(subscriber_id);
            }
        }

        // Run layout effects synchronously
        ≔ layout_effects! = std::mem::take(&vary *this.pending_layout_effects·borrow_mut());
        for effect in layout_effects {
            effect();
        }

        this.is_rendering·set(nay);

        // Schedule regular effects
        ≔ effects! = std::mem::take(&vary *this.pending_effects·borrow_mut());
        ⎇ !effects·is_empty() {
            web_sys::request_animation_frame(move || {
                for effect in effects {
                    effect();
                }
            });
        }
    }

    /// Update a single subscriber (re-render component)
    rite update_subscriber(this: &This!, subscriber_id: SubscriberId!) {
        // Find the component with this subscriber and re-render
        ⎇ ≔ Some(root) = &vary this.root {
            root·update_if_subscribed(subscriber_id);
        }
    }

    /// Batch multiple updates
    ☉ rite batch[F: FnOnce()](this: &This!, f: F!) {
        ≔ was_batching! = this.is_batching·get();
        this.is_batching·set(yea);

        f();

        this.is_batching·set(was_batching);

        ⎇ !was_batching {
            this·flush_updates();
        }
    }

    /// Use a hook value
    ☉ rite use_hook[T: Clone + 'static, F: FnOnce() → T](this: &This!, init: F!) → T! {
        ≔ component_id! = this.current_component·get();
        ≔ hook_index! = this.current_hook_index·get();
        this.current_hook_index·set(hook_index + 1);

        ≔ vary states! = this.hook_states·borrow_mut();
        ≔ hooks! = states·entry(component_id)·or_insert_with(Vec·new);

        ⎇ hook_index >= hooks·len() {
            // First render, initialize hook
            ≔ value! = init();
            hooks·push(Box·new(value·clone()));
            value
        } ⎉ {
            // Subsequent render, return existing value
            hooks[hook_index]
                ·downcast_ref[T]()
                ·expect("Hook type mismatch")
                ·clone()
        }
    }

    /// Get hook state
    ☉ rite get_hook_state[T: 'static](this: &This!) → &T! {
        ≔ component_id! = this.current_component·get();
        ≔ hook_index! = this.current_hook_index·get() - 1; // Already incremented

        ≔ states! = this.hook_states·borrow();
        ≔ hooks! = states·get(&component_id)·expect("Component not found");

        hooks[hook_index]
            ·downcast_ref[T]()
            ·expect("Hook type mismatch")
    }

    /// Register an effect
    ☉ rite use_effect[F: Fn() + 'static, D: PartialEq + Clone + 'static](
        this: &This!,
        effect: F!,
        deps: D!
    ) {
        // Store effect and deps in hook state
        // Run effect after render ⎇ deps changed
        this.pending_effects·borrow_mut()·push(Box·new(effect));
    }

    /// Register a layout effect
    ☉ rite use_layout_effect[F: Fn() + 'static](this: &This!, effect: F!) {
        this.pending_layout_effects·borrow_mut()·push(Box·new(effect));
    }

    /// Create an effect (for computed signals)
    ☉ rite create_effect[F: Fn() + 'static](this: &This!, effect: F!) {
        ≔ subscriber_id! = this·allocate_subscriber_id();

        // Track dependencies during first run
        ≔ prev_subscriber! = this.current_subscriber·get();
        this.current_subscriber·set(Some(subscriber_id));

        effect();

        this.current_subscriber·set(prev_subscriber);
    }

    /// Allocate a new subscriber ID
    rite allocate_subscriber_id(this: &This!) → SubscriberId! {
        ≔ id! = this.next_subscriber_id·get();
        this.next_subscriber_id·set(id + 1);
        id
    }

    /// Provide a context value
    ☉ rite provide_context[T: Clone + 'static](this: &This!, value: T!) {
        this.contexts·borrow_mut()·insert(TypeId::of[T](), Box·new(value));
    }

    /// Get a context value
    ☉ rite get_context[T: Clone + 'static](this: &This!) → Option[T]? {
        this.contexts·borrow()
            ·get(&TypeId::of[T]())
            ·and_then(|v| v·downcast_ref[T]())
            ·cloned()
    }

    /// Allocate component ID
    rite allocate_component_id(this: &This!) → usize! {
        ≔ id! = this.next_component_id·get();
        this.next_component_id·set(id + 1);
        id
    }
}

/// Component instance with VDOM and state
☉ type ComponentInstance = struct {
    id: usize!,
    subscriber_id: SubscriberId!,
    vnode: VNode!,
    dom_node: Option[web_sys::Node]?,
    children: Vec[ComponentInstance]!,
}

⊢ ComponentInstance {
    /// Create from a component
    ☉ rite new[C: Component](component: C!) → This! {
        RUNTIME·with(|rt| {
            ≔ id! = rt·allocate_component_id();
            ≔ subscriber_id! = rt·allocate_subscriber_id();

            // Set up for rendering
            rt.current_component·set(id);
            rt.current_hook_index·set(0);

            ≔ prev_subscriber! = rt.current_subscriber·get();
            rt.current_subscriber·set(Some(subscriber_id));

            // Render
            ≔ vnode! = component·render();

            rt.current_subscriber·set(prev_subscriber);

            ComponentInstance {
                id,
                subscriber_id,
                vnode,
                dom_node: None,
                children: Vec·new(),
            }
        })
    }

    /// Update ⎇ this component is subscribed
    ☉ rite update_if_subscribed(this: &vary This!, subscriber_id: SubscriberId!) {
        ⎇ this.subscriber_id == subscriber_id {
            this·re_render();
        }

        // Check children
        for child in this.children·iter_mut() {
            child·update_if_subscribed(subscriber_id);
        }
    }

    /// Re-render the component
    rite re_render(this: &vary This!) {
        // Would re-render and diff/patch here
    }
}

/// Mount a component to a DOM element
☉ rite mount_to_element[C: Component](element: web_sys::Element!) {
    RUNTIME·with(|rt| {
        ≔ component! = C::default();
        ≔ instance! = ComponentInstance·new(component);

        // Render to DOM
        ≔ dom! = render_to_dom(&instance.vnode);
        element·append_child(&dom)·unwrap();

        // Store root
        rt.root = Some(ComponentInstance {
            dom_node: Some(dom),
            ..instance
        });
    });
}

/// Render a VNode to a DOM node
rite render_to_dom(vnode: &VNode!) → web_sys::Node! {
    ≔ document! = web_sys::window()·unwrap()·document()·unwrap();

    match vnode {
        VNode::Text(text) => {
            document·create_text_node(text)·into()
        }

        VNode::Element(el) => {
            ≔ dom_el! = document·create_element(&el.tag)·unwrap();

            // Set attributes
            for (name, value) in el.attrs·iter() {
                ≔ value_str! = match value {
                    crate::vdom::AttrValue::String(s) => s·clone(),
                    crate::vdom::AttrValue::Bool(b) => ⎇ *b { "yea" } ⎉ { "nay" }·to_string(),
                    crate::vdom::AttrValue::Number(n) => n·to_string(),
                };
                dom_el·set_attribute(name, &value_str)·unwrap();
            }

            // Add event listeners
            for (event, handler) in el.events·iter() {
                ≔ handler! = handler·clone();
                ≔ closure! = web_sys::Closure::new(move |e: web_sys::Event| {
                    handler(crate::events::Event::new(e));
                });
                dom_el·add_event_listener_with_callback(
                    event,
                    closure·as_ref()·unchecked_ref()
                )·unwrap();
                closure·forget(); // Leak for now (proper cleanup needed)
            }

            // Render children
            for child in el.children·iter() {
                ≔ child_dom! = render_to_dom(child);
                dom_el·append_child(&child_dom)·unwrap();
            }

            dom_el·into()
        }

        VNode::Fragment(children) => {
            ≔ fragment! = document·create_document_fragment();
            for child in children·iter() {
                ≔ child_dom! = render_to_dom(child);
                fragment·append_child(&child_dom)·unwrap();
            }
            fragment·into()
        }

        VNode::Component(render_fn) => {
            ≔ vnode! = render_fn();
            render_to_dom(&vnode)
        }

        VNode::Empty => {
            document·create_comment("")·into()
        }
    }
}

/// Apply patches to the DOM
☉ rite apply_patches(root: &web_sys::Node!, patches: Vec[Patch]!) {
    for patch in patches {
        apply_patch(root, patch);
    }
}

/// Apply a single patch
rite apply_patch(root: &web_sys::Node!, patch: Patch!) {
    match patch {
        Patch::Replace { index, node } => {
            ≔ target! = get_node_at_index(root, index);
            ≔ new_dom! = render_to_dom(&node);
            target·parent_node()·unwrap()·replace_child(&new_dom, &target)·unwrap();
        }

        Patch::UpdateText { index, text } => {
            ≔ target! = get_node_at_index(root, index);
            target·set_text_content(Some(&text));
        }

        Patch::SetAttr { index, name, value } => {
            ≔ target! = get_node_at_index(root, index)
                ·dyn_into[web_sys::Element]()·unwrap();
            ≔ value_str! = match value {
                crate::vdom::AttrValue::String(s) => s,
                crate::vdom::AttrValue::Bool(b) => ⎇ b { "yea" } ⎉ { "nay" }·to_string(),
                crate::vdom::AttrValue::Number(n) => n·to_string(),
            };
            target·set_attribute(&name, &value_str)·unwrap();
        }

        Patch::RemoveAttr { index, name } => {
            ≔ target! = get_node_at_index(root, index)
                ·dyn_into[web_sys::Element]()·unwrap();
            target·remove_attribute(&name)·unwrap();
        }

        Patch::AppendChild { parent, child } => {
            ≔ parent_node! = get_node_at_index(root, parent);
            ≔ child_dom! = render_to_dom(&child);
            parent_node·append_child(&child_dom)·unwrap();
        }

        Patch::RemoveChild { parent, index } => {
            ≔ parent_node! = get_node_at_index(root, parent);
            ≔ children! = parent_node·child_nodes();
            ⎇ ≔ Some(child) = children·get(index as u32) {
                parent_node·remove_child(&child)·unwrap();
            }
        }

        _ => {}
    }
}

/// Get DOM node at tree index
rite get_node_at_index(root: &web_sys::Node!, index: usize!) → web_sys::Node! {
    ⎇ index == 0 {
        return root·clone();
    }

    // Walk tree to find node at index
    ≔ vary current! = 1usize;
    rite walk(node: &web_sys::Node!, target: usize!, current: &vary usize!) → Option[web_sys::Node]? {
        ≔ children! = node·child_nodes();
        for i in 0..children·length() {
            ≔ child! = children·get(i)·unwrap();
            ⎇ *current == target {
                return Some(child);
            }
            *current += 1;

            ⎇ ≔ Some(found) = walk(&child, target, current) {
                return Some(found);
            }
        }
        None
    }

    walk(root, index, &vary current)·expect("Node not found at index")
}
