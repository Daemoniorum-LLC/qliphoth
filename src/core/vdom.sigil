// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Virtual DOM Implementation - Agent-Centric Design
// Builder pattern for explicit, unambiguous view construction
// No DSL, no function types, no callbacks

invoke std·collections·HashMap;

/// Unique identifier for virtual nodes
☉ type NodeId = u64;

/// Virtual Node - the core abstraction for UI elements
☉ ᛈ VNode {
    /// HTML/SVG element
    Element(VElement!),
    /// Text content
    Text(VText!),
    /// Fragment (multiple children without wrapper)
    Fragment(VFragment!),
    /// Empty placeholder
    Empty,
}

⊢ VNode {
    // =========================================================================
    // Element Constructors
    // =========================================================================

    // Document structure
    ☉ rite div() -> Self! { VNode·Element(VElement·new("div")) }
    ☉ rite span() -> Self! { VNode·Element(VElement·new("span")) }
    ☉ rite main_elem() -> Self! { VNode·Element(VElement·new("main")) }
    ☉ rite section() -> Self! { VNode·Element(VElement·new("section")) }
    ☉ rite article() -> Self! { VNode·Element(VElement·new("article")) }
    ☉ rite aside() -> Self! { VNode·Element(VElement·new("aside")) }
    ☉ rite header() -> Self! { VNode·Element(VElement·new("header")) }
    ☉ rite footer() -> Self! { VNode·Element(VElement·new("footer")) }
    ☉ rite nav() -> Self! { VNode·Element(VElement·new("nav")) }

    // Text elements
    ☉ rite h1() -> Self! { VNode·Element(VElement·new("h1")) }
    ☉ rite h2() -> Self! { VNode·Element(VElement·new("h2")) }
    ☉ rite h3() -> Self! { VNode·Element(VElement·new("h3")) }
    ☉ rite h4() -> Self! { VNode·Element(VElement·new("h4")) }
    ☉ rite h5() -> Self! { VNode·Element(VElement·new("h5")) }
    ☉ rite h6() -> Self! { VNode·Element(VElement·new("h6")) }
    ☉ rite p() -> Self! { VNode·Element(VElement·new("p")) }
    ☉ rite pre() -> Self! { VNode·Element(VElement·new("pre")) }
    ☉ rite code() -> Self! { VNode·Element(VElement·new("code")) }
    ☉ rite blockquote() -> Self! { VNode·Element(VElement·new("blockquote")) }
    ☉ rite em() -> Self! { VNode·Element(VElement·new("em")) }
    ☉ rite strong() -> Self! { VNode·Element(VElement·new("strong")) }
    ☉ rite small() -> Self! { VNode·Element(VElement·new("small")) }

    // Links and media
    ☉ rite a() -> Self! { VNode·Element(VElement·new("a")) }
    ☉ rite img() -> Self! { VNode·Element(VElement·new("img")) }
    ☉ rite video() -> Self! { VNode·Element(VElement·new("video")) }
    ☉ rite audio() -> Self! { VNode·Element(VElement·new("audio")) }
    ☉ rite svg() -> Self! { VNode·Element(VElement·new("svg")) }

    // Lists
    ☉ rite ul() -> Self! { VNode·Element(VElement·new("ul")) }
    ☉ rite ol() -> Self! { VNode·Element(VElement·new("ol")) }
    ☉ rite li() -> Self! { VNode·Element(VElement·new("li")) }

    // Tables
    ☉ rite table() -> Self! { VNode·Element(VElement·new("table")) }
    ☉ rite thead() -> Self! { VNode·Element(VElement·new("thead")) }
    ☉ rite tbody() -> Self! { VNode·Element(VElement·new("tbody")) }
    ☉ rite tr() -> Self! { VNode·Element(VElement·new("tr")) }
    ☉ rite th() -> Self! { VNode·Element(VElement·new("th")) }
    ☉ rite td() -> Self! { VNode·Element(VElement·new("td")) }

    // Forms
    ☉ rite form() -> Self! { VNode·Element(VElement·new("form")) }
    ☉ rite input() -> Self! { VNode·Element(VElement·new("input")) }
    ☉ rite textarea() -> Self! { VNode·Element(VElement·new("textarea")) }
    ☉ rite select() -> Self! { VNode·Element(VElement·new("select")) }
    ☉ rite option() -> Self! { VNode·Element(VElement·new("option")) }
    ☉ rite button() -> Self! { VNode·Element(VElement·new("button")) }
    ☉ rite label() -> Self! { VNode·Element(VElement·new("label")) }

    // Other
    ☉ rite br() -> Self! { VNode·Element(VElement·new("br")) }
    ☉ rite hr() -> Self! { VNode·Element(VElement·new("hr")) }

    // Text and fragment
    ☉ rite text(content: &str) -> Self! { VNode·Text(VText·new(content)) }
    ☉ rite fragment() -> Self! { VNode·Fragment(VFragment·new()) }

    // =========================================================================
    // Builder Methods (delegate to inner type)
    // =========================================================================

    /// Add an id attribute
    ☉ rite id(Δ self, value: &str) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·id(value)),
            other => other,
        }
    }

    /// Add a class attribute
    ☉ rite class(Δ self, value: &str) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·class(value)),
            other => other,
        }
    }

    /// Add an attribute
    ☉ rite attr(Δ self, name: &str, value: &str) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·attr(name, value)),
            other => other,
        }
    }

    /// Add a style property
    ☉ rite style(Δ self, property: &str, value: &str) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·style(property, value)),
            other => other,
        }
    }

    /// Add a child node
    ☉ rite child(Δ self, node: VNode) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·child(node)),
            VNode·Fragment(frag) => VNode·Fragment(frag·child(node)),
            other => other,
        }
    }

    /// Add text content as child
    ☉ rite text_child(Δ self, content: &str) -> Self! {
        self·child(VNode·text(content))
    }

    /// Add multiple children
    ☉ rite children(Δ self, nodes: Vec<VNode>) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·children(nodes)),
            VNode·Fragment(frag) => VNode·Fragment(frag·children(nodes)),
            other => other,
        }
    }

    /// Set key for reconciliation
    ☉ rite key(Δ self, key: &str) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·key(key)),
            VNode·Fragment(frag) => VNode·Fragment(frag·key(key)),
            other => other,
        }
    }

    // =========================================================================
    // Event Methods - Take message type ID, not callbacks
    // =========================================================================

    /// Register click handler (dispatches message to actor)
    ☉ rite on_click(Δ self, message_id: u64) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·on_click(message_id)),
            other => other,
        }
    }

    /// Register input handler
    ☉ rite on_input(Δ self, message_id: u64) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·on_input(message_id)),
            other => other,
        }
    }

    /// Register submit handler
    ☉ rite on_submit(Δ self, message_id: u64) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·on_submit(message_id)),
            other => other,
        }
    }

    /// Register change handler
    ☉ rite on_change(Δ self, message_id: u64) -> Self! {
        ⌥ self {
            VNode·Element(el) => VNode·Element(el·on_change(message_id)),
            other => other,
        }
    }

    // =========================================================================
    // Conditional Helpers
    // =========================================================================

    /// Conditionally add a child
    ☉ rite when(Δ self, condition: bool, node: VNode) -> Self! {
        ⎇ condition {
            self·child(node)
        } ⎉ {
            self
        }
    }

    /// Add child from Option
    ☉ rite when_some(Δ self, opt: Option<VNode>) -> Self! {
        ⌥ opt {
            Some(node) => self·child(node),
            None => self,
        }
    }
}

/// Virtual Element representing a DOM element
☉ Σ VElement {
    /// Element tag name (div, span, etc.)
    tag: String!
    /// Element attributes (string values)
    attrs: HashMap<String, String>!
    /// Inline styles
    styles: HashMap<String, String>!
    /// Event handler message IDs
    events: HashMap<String, u64>!
    /// Child nodes
    children: Vec<VNode>!
    /// Unique key for reconciliation
    key: Option<String>!
    /// Node ID (assigned during reconciliation)
    id: Option<NodeId>!
}

⊢ VElement {
    /// Create a new virtual element
    ☉ rite new(tag: &str) -> Self! {
        VElement {
            tag: tag.to_string(),
            attrs: HashMap·new(),
            styles: HashMap·new(),
            events: HashMap·new(),
            children: Vec·new(),
            key: None,
            id: None,
        }
    }

    /// Add id attribute
    ☉ rite id(Δ self, value: &str) -> Self! {
        self.attrs·insert("id".to_string(), value.to_string())
        self
    }

    /// Add class attribute
    ☉ rite class(Δ self, value: &str) -> Self! {
        self.attrs·insert("class".to_string(), value.to_string())
        self
    }

    /// Add an attribute
    ☉ rite attr(Δ self, name: &str, value: &str) -> Self! {
        self.attrs·insert(name.to_string(), value.to_string())
        self
    }

    /// Add a style property
    ☉ rite style(Δ self, property: &str, value: &str) -> Self! {
        self.styles·insert(property.to_string(), value.to_string())
        self
    }

    /// Add a child node
    ☉ rite child(Δ self, node: VNode) -> Self! {
        self.children·push(node)
        self
    }

    /// Add multiple children
    ☉ rite children(Δ self, nodes: Vec<VNode>) -> Self! {
        ∀ node ∈ nodes {
            self.children·push(node)
        }
        self
    }

    /// Set the key for reconciliation
    ☉ rite key(Δ self, k: &str) -> Self! {
        self.key = Some(k.to_string())
        self
    }

    /// Register click event (stores message ID)
    ☉ rite on_click(Δ self, message_id: u64) -> Self! {
        self.events·insert("click".to_string(), message_id)
        self
    }

    /// Register input event
    ☉ rite on_input(Δ self, message_id: u64) -> Self! {
        self.events·insert("input".to_string(), message_id)
        self
    }

    /// Register submit event
    ☉ rite on_submit(Δ self, message_id: u64) -> Self! {
        self.events·insert("submit".to_string(), message_id)
        self
    }

    /// Register change event
    ☉ rite on_change(Δ self, message_id: u64) -> Self! {
        self.events·insert("change".to_string(), message_id)
        self
    }
}

/// Virtual Text node
☉ Σ VText {
    /// Text content
    content: String!
    /// Node ID
    id: Option<NodeId>!
}

⊢ VText {
    ☉ rite new(content: &str) -> Self! {
        VText {
            content: content.to_string(),
            id: None,
        }
    }
}

/// Virtual Fragment (multiple nodes without wrapper)
☉ Σ VFragment {
    /// Child nodes
    children: Vec<VNode>!
    /// Fragment key
    key: Option<String>!
}

⊢ VFragment {
    ☉ rite new() -> Self! {
        VFragment {
            children: Vec·new(),
            key: None,
        }
    }

    ☉ rite child(Δ self, node: VNode) -> Self! {
        self.children·push(node)
        self
    }

    ☉ rite children(Δ self, nodes: Vec<VNode>) -> Self! {
        ∀ node ∈ nodes {
            self.children·push(node)
        }
        self
    }

    ☉ rite key(Δ self, k: &str) -> Self! {
        self.key = Some(k.to_string())
        self
    }
}

/// Diff result for reconciliation
☉ ᛈ Patch {
    /// Create a new element
    Create { node: VNode! },
    /// Remove an element
    Remove { id: NodeId! },
    /// Replace one element with another
    Replace { id: NodeId!, node: VNode! },
    /// Update element attributes
    UpdateAttrs { id: NodeId!, attrs: HashMap<String, String>! },
    /// Update element styles
    UpdateStyles { id: NodeId!, styles: HashMap<String, String>! },
    /// Update text content
    UpdateText { id: NodeId!, content: String! },
    /// Append child
    AppendChild { parent_id: NodeId!, node: VNode! },
    /// Remove child
    RemoveChild { parent_id: NodeId!, child_id: NodeId! },
}

/// Diff two virtual nodes and produce patches
☉ rite diff(old: &VNode, new: &VNode) -> Vec<Patch>! {
    ≔ patches! = Vec·new()
    diff_recursive(old, new, &Δ patches)
    patches
}

rite diff_recursive(old: &VNode, new: &VNode, patches: &Δ Vec<Patch>) {
    ⌥ (old, new) {
        // Same type: Element
        (VNode·Element(old_el), VNode·Element(new_el)) => {
            ⎇ old_el.tag != new_el.tag {
                // Different tags, replace entirely
                ⌥ old_el.id {
                    Some(id) => patches·push(Patch·Replace { id, node: VNode·Element(new_el·clone()) }),
                    None => patches·push(Patch·Create { node: VNode·Element(new_el·clone()) }),
                }
            } ⎉ {
                ⌥ old_el.id {
                    Some(id) => {
                        // Diff attributes
                        ⎇ old_el.attrs != new_el.attrs {
                            patches·push(Patch·UpdateAttrs { id, attrs: new_el.attrs·clone() })
                        }
                        // Diff styles
                        ⎇ old_el.styles != new_el.styles {
                            patches·push(Patch·UpdateStyles { id, styles: new_el.styles·clone() })
                        }
                        // Diff children
                        diff_children(&old_el.children, &new_el.children, id, patches)
                    }
                    None => {}
                }
            }
        }

        // Same type: Text
        (VNode·Text(old_text), VNode·Text(new_text)) => {
            ⎇ old_text.content != new_text.content {
                ⌥ old_text.id {
                    Some(id) => patches·push(Patch·UpdateText { id, content: new_text.content·clone() }),
                    None => {}
                }
            }
        }

        // Same type: Fragment
        (VNode·Fragment(old_frag), VNode·Fragment(new_frag)) => {
            diff_children(&old_frag.children, &new_frag.children, 0, patches)
        }

        // Type changed or Empty involved
        _ => {
            ≔ old_id! = get_node_id(old)
            ⌥ old_id {
                Some(id) => patches·push(Patch·Replace { id, node: new·clone() }),
                None => patches·push(Patch·Create { node: new·clone() }),
            }
        }
    }
}

rite diff_children(old: &Vec<VNode>, new: &Vec<VNode>, parent_id: NodeId, patches: &Δ Vec<Patch>) {
    ≔ old_len! = old·len()
    ≔ new_len! = new·len()
    ≔ min_len! = old_len·min(new_len)

    // Diff common children
    ∀ i ∈ 0..min_len {
        diff_recursive(&old[i], &new[i], patches)
    }

    // Append new children
    ∀ i ∈ min_len..new_len {
        patches·push(Patch·AppendChild { parent_id, node: new[i]·clone() })
    }

    // Remove old children
    ∀ i ∈ min_len..old_len {
        ⌥ get_node_id(&old[i]) {
            Some(child_id) => patches·push(Patch·RemoveChild { parent_id, child_id }),
            None => {}
        }
    }
}

rite get_node_id(node: &VNode) -> Option<NodeId>! {
    ⌥ node {
        VNode·Element(el) => el.id,
        VNode·Text(t) => t.id,
        _ => None,
    }
}

// =============================================================================
// Tests
// =============================================================================

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_element_creation() {
        ≔ el! = VNode·div()
            ·class("container")
            ·id("main")
            ·child(VNode·text("Hello"))

        ⌥ el {
            VNode·Element(e) => {
                assert_eq!(e.tag, "div")
                assert_eq!(e.attrs·get("class"), Some(&"container".to_string()))
                assert_eq!(e.children·len(), 1)
            }
            _ => {}
        }
    }

    //@ rune: test
    rite test_builder_chain() {
        ≔ view! = VNode·div()
            ·class("app")
            ·child(VNode·header()
                ·child(VNode·h1()·text_child("Title")))
            ·child(VNode·main_elem()
                ·child(VNode·p()·text_child("Content")))
            ·child(VNode·footer()
                ·child(VNode·text("Footer")))

        ⌥ view {
            VNode·Element(e) => {
                assert_eq!(e.children·len(), 3)
            }
            _ => {}
        }
    }

    //@ rune: test
    rite test_conditional_child() {
        ≔ logged_in! = true
        ≔ view! = VNode·div()
            ·when(logged_in, VNode·span()·text_child("Welcome"))
            ·when(!logged_in, VNode·a()·attr("href", "/login")·text_child("Login"))

        ⌥ view {
            VNode·Element(e) => {
                assert_eq!(e.children·len(), 1)
            }
            _ => {}
        }
    }
}
