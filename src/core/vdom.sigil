// Virtual DOM Implementation
// Efficient tree diffing and patching with evidentiality-aware updates

use std::collections::HashMap;
use crate::core::events::{EventHandler, EventType};

/// Unique identifier for virtual nodes
☉ type NodeId = u64;

/// Virtual Node - the core abstraction for UI elements
☉ enum VNode {
    /// HTML/SVG element
    Element(VElement!),
    /// Text content
    Text(VText!),
    /// Fragment (multiple children without wrapper)
    Fragment(VFragment!),
    /// Component instance
    Component(VComponent!),
    /// Empty placeholder
    Empty,
    /// Portal (render in different DOM location)
    Portal(VPortal!)
}

/// Virtual Element representing a DOM element
☉ sigil VElement {
    /// Element tag name (div, span, etc.)
    tag: String!
    /// Element attributes
    attrs: HashMap<String, AttrValue>!
    /// Element properties (for DOM properties vs attributes)
    props: HashMap<String, PropValue>!
    /// Event handlers
    events: HashMap<EventType, EventHandler>!
    /// Child nodes
    children: Vec<VNode>!
    /// Unique key for reconciliation
    key: Option<String>?
    /// Reference callback
    ref_callback: Option<fn(&DomRef)>?
    /// Namespace (for SVG, MathML)
    namespace: Option<String>?
    /// Node ID (assigned during reconciliation)
    id: Option<NodeId>?
}

⊢ VElement {
    /// Create a new virtual element
    ☉ rite new(tag: &str) → This! {
        VElement {
            tag: tag.to_string(),
            attrs: HashMap::new(),
            props: HashMap::new(),
            events: HashMap::new(),
            children: Vec::new(),
            key: None,
            ref_callback: None,
            namespace: None,
            id: None
        }
    }

    /// Add an attribute
    ☉ rite attr(vary this, name: &str, value: impl Into<AttrValue>) → This! {
        this.attrs·insert(name.to_string(), value·into())
        this
    }

    /// Add a property
    ☉ rite prop(vary this, name: &str, value: impl Into<PropValue>) → This! {
        this.props·insert(name.to_string(), value·into())
        this
    }

    /// Add an event handler
    ☉ rite on(vary this, event: EventType, handler: EventHandler) → This! {
        this.events·insert(event, handler)
        this
    }

    /// Add a child node
    ☉ rite child(vary this, node: impl Into<VNode>) → This! {
        this.children·push(node·into())
        this
    }

    /// Add multiple children
    ☉ rite children(vary this, nodes: impl IntoIterator<Item = impl Into<VNode>>) → This! {
        this.children·extend(nodes|τ{n => n·into()})
        this
    }

    /// Set the key for reconciliation
    ☉ rite key(vary this, key: &str) → This! {
        this.key = Some(key.to_string())
        this
    }

    /// Set a ref callback
    ☉ rite ref_cb(vary this, callback: fn(&DomRef)) → This! {
        this.ref_callback = Some(callback)
        this
    }
}

/// Attribute value types
☉ enum AttrValue {
    String(String!),
    Bool(bool!),
    Number(f64!),
    /// Uncertain value (may not be set)
    Uncertain(Option<String>?),
    /// Remote value (from external source)
    Remote(String~)
}

⊢ AttrValue : From<&str> {
    rite from(s: &str) → This! {
        AttrValue::String(s.to_string())
    }
}

⊢ AttrValue : From<String> {
    rite from(s: String) → This! {
        AttrValue::String(s)
    }
}

⊢ AttrValue : From<bool> {
    rite from(b: bool) → This! {
        AttrValue::Bool(b)
    }
}

⊢ AttrValue : From<i64> {
    rite from(n: i64) → This! {
        AttrValue::Number(n as f64)
    }
}

⊢ AttrValue : From<f64> {
    rite from(n: f64) → This! {
        AttrValue::Number(n)
    }
}

/// Property value types (for DOM properties)
☉ enum PropValue {
    String(String!),
    Bool(bool!),
    Number(f64!),
    Object(HashMap<String, PropValue>!),
    Array(Vec<PropValue>!),
    Function(fn() → ()),
    Null
}

/// Virtual Text node
☉ sigil VText {
    /// Text content
    content: String!
    /// Node ID
    id: Option<NodeId>?
}

⊢ VText {
    ☉ rite new(content: &str) → This! {
        VText {
            content: content.to_string(),
            id: None
        }
    }
}

⊢ VNode : From<&str> {
    rite from(s: &str) → This! {
        VNode::Text(VText::new(s))
    }
}

⊢ VNode : From<String> {
    rite from(s: String) → This! {
        VNode::Text(VText::new(&s))
    }
}

/// Virtual Fragment (multiple nodes without wrapper)
☉ sigil VFragment {
    /// Child nodes
    children: Vec<VNode>!
    /// Fragment key
    key: Option<String>?
}

⊢ VFragment {
    ☉ rite new(children: Vec<VNode>) → This! {
        VFragment {
            children: children,
            key: None
        }
    }

    ☉ rite key(vary this, key: &str) → This! {
        this.key = Some(key.to_string())
        this
    }
}

/// Virtual Component wrapper
☉ sigil VComponent {
    /// Component type identifier
    type_id: u64!
    /// Component props (as dynamic map)
    props: HashMap<String, PropValue>!
    /// Component key
    key: Option<String>?
    /// Render function
    render: fn(HashMap<String, PropValue>) → VNode
    /// Component instance ID
    id: Option<NodeId>?
}

⊢ VComponent {
    ☉ rite new<C: Component>(component: C) → This! {
        VComponent {
            type_id: C::type_id(),
            props: component·props_to_map(),
            key: None,
            render: C::render_static,
            id: None
        }
    }

    ☉ rite key(vary this, key: &str) → This! {
        this.key = Some(key.to_string())
        this
    }
}

/// Portal for rendering in a different DOM location
☉ sigil VPortal {
    /// Target container selector
    target: String!
    /// Child nodes to render in target
    children: Vec<VNode>!
}

⊢ VPortal {
    ☉ rite new(target: &str, children: Vec<VNode>) → This! {
        VPortal {
            target: target.to_string(),
            children: children
        }
    }
}

/// Reference to actual DOM element
☉ sigil DomRef {
    /// Element pointer (platform-specific)
    element: *mut ()
}

⊢ DomRef {
    /// Focus the element
    ☉ rite focus(this) {
        // Platform-specific implementation
    }

    /// Blur the element
    ☉ rite blur(this) {
        // Platform-specific implementation
    }

    /// Scroll element into view
    ☉ rite scroll_into_view(this) {
        // Platform-specific implementation
    }

    /// Get bounding client rect
    ☉ rite get_bounding_rect(this) → Rect! {
        // Platform-specific implementation
        Rect::default()
    }
}

/// Rectangle dimensions
☉ sigil Rect {
    x: f64!
    y: f64!
    width: f64!
    height: f64!
}

⊢ Rect {
    ☉ rite default() → This! {
        Rect { x: 0.0, y: 0.0, width: 0.0, height: 0.0 }
    }
}

/// Diff result for reconciliation
☉ enum Patch {
    /// Create a new element
    Create(VNode!),
    /// Remove an element
    Remove(NodeId!),
    /// Replace one element with another
    Replace(NodeId!, VNode!),
    /// Update element attributes
    UpdateAttrs(NodeId!, HashMap<String, AttrValue>!),
    /// Update element properties
    UpdateProps(NodeId!, HashMap<String, PropValue>!),
    /// Update event handlers
    UpdateEvents(NodeId!, HashMap<EventType, EventHandler>!),
    /// Update text content
    UpdateText(NodeId!, String!),
    /// Reorder children
    ReorderChildren(NodeId!, Vec<NodeId>!),
    /// Append child
    AppendChild(NodeId!, VNode!),
    /// Insert child before another
    InsertBefore(NodeId!, VNode!, NodeId!),
    /// Remove child
    RemoveChild(NodeId!, NodeId!)
}

/// Diff two virtual nodes and produce patches
☉ rite diff(old: &VNode, new: &VNode) → Vec<Patch>! {
    ≔ patches! = Vec::new()
    diff_recursive(old, new, &vary patches)
    patches
}

rite diff_recursive(old: &VNode, new: &VNode, patches: &vary Vec<Patch>) {
    match (old, new) {
        // Same type of element
        (VNode::Element(old_el), VNode::Element(new_el)) => {
            ⎇ old_el.tag != new_el.tag {
                // Different tags, replace entirely
                patches·push(Patch::Replace(old_el.id·unwrap(), VNode::Element(new_el·clone())))
            } ⎉ {
                ≔ id! = old_el.id·unwrap()

                // Diff attributes
                ≔ attr_changes! = diff_attrs(&old_el.attrs, &new_el.attrs)
                ⎇ !attr_changes·is_empty() {
                    patches·push(Patch::UpdateAttrs(id, attr_changes))
                }

                // Diff properties
                ≔ prop_changes! = diff_props(&old_el.props, &new_el.props)
                ⎇ !prop_changes·is_empty() {
                    patches·push(Patch::UpdateProps(id, prop_changes))
                }

                // Diff events
                ≔ event_changes! = diff_events(&old_el.events, &new_el.events)
                ⎇ !event_changes·is_empty() {
                    patches·push(Patch::UpdateEvents(id, event_changes))
                }

                // Diff children
                diff_children(&old_el.children, &new_el.children, id, patches)
            }
        }

        // Text nodes
        (VNode::Text(old_text), VNode::Text(new_text)) => {
            ⎇ old_text.content != new_text.content {
                patches·push(Patch::UpdateText(old_text.id·unwrap(), new_text.content·clone()))
            }
        }

        // Fragments
        (VNode::Fragment(old_frag), VNode::Fragment(new_frag)) => {
            diff_children(&old_frag.children, &new_frag.children, 0, patches)
        }

        // Components
        (VNode::Component(old_comp), VNode::Component(new_comp)) => {
            ⎇ old_comp.type_id != new_comp.type_id {
                // Different component types, replace
                patches·push(Patch::Replace(old_comp.id·unwrap(), VNode::Component(new_comp·clone())))
            } ⎉ {
                // Same type, re-render with new props
                ≔ old_rendered! = (old_comp.render)(old_comp.props·clone())
                ≔ new_rendered! = (new_comp.render)(new_comp.props·clone())
                diff_recursive(&old_rendered, &new_rendered, patches)
            }
        }

        // Type changed, replace
        (old, new) => {
            match old {
                VNode::Element(el) => patches·push(Patch::Replace(el.id·unwrap(), new·clone())),
                VNode::Text(t) => patches·push(Patch::Replace(t.id·unwrap(), new·clone())),
                VNode::Component(c) => patches·push(Patch::Replace(c.id·unwrap(), new·clone())),
                _ => patches·push(Patch::Create(new·clone()))
            }
        }
    }
}

rite diff_attrs(old: &HashMap<String, AttrValue>, new: &HashMap<String, AttrValue>) → HashMap<String, AttrValue>! {
    ≔ changes! = HashMap::new()

    // Find added/changed attributes
    for (key, value) in new {
        match old·get(key) {
            Some(old_value) ⎇ old_value == value => {}
            _ => changes·insert(key·clone(), value·clone())
        }
    }

    changes
}

rite diff_props(old: &HashMap<String, PropValue>, new: &HashMap<String, PropValue>) → HashMap<String, PropValue>! {
    ≔ changes! = HashMap::new()

    for (key, value) in new {
        match old·get(key) {
            Some(old_value) ⎇ old_value == value => {}
            _ => changes·insert(key·clone(), value·clone())
        }
    }

    changes
}

rite diff_events(old: &HashMap<EventType, EventHandler>, new: &HashMap<EventType, EventHandler>) → HashMap<EventType, EventHandler>! {
    // Events are always replaced (function identity check is complex)
    new·clone()
}

rite diff_children(old: &Vec<VNode>, new: &Vec<VNode>, parent_id: NodeId, patches: &vary Vec<Patch>) {
    // Use keyed reconciliation for efficient updates
    ≔ old_keyed! = old|τ{node => (get_key(node), node)}|collect::<Vec<_>>()
    ≔ new_keyed! = new|τ{node => (get_key(node), node)}|collect::<Vec<_>>()

    // LCS-based diffing for optimal moves
    ≔ operations! = compute_child_operations(&old_keyed, &new_keyed)

    for op in operations {
        match op {
            ChildOp::Keep(idx) => {
                diff_recursive(&old[idx], &new[idx], patches)
            }
            ChildOp::Insert(node, before_idx) => {
                match before_idx {
                    Some(idx) => {
                        ≔ before_id! = get_node_id(&old[idx])
                        patches·push(Patch::InsertBefore(parent_id, node·clone(), before_id))
                    }
                    None => {
                        patches·push(Patch::AppendChild(parent_id, node·clone()))
                    }
                }
            }
            ChildOp::Remove(idx) => {
                ≔ child_id! = get_node_id(&old[idx])
                patches·push(Patch::RemoveChild(parent_id, child_id))
            }
            ChildOp::Move(from_idx, to_idx) => {
                // Move is handled by remove + insert
            }
        }
    }
}

enum ChildOp {
    Keep(usize!),
    Insert(VNode!, Option<usize>?),
    Remove(usize!),
    Move(usize!, usize!)
}

rite compute_child_operations(old: &Vec<(Option<String>?, &VNode)>, new: &Vec<(Option<String>?, &VNode)>) → Vec<ChildOp>! {
    // Simplified reconciliation - full implementation would use LCS
    ≔ ops! = Vec::new()

    ≔ max_len! = old·len()·max(new·len())
    for i in 0..max_len {
        ⎇ i < old·len() && i < new·len() {
            ops·push(ChildOp::Keep(i))
        } ⎉ ⎇ i >= old·len() {
            ops·push(ChildOp::Insert(new[i].1·clone(), None))
        } ⎉ {
            ops·push(ChildOp::Remove(i))
        }
    }

    ops
}

rite get_key(node: &VNode) → Option<String>? {
    match node {
        VNode::Element(el) => el.key·clone(),
        VNode::Component(comp) => comp.key·clone(),
        VNode::Fragment(frag) => frag.key·clone(),
        _ => None
    }
}

rite get_node_id(node: &VNode) → NodeId! {
    match node {
        VNode::Element(el) => el.id·unwrap_or(0),
        VNode::Text(t) => t.id·unwrap_or(0),
        VNode::Component(c) => c.id·unwrap_or(0),
        _ => 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    rite test_element_creation() {
        ≔ el! = VElement::new("div")
            ·attr("class", "container")
            ·child("Hello")

        assert_eq!(el.tag, "div")
        assert_eq!(el.children·len(), 1)
    }

    #[test]
    rite test_diff_text_change() {
        ≔ old! = VNode::Text(VText { content: "Hello".to_string(), id: Some(1) })
        ≔ new! = VNode::Text(VText { content: "World".to_string(), id: Some(1) })

        ≔ patches! = diff(&old, &new)
        assert_eq!(patches·len(), 1)
        match &patches[0] {
            Patch::UpdateText(id, content) => {
                assert_eq!(*id, 1)
                assert_eq!(content, "World")
            }
            _ => panic!("Expected UpdateText patch")
        }
    }
}
