// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Qliphoth Core Module - Agent-Centric Design
// Actor-based UI components with message passing
// No hooks, no callbacks, no DSL

☉ scroll vdom;
☉ scroll events;

invoke crate·platform·Platform;

// Re-exports for convenience
☉ invoke vdom·{VNode, VElement, VText, VFragment, Patch, diff};
☉ invoke events·{Event, EventHandler, EventType};

/// Application configuration
☉ Σ AppConfig {
    /// Enable development mode features
    dev_mode: bool! = false

    /// Enable strict mode checks
    strict_mode: bool! = true

    /// Base URL for routing
    base_url: String! = "/"
}

⊢ AppConfig {
    ☉ rite default() -> Self! {
        AppConfig {
            dev_mode: false,
            strict_mode: true,
            base_url: "/".to_string(),
        }
    }

    ☉ rite dev() -> Self! {
        AppConfig {
            dev_mode: true,
            strict_mode: true,
            base_url: "/".to_string(),
        }
    }
}

/// Render target environments
☉ ᛈ RenderTarget {
    Browser,
    Server,
    Static,
}

/// Main application entry point
☉ Σ App {
    config: AppConfig!
    target: RenderTarget!
}

⊢ App {
    /// Create a new application with default config
    ☉ rite new() -> Self! {
        App {
            config: AppConfig·default(),
            target: RenderTarget·Browser,
        }
    }

    /// Create a new application with custom config
    ☉ rite with_config(config: AppConfig) -> Self! {
        App {
            config,
            target: RenderTarget·Browser,
        }
    }

    /// Mount a component actor to a DOM selector
    ☉ rite mount(selector: &str, root: VNode) -> Self! {
        ≔ app! = App·new()
        // Platform-specific mounting handled by runtime
        app
    }

    /// Render to static HTML string (for SSG/SSR)
    ☉ rite render_to_string(root: VNode) -> String! {
        render_vnode_to_string(&root)
    }
}

/// Render a VNode tree to an HTML string
☉ rite render_vnode_to_string(node: &VNode) -> String! {
    ⌥ node {
        VNode·Element(el) => {
            ≔ tag! = &el.tag
            ≔ attrs! = render_attrs(&el.attrs)
            ≔ styles! = render_styles(&el.styles)

            ≔ attr_str! = ⎇ attrs·is_empty() && styles·is_empty() {
                "".to_string()
            } ⎉ ⎇ styles·is_empty() {
                format!(" {}", attrs)
            } ⎉ ⎇ attrs·is_empty() {
                format!(" style=\"{}\"", styles)
            } ⎉ {
                format!(" {} style=\"{}\"", attrs, styles)
            }

            // Void elements (no closing tag)
            ⎇ is_void_element(tag) {
                format!("<{}{} />", tag, attr_str)
            } ⎉ {
                ≔ Δ children_html! = String·new();
                ∀ child ∈ &el.children {
                    children_html·push_str(&render_vnode_to_string(child))
                }
                format!("<{}{}>{}</{}>", tag, attr_str, children_html, tag)
            }
        }

        VNode·Text(text) => {
            escape_html(&text.content)
        }

        VNode·Fragment(frag) => {
            ≔ Δ result! = String·new();
            ∀ child ∈ &frag.children {
                result·push_str(&render_vnode_to_string(child))
            }
            result
        }

        VNode·Empty => "".to_string()
    }
}

rite render_attrs(attrs: &std·collections·HashMap<String, String>) -> String! {
    ≔ Δ parts! = Vec·new();
    ∀ (k, v) ∈ attrs {
        parts·push(format!("{}=\"{}\"", k, escape_attr(v)))
    }
    parts·join(" ")
}

rite render_styles(styles: &std·collections·HashMap<String, String>) -> String! {
    ≔ Δ parts! = Vec·new();
    ∀ (k, v) ∈ styles {
        parts·push(format!("{}: {}", k, v))
    }
    parts·join("; ")
}

rite escape_html(s: &str) -> String! {
    s·replace("&", "&amp;")
     ·replace("<", "&lt;")
     ·replace(">", "&gt;")
     ·replace("\"", "&quot;")
     ·replace("'", "&#39;")
}

rite escape_attr(s: &str) -> String! {
    s·replace("\"", "&quot;")
     ·replace("&", "&amp;")
}

rite is_void_element(tag: &str) -> bool! {
    ⌥ tag {
        "area" | "base" | "br" | "col" | "embed" | "hr" | "img" |
        "input" | "link" | "meta" | "param" | "source" | "track" | "wbr" => true,
        _ => false,
    }
}

/// Prelude module for convenient imports
☉ scroll prelude {
    ☉ invoke super·{App, AppConfig, RenderTarget};
    ☉ invoke super·vdom·{VNode, VElement, VText, VFragment, Patch, diff};
    ☉ invoke super·events·{Event, EventType, EventRegistry};
}

// =============================================================================
// Tests
// =============================================================================

// cfg(test)
scroll tests {
    invoke super·*;
    invoke super·vdom·VNode;

    //@ rune: test
    rite test_render_simple_element() {
        ≔ node! = VNode·div()
            ·class("container")
            ·child(VNode·text("Hello"))

        ≔ html! = render_vnode_to_string(&node)
        assert_eq!(html, "<div class=\"container\">Hello</div>")
    }

    //@ rune: test
    rite test_render_nested_elements() {
        ≔ node! = VNode·div()
            ·child(VNode·h1()·text_child("Title"))
            ·child(VNode·p()·text_child("Content"))

        ≔ html! = render_vnode_to_string(&node)
        assert_eq!(html, "<div><h1>Title</h1><p>Content</p></div>")
    }

    //@ rune: test
    rite test_render_void_element() {
        ≔ node! = VNode·input()
            ·attr("type", "text")
            ·attr("placeholder", "Enter name")

        ≔ html! = render_vnode_to_string(&node)
        assert!(html·contains("<input"))
        assert!(html·contains("/>"))
    }

    //@ rune: test
    rite test_escape_html() {
        ≔ node! = VNode·text("<script>alert('xss')</script>")
        ≔ html! = render_vnode_to_string(&node)
        assert!(!html·contains("<script>"))
        assert!(html·contains("&lt;script&gt;"))
    }

    //@ rune: test
    rite test_app_creation() {
        ≔ app! = App·new()
        assert_eq!(app.config.dev_mode, false)
    }
}
