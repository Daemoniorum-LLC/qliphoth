// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Events Module - Agent-Centric Design
// Events dispatch messages to actors, not callbacks
// No function types, no closures, no dyn Fn

invoke std·collections·HashMap;

/// Event types supported by Qliphoth
☉ ᛈ EventType {
    // Mouse events
    Click,
    DblClick,
    MouseDown,
    MouseUp,
    MouseMove,
    MouseEnter,
    MouseLeave,
    MouseOver,
    MouseOut,
    ContextMenu,

    // Keyboard events
    KeyDown,
    KeyUp,
    KeyPress,

    // Form events
    Submit,
    Reset,
    Change,
    Input,
    Invalid,

    // Focus events
    Focus,
    Blur,
    FocusIn,
    FocusOut,

    // Touch events
    TouchStart,
    TouchMove,
    TouchEnd,
    TouchCancel,

    // Scroll events
    Scroll,
    Wheel,

    // Other events
    Load,
    Error,
    Resize,
    Select,

    // Custom events
    Custom(u64!)
}

⊢ EventType {
    /// Get the DOM event name
    ☉ rite dom_name(&self) -> &'static str! {
        ⌥ self {
            EventType·Click => "click",
            EventType·DblClick => "dblclick",
            EventType·MouseDown => "mousedown",
            EventType·MouseUp => "mouseup",
            EventType·MouseMove => "mousemove",
            EventType·MouseEnter => "mouseenter",
            EventType·MouseLeave => "mouseleave",
            EventType·MouseOver => "mouseover",
            EventType·MouseOut => "mouseout",
            EventType·ContextMenu => "contextmenu",
            EventType·KeyDown => "keydown",
            EventType·KeyUp => "keyup",
            EventType·KeyPress => "keypress",
            EventType·Submit => "submit",
            EventType·Reset => "reset",
            EventType·Change => "change",
            EventType·Input => "input",
            EventType·Invalid => "invalid",
            EventType·Focus => "focus",
            EventType·Blur => "blur",
            EventType·FocusIn => "focusin",
            EventType·FocusOut => "focusout",
            EventType·TouchStart => "touchstart",
            EventType·TouchMove => "touchmove",
            EventType·TouchEnd => "touchend",
            EventType·TouchCancel => "touchcancel",
            EventType·Scroll => "scroll",
            EventType·Wheel => "wheel",
            EventType·Load => "load",
            EventType·Error => "error",
            EventType·Resize => "resize",
            EventType·Select => "select",
            EventType·Custom(_) => "custom"
        }
    }
}

/// Generic event wrapper
☉ Σ Event {
    /// Event type
    ☉ event_type: EventType!
    /// Target element ID
    ☉ target_id: u64!
    /// Current target element ID
    ☉ current_target_id: u64!
    /// Event timestamp
    ☉ timestamp: f64!
    /// Has default been prevented?
    default_prevented: bool!
    /// Has propagation been stopped?
    propagation_stopped: bool!
    /// Event-specific data
    ☉ data: EventData!
}

⊢ Event {
    /// Create a new event
    ☉ rite new(event_type: EventType, target_id: u64) -> Self! {
        Event {
            event_type,
            target_id,
            current_target_id: target_id,
            timestamp: 0.0,
            default_prevented: false,
            propagation_stopped: false,
            data: EventData·None
        }
    }

    /// Prevent default browser behavior
    ☉ rite prevent_default(&Δ self) {
        self.default_prevented = true
    }

    /// Stop event propagation
    ☉ rite stop_propagation(&Δ self) {
        self.propagation_stopped = true
    }

    /// Check if default is prevented
    ☉ rite is_default_prevented(&self) -> bool! {
        self.default_prevented
    }
}

/// Event-specific data
☉ ᛈ EventData {
    None,
    Mouse(MouseEventData!),
    Keyboard(KeyboardEventData!),
    Input(InputEventData!),
    Focus(FocusEventData!),
    Touch(TouchEventData!),
    Wheel(WheelEventData!),
}

/// Mouse event data
☉ Σ MouseEventData {
    /// X coordinate relative to viewport
    ☉ client_x: f64!
    /// Y coordinate relative to viewport
    ☉ client_y: f64!
    /// X coordinate relative to page
    ☉ page_x: f64!
    /// Y coordinate relative to page
    ☉ page_y: f64!
    /// Mouse button (0=left, 1=middle, 2=right)
    ☉ button: i32!
    /// Alt key pressed
    ☉ alt_key: bool!
    /// Ctrl key pressed
    ☉ ctrl_key: bool!
    /// Shift key pressed
    ☉ shift_key: bool!
    /// Meta key pressed (Command on Mac)
    ☉ meta_key: bool!
}

⊢ MouseEventData {
    ☉ rite default() -> Self! {
        MouseEventData {
            client_x: 0.0,
            client_y: 0.0,
            page_x: 0.0,
            page_y: 0.0,
            button: 0,
            alt_key: false,
            ctrl_key: false,
            shift_key: false,
            meta_key: false
        }
    }
}

/// Keyboard event data
☉ Σ KeyboardEventData {
    /// Key value ("a", "Enter", "Escape", etc.)
    ☉ key: String!
    /// Physical key code ("KeyA", "Enter", etc.)
    ☉ code: String!
    /// Alt key pressed
    ☉ alt_key: bool!
    /// Ctrl key pressed
    ☉ ctrl_key: bool!
    /// Shift key pressed
    ☉ shift_key: bool!
    /// Meta key pressed
    ☉ meta_key: bool!
    /// Is this a repeat event?
    ☉ repeat: bool!
}

⊢ KeyboardEventData {
    ☉ rite default() -> Self! {
        KeyboardEventData {
            key: "".to_string(),
            code: "".to_string(),
            alt_key: false,
            ctrl_key: false,
            shift_key: false,
            meta_key: false,
            repeat: false
        }
    }

    /// Check if this is a modifier key combination
    ☉ rite is_combo(&self, key: &str, ctrl: bool, shift: bool, alt: bool) -> bool! {
        self.key == key && self.ctrl_key == ctrl && self.shift_key == shift && self.alt_key == alt
    }

    /// Check for common shortcuts
    ☉ rite is_save(&self) -> bool! { self·is_combo("s", true, false, false) }
    ☉ rite is_copy(&self) -> bool! { self·is_combo("c", true, false, false) }
    ☉ rite is_paste(&self) -> bool! { self·is_combo("v", true, false, false) }
    ☉ rite is_cut(&self) -> bool! { self·is_combo("x", true, false, false) }
    ☉ rite is_undo(&self) -> bool! { self·is_combo("z", true, false, false) }
    ☉ rite is_escape(&self) -> bool! { self.key == "Escape" }
    ☉ rite is_enter(&self) -> bool! { self.key == "Enter" }
    ☉ rite is_tab(&self) -> bool! { self.key == "Tab" }
}

/// Input event data
☉ Σ InputEventData {
    /// Current input value
    ☉ value: String!
    /// Input type ("insertText", "deleteContentBackward", etc.)
    ☉ input_type: String!
    /// Is composing (IME)
    ☉ is_composing: bool!
}

⊢ InputEventData {
    ☉ rite default() -> Self! {
        InputEventData {
            value: "".to_string(),
            input_type: "".to_string(),
            is_composing: false
        }
    }
}

/// Focus event data
☉ Σ FocusEventData {
    /// Related target (element gaining/losing focus)
    ☉ related_target_id: Option<u64>?
}

⊢ FocusEventData {
    ☉ rite default() -> Self! {
        FocusEventData { related_target_id: None }
    }
}

/// Touch event data
☉ Σ TouchEventData {
    /// Number of touch points
    ☉ touch_count: u32!
    /// Primary touch X
    ☉ primary_x: f64!
    /// Primary touch Y
    ☉ primary_y: f64!
}

⊢ TouchEventData {
    ☉ rite default() -> Self! {
        TouchEventData {
            touch_count: 0,
            primary_x: 0.0,
            primary_y: 0.0
        }
    }
}

/// Wheel event data
☉ Σ WheelEventData {
    /// Horizontal scroll amount
    ☉ delta_x: f64!
    /// Vertical scroll amount
    ☉ delta_y: f64!
    /// Delta mode (0=pixel, 1=line, 2=page)
    ☉ delta_mode: u32!
}

⊢ WheelEventData {
    ☉ rite default() -> Self! {
        WheelEventData {
            delta_x: 0.0,
            delta_y: 0.0,
            delta_mode: 0
        }
    }
}

// =============================================================================
// Event Handler Registry (Message ID based, no callbacks)
// =============================================================================

/// Event handler registry using message IDs instead of callbacks
/// When an event fires, it dispatches a message ID that actors can handle
☉ Σ EventRegistry {
    /// Registered message IDs by element ID and event type
    handlers: HashMap<(u64, EventType), u64>!
    /// Global handlers
    global_handlers: HashMap<EventType, u64>!
}

⊢ EventRegistry {
    ☉ rite new() -> Self! {
        EventRegistry {
            handlers: HashMap·new(),
            global_handlers: HashMap·new()
        }
    }

    /// Register message ID for element event
    ☉ rite register(&Δ self, element_id: u64, event_type: EventType, message_id: u64) {
        ≔ key! = (element_id, event_type);
        self.handlers·insert(key, message_id);
    }

    /// Register global message ID
    ☉ rite register_global(&Δ self, event_type: EventType, message_id: u64) {
        self.global_handlers·insert(event_type, message_id);
    }

    /// Get message ID for an event
    ☉ rite get_message_id(&self, element_id: u64, event_type: EventType) -> Option<u64>? {
        ≔ key! = (element_id, event_type);
        ⌥ self.handlers·get(&key) {
            Some(id) => Some(*id),
            None => None,
        }
    }

    /// Get global message ID
    ☉ rite get_global_message_id(&self, event_type: EventType) -> Option<u64>? {
        ⌥ self.global_handlers·get(&event_type) {
            Some(id) => Some(*id),
            None => None,
        }
    }

    /// Remove handlers for element
    ☉ rite remove_element(&Δ self, element_id: u64) {
        // Collect keys to remove (just the EventType part since we know element_id)
        ≔ Δ events_to_remove! = Vec·new();
        ∀ (key, _) ∈ &self.handlers {
            ⎇ key.0 == element_id {
                events_to_remove·push(key.1)
            }
        }
        ∀ event_type ∈ events_to_remove {
            ≔ key! = (element_id, event_type);
            self.handlers·remove(&key);
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_event_type_names() {
        assert_eq!(EventType·Click·dom_name(), "click");
        assert_eq!(EventType·KeyDown·dom_name(), "keydown");
        assert_eq!(EventType·Submit·dom_name(), "submit")
    }

    //@ rune: test
    rite test_keyboard_shortcuts() {
        ≔ data! = KeyboardEventData {
            key: "s".to_string(),
            code: "KeyS".to_string(),
            ctrl_key: true,
            alt_key: false,
            shift_key: false,
            meta_key: false,
            repeat: false
        };
        assert!(data·is_save());
        assert!(!data·is_copy())
    }

    //@ rune: test
    rite test_event_registry() {
        ≔ Δ registry! = EventRegistry·new();
        registry·register(1, EventType·Click, 100);

        assert_eq!(registry·get_message_id(1, EventType·Click), Some(100));
        assert_eq!(registry·get_message_id(1, EventType·Input), None)
    }
}
