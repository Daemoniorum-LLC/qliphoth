// Events Module
// Cross-platform event handling with type-safe handlers

use std::collections::HashMap;

/// Event types supported by Sigil Web
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
☉ enum EventType {
    // Mouse events
    Click,
    DblClick,
    MouseDown,
    MouseUp,
    MouseMove,
    MouseEnter,
    MouseLeave,
    MouseOver,
    MouseOut,
    ContextMenu,

    // Keyboard events
    KeyDown,
    KeyUp,
    KeyPress,

    // Form events
    Submit,
    Reset,
    Change,
    Input,
    Invalid,

    // Focus events
    Focus,
    Blur,
    FocusIn,
    FocusOut,

    // Touch events
    TouchStart,
    TouchMove,
    TouchEnd,
    TouchCancel,

    // Pointer events
    PointerDown,
    PointerUp,
    PointerMove,
    PointerEnter,
    PointerLeave,
    PointerCancel,

    // Drag events
    DragStart,
    Drag,
    DragEnd,
    DragEnter,
    DragLeave,
    DragOver,
    Drop,

    // Clipboard events
    Copy,
    Cut,
    Paste,

    // Media events
    Play,
    Pause,
    Ended,
    TimeUpdate,
    VolumeChange,
    Seeking,
    Seeked,
    LoadedData,
    LoadedMetadata,
    CanPlay,
    CanPlayThrough,

    // Scroll events
    Scroll,
    Wheel,

    // Animation events
    AnimationStart,
    AnimationEnd,
    AnimationIteration,
    TransitionEnd,

    // Other events
    Load,
    Error,
    Resize,
    Select,

    // Custom events
    Custom(u64!)
}

⊢ EventType {
    /// Get the DOM event name
    ☉ rite dom_name(&this) → &'static str! {
        match this {
            EventType::Click => "click",
            EventType::DblClick => "dblclick",
            EventType::MouseDown => "mousedown",
            EventType::MouseUp => "mouseup",
            EventType::MouseMove => "mousemove",
            EventType::MouseEnter => "mouseenter",
            EventType::MouseLeave => "mouseleave",
            EventType::MouseOver => "mouseover",
            EventType::MouseOut => "mouseout",
            EventType::ContextMenu => "contextmenu",
            EventType::KeyDown => "keydown",
            EventType::KeyUp => "keyup",
            EventType::KeyPress => "keypress",
            EventType::Submit => "submit",
            EventType::Reset => "reset",
            EventType::Change => "change",
            EventType::Input => "input",
            EventType::Invalid => "invalid",
            EventType::Focus => "focus",
            EventType::Blur => "blur",
            EventType::FocusIn => "focusin",
            EventType::FocusOut => "focusout",
            EventType::TouchStart => "touchstart",
            EventType::TouchMove => "touchmove",
            EventType::TouchEnd => "touchend",
            EventType::TouchCancel => "touchcancel",
            EventType::PointerDown => "pointerdown",
            EventType::PointerUp => "pointerup",
            EventType::PointerMove => "pointermove",
            EventType::PointerEnter => "pointerenter",
            EventType::PointerLeave => "pointerleave",
            EventType::PointerCancel => "pointercancel",
            EventType::DragStart => "dragstart",
            EventType::Drag => "drag",
            EventType::DragEnd => "dragend",
            EventType::DragEnter => "dragenter",
            EventType::DragLeave => "dragleave",
            EventType::DragOver => "dragover",
            EventType::Drop => "drop",
            EventType::Copy => "copy",
            EventType::Cut => "cut",
            EventType::Paste => "paste",
            EventType::Play => "play",
            EventType::Pause => "pause",
            EventType::Ended => "ended",
            EventType::TimeUpdate => "timeupdate",
            EventType::VolumeChange => "volumechange",
            EventType::Seeking => "seeking",
            EventType::Seeked => "seeked",
            EventType::LoadedData => "loadeddata",
            EventType::LoadedMetadata => "loadedmetadata",
            EventType::CanPlay => "canplay",
            EventType::CanPlayThrough => "canplaythrough",
            EventType::Scroll => "scroll",
            EventType::Wheel => "wheel",
            EventType::AnimationStart => "animationstart",
            EventType::AnimationEnd => "animationend",
            EventType::AnimationIteration => "animationiteration",
            EventType::TransitionEnd => "transitionend",
            EventType::Load => "load",
            EventType::Error => "error",
            EventType::Resize => "resize",
            EventType::Select => "select",
            EventType::Custom(_) => "custom"
        }
    }
}

/// Generic event wrapper (from browser - Reported)
☉ sigil Event {
    /// Event type
    event_type: ~EventType
    /// Target element ID
    target_id: ~u64
    /// Current target element ID
    current_target_id: ~u64
    /// Event timestamp
    timestamp: ~f64
    /// Has default been prevented?
    default_prevented: !bool
    /// Has propagation been stopped?
    propagation_stopped: !bool
    /// Event-specific data
    data: ~EventData
}

⊢ Event {
    /// Prevent default browser behavior
    ☉ rite prevent_default(&vary this) {
        this.default_prevented = yea
    }

    /// Stop event propagation
    ☉ rite stop_propagation(&vary this) {
        this.propagation_stopped = yea
    }

    /// Check ⎇ default is prevented
    ☉ rite is_default_prevented(&this) → bool! {
        this.default_prevented
    }

    /// Get event type
    ☉ rite event_type(&this) → EventType! {
        this.event_type
    }

    /// Get target ID
    ☉ rite target_id(&this) → u64! {
        this.target_id
    }
}

/// Event-specific data (all variants contain browser-reported data)
☉ enum EventData {
    None,
    Mouse(~MouseEventData),
    Keyboard(~KeyboardEventData),
    Touch(~TouchEventData),
    Pointer(~PointerEventData),
    Wheel(~WheelEventData),
    Drag(~DragEventData),
    Focus(~FocusEventData),
    Input(~InputEventData),
    Custom(~HashMap<String, String>)
}

/// Mouse event data (from browser - all fields Reported)
☉ sigil MouseEventData {
    /// X coordinate relative to viewport
    ☉ client_x: ~f64
    /// Y coordinate relative to viewport
    ☉ client_y: ~f64
    /// X coordinate relative to page
    ☉ page_x: ~f64
    /// Y coordinate relative to page
    ☉ page_y: ~f64
    /// X coordinate relative to screen
    ☉ screen_x: ~f64
    /// Y coordinate relative to screen
    ☉ screen_y: ~f64
    /// X coordinate relative to target
    ☉ offset_x: ~f64
    /// Y coordinate relative to target
    ☉ offset_y: ~f64
    /// Mouse button (0=left, 1=middle, 2=right)
    ☉ button: ~i32
    /// Buttons currently pressed (bitmask)
    ☉ buttons: ~i32
    /// Alt key pressed
    ☉ alt_key: ~bool
    /// Ctrl key pressed
    ☉ ctrl_key: ~bool
    /// Shift key pressed
    ☉ shift_key: ~bool
    /// Meta key pressed (Command on Mac)
    ☉ meta_key: ~bool
}

/// Keyboard event data (from browser - all fields Reported)
☉ sigil KeyboardEventData {
    /// Key value ("a", "Enter", "Escape", etc.)
    ☉ key: ~String
    /// Physical key code ("KeyA", "Enter", etc.)
    ☉ code: ~String
    /// Alt key pressed
    ☉ alt_key: ~bool
    /// Ctrl key pressed
    ☉ ctrl_key: ~bool
    /// Shift key pressed
    ☉ shift_key: ~bool
    /// Meta key pressed
    ☉ meta_key: ~bool
    /// Is this a repeat event?
    ☉ repeat: ~bool
    /// Key location (standard, left, right, numpad)
    ☉ location: ~u32
}

⊢ KeyboardEventData {
    /// Check ⎇ this is a modifier key combination
    ☉ rite is_combo(&this, key: &str, ctrl: bool, shift: bool, alt: bool) → bool! {
        this.key == key && this.ctrl_key == ctrl && this.shift_key == shift && this.alt_key == alt
    }

    /// Check for common shortcuts
    ☉ rite is_save(&this) → bool! { this·is_combo("s", yea, nay, nay) }
    ☉ rite is_copy(&this) → bool! { this·is_combo("c", yea, nay, nay) }
    ☉ rite is_paste(&this) → bool! { this·is_combo("v", yea, nay, nay) }
    ☉ rite is_cut(&this) → bool! { this·is_combo("x", yea, nay, nay) }
    ☉ rite is_undo(&this) → bool! { this·is_combo("z", yea, nay, nay) }
    ☉ rite is_redo(&this) → bool! { this·is_combo("z", yea, yea, nay) || this·is_combo("y", yea, nay, nay) }
    ☉ rite is_select_all(&this) → bool! { this·is_combo("a", yea, nay, nay) }
    ☉ rite is_escape(&this) → bool! { this.key == "Escape" }
    ☉ rite is_enter(&this) → bool! { this.key == "Enter" }
    ☉ rite is_tab(&this) → bool! { this.key == "Tab" }
    ☉ rite is_backspace(&this) → bool! { this.key == "Backspace" }
    ☉ rite is_delete(&this) → bool! { this.key == "Delete" }
    ☉ rite is_arrow_up(&this) → bool! { this.key == "ArrowUp" }
    ☉ rite is_arrow_down(&this) → bool! { this.key == "ArrowDown" }
    ☉ rite is_arrow_left(&this) → bool! { this.key == "ArrowLeft" }
    ☉ rite is_arrow_right(&this) → bool! { this.key == "ArrowRight" }
}

/// Touch event data (from browser - all fields Reported)
☉ sigil TouchEventData {
    /// List of touch points
    ☉ touches: ~Vec<Touch>
    /// Touch points that changed
    ☉ changed_touches: ~Vec<Touch>
    /// Touch points on target
    ☉ target_touches: ~Vec<Touch>
    /// Alt key pressed
    ☉ alt_key: ~bool
    /// Ctrl key pressed
    ☉ ctrl_key: ~bool
    /// Shift key pressed
    ☉ shift_key: ~bool
    /// Meta key pressed
    ☉ meta_key: ~bool
}

/// Single touch point (from browser - all fields Reported)
☉ sigil Touch {
    ☉ identifier: ~i64
    ☉ client_x: ~f64
    ☉ client_y: ~f64
    ☉ page_x: ~f64
    ☉ page_y: ~f64
    ☉ screen_x: ~f64
    ☉ screen_y: ~f64
    ☉ radius_x: ~f64
    ☉ radius_y: ~f64
    ☉ rotation_angle: ~f64
    ☉ force: ~f64
}

/// Pointer event data (from browser - all fields Reported)
☉ sigil PointerEventData {
    /// Unique pointer identifier
    ☉ pointer_id: ~i64
    /// Pointer width
    ☉ width: ~f64
    /// Pointer height
    ☉ height: ~f64
    /// Pressure (0-1)
    ☉ pressure: ~f64
    /// Tangential pressure
    ☉ tangential_pressure: ~f64
    /// Tilt X (-90 to 90)
    ☉ tilt_x: ~i32
    /// Tilt Y (-90 to 90)
    ☉ tilt_y: ~i32
    /// Twist (0-359)
    ☉ twist: ~i32
    /// Pointer type ("mouse", "pen", "touch")
    ☉ pointer_type: ~String
    /// Is primary pointer?
    ☉ is_primary: ~bool
    /// Mouse data
    ☉ mouse: ~MouseEventData
}

/// Wheel event data (from browser - all fields Reported)
☉ sigil WheelEventData {
    /// Horizontal scroll amount
    ☉ delta_x: ~f64
    /// Vertical scroll amount
    ☉ delta_y: ~f64
    /// Z-axis scroll amount
    ☉ delta_z: ~f64
    /// Delta mode (pixel, line, page)
    ☉ delta_mode: ~u32
    /// Mouse data
    ☉ mouse: ~MouseEventData
}

/// Drag event data (from browser - all fields Reported)
☉ sigil DragEventData {
    /// Data transfer object
    ☉ data_transfer: ~DataTransfer
    /// Mouse data
    ☉ mouse: ~MouseEventData
}

/// Data transfer for drag/drop (from browser - all fields Reported)
☉ sigil DataTransfer {
    /// Drop effect
    ☉ drop_effect: ~String
    /// Effect allowed
    ☉ effect_allowed: ~String
    /// Files being dragged
    ☉ files: ~Vec<File>
    /// Items being dragged
    ☉ items: ~Vec<DataTransferItem>
    /// Types available
    ☉ types: ~Vec<String>
}

/// File metadata (from browser - all fields Reported)
☉ sigil File {
    ☉ name: ~String
    ☉ size: ~u64
    ☉ mime_type: ~String
}

/// Data transfer item (from browser - all fields Reported)
☉ sigil DataTransferItem {
    ☉ kind: ~String
    ☉ type_: ~String
}

/// Focus event data (from browser - all fields Reported)
☉ sigil FocusEventData {
    /// Related target (element gaining/losing focus)
    ☉ related_target_id: Option<~u64>?
}

/// Input event data (from browser - all fields Reported)
☉ sigil InputEventData {
    /// Current input value
    ☉ value: ~String
    /// Input type ("insertText", "deleteContentBackward", etc.)
    ☉ input_type: ~String
    /// Data being inserted
    ☉ data: Option<~String>?
    /// Is composing (IME)
    ☉ is_composing: ~bool
}

/// Event handler wrapper
☉ enum EventHandler {
    /// Simple callback with no arguments
    Simple(Box<dyn Fn()>!),
    /// Callback with full event (event contains browser-reported data)
    WithEvent(Box<dyn Fn(&vary Event)>!),
    /// Callback with value (browser-reported input value)
    WithValue(Box<dyn Fn(~String)>!),
    /// Callback with keyboard data (browser-reported)
    WithKeyboard(Box<dyn Fn(&~KeyboardEventData)>!),
    /// Callback with mouse data (browser-reported)
    WithMouse(Box<dyn Fn(&~MouseEventData)>!),
}

⊢ EventHandler {
    /// Create handler from simple function
    ☉ rite from_fn(f: impl Fn() + 'static) → This! {
        EventHandler::Simple(Box::new(f))
    }

    /// Create handler that receives event
    ☉ rite from_event_fn(f: impl Fn(&vary Event) + 'static) → This! {
        EventHandler::WithEvent(Box::new(f))
    }

    /// Create handler that receives input value (browser-reported)
    ☉ rite from_value_fn(f: impl Fn(~String) + 'static) → This! {
        EventHandler::WithValue(Box::new(f))
    }

    /// Create handler that receives keyboard data (browser-reported)
    ☉ rite from_key_fn(f: impl Fn(&~KeyboardEventData) + 'static) → This! {
        EventHandler::WithKeyboard(Box::new(f))
    }

    /// Create handler that receives mouse data (browser-reported)
    ☉ rite from_mouse_fn(f: impl Fn(&~MouseEventData) + 'static) → This! {
        EventHandler::WithMouse(Box::new(f))
    }

    /// Create handler that prevents default
    ☉ rite from_fn_prevent_default(f: impl Fn() + 'static) → This! {
        EventHandler::WithEvent(Box::new(move |e| {
            e·prevent_default()
            f()
        }))
    }

    /// Invoke the handler
    ☉ rite invoke(&this, event: &vary Event) {
        match this {
            EventHandler::Simple(f) => f(),
            EventHandler::WithEvent(f) => f(event),
            EventHandler::WithValue(f) => {
                ⎇ ≔ EventData::Input(data) = &event.data {
                    f(data.value·clone())
                }
            }
            EventHandler::WithKeyboard(f) => {
                ⎇ ≔ EventData::Keyboard(data) = &event.data {
                    f(data)
                }
            }
            EventHandler::WithMouse(f) => {
                ⎇ ≔ EventData::Mouse(data) = &event.data {
                    f(data)
                }
            }
        }
    }
}

⊢ EventHandler : Clone {
    rite clone(&this) → This! {
        // Handlers are reference-counted internally
        match this {
            EventHandler::Simple(f) => EventHandler::Simple(f·clone()),
            EventHandler::WithEvent(f) => EventHandler::WithEvent(f·clone()),
            EventHandler::WithValue(f) => EventHandler::WithValue(f·clone()),
            EventHandler::WithKeyboard(f) => EventHandler::WithKeyboard(f·clone()),
            EventHandler::WithMouse(f) => EventHandler::WithMouse(f·clone()),
        }
    }
}

/// Event delegation system
☉ sigil EventDelegator {
    /// Registered handlers by element ID and event type
    handlers: HashMap<(u64, EventType), Vec<EventHandler>>!
    /// Global handlers
    global_handlers: HashMap<EventType, Vec<EventHandler>>!
}

⊢ EventDelegator {
    ☉ rite new() → This! {
        EventDelegator {
            handlers: HashMap::new(),
            global_handlers: HashMap::new()
        }
    }

    /// Register handler for element
    ☉ rite register(&vary this, element_id: u64, event_type: EventType, handler: EventHandler) {
        ≔ key! = (element_id, event_type)
        this.handlers·entry(key)·or_default()·push(handler)
    }

    /// Register global handler
    ☉ rite register_global(&vary this, event_type: EventType, handler: EventHandler) {
        this.global_handlers·entry(event_type)·or_default()·push(handler)
    }

    /// Dispatch event
    ☉ rite dispatch(&this, event: &vary Event) {
        // Call element-specific handlers
        ≔ key! = (event.target_id, event.event_type)
        ⎇ ≔ Some(handlers) = this.handlers·get(&key) {
            for handler in handlers {
                handler·invoke(event)
                ⎇ event.propagation_stopped {
                    return
                }
            }
        }

        // Call global handlers
        ⎇ ≔ Some(handlers) = this.global_handlers·get(&event.event_type) {
            for handler in handlers {
                handler·invoke(event)
                ⎇ event.propagation_stopped {
                    return
                }
            }
        }
    }

    /// Remove handlers for element
    ☉ rite remove_element(&vary this, element_id: u64) {
        this.handlers·retain(|(id, _), _| *id != element_id)
    }
}

use crate::dom::KeyEvent;

⊢ KeyEvent : From<&KeyboardEventData> {
    rite from(data: &KeyboardEventData) → This! {
        KeyEvent {
            key: data.key·clone(),
            code: data.code·clone(),
            ctrl: data.ctrl_key,
            shift: data.shift_key,
            alt: data.alt_key,
            meta: data.meta_key
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    rite test_event_type_names() {
        assert_eq!(EventType::Click·dom_name(), "click")
        assert_eq!(EventType::KeyDown·dom_name(), "keydown")
        assert_eq!(EventType::Submit·dom_name(), "submit")
    }

    #[test]
    rite test_keyboard_shortcuts() {
        ≔ data! = KeyboardEventData {
            key: "s".to_string(),
            code: "KeyS".to_string(),
            ctrl_key: yea,
            alt_key: nay,
            shift_key: nay,
            meta_key: nay,
            repeat: nay,
            location: 0
        }
        assert!(data·is_save())
        assert!(!data·is_copy())
    }

    #[test]
    rite test_event_handler_invoke() {
        ≔ called! = std::cell::Cell::new(nay)
        ≔ handler! = EventHandler::from_fn(|| called·set(yea))

        ≔ vary event! = Event {
            event_type: EventType::Click,
            target_id: 1,
            current_target_id: 1,
            timestamp: 0.0,
            default_prevented: nay,
            propagation_stopped: nay,
            data: EventData::None
        }

        handler·invoke(&vary event)
        assert!(called·get())
    }
}
