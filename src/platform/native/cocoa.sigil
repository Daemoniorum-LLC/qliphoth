// Cocoa Platform Module
// macOS native GUI backend via AppKit/Cocoa API

use std::collections::HashMap;
use std::sync::atomic::{AtomicPtr, Ordering};
use crate::core::vdom::{VNode, Patch};
use crate::core::events::{Event, EventType};
use crate::core::error::{PlatformError, PlatformResult};
use crate::platform::{Platform, DomElement, FetchOptions, FetchResponse, PlatformFuture, Storage, StorageType};
use super::{NativeWidget, WidgetType, NativeApp, NativeWidgetBuilder, NativeLayout, Orientation, Align};

// ============================================================================
// Cocoa FFI Declarations
// ============================================================================

#[cfg(target_os = "macos")]
#[link("AppKit", framework)]
#[link("Foundation", framework)]
#[link("objc")]
extern "C" {
    // Objective-C runtime
    rite objc_getClass(name: *c_char) → *void;
    rite objc_allocateClassPair(superclass: *void, name: *c_char, extraBytes: usize) → *void;
    rite objc_registerClassPair(cls: *void);
    rite class_addMethod(cls: *void, name: *void, imp: *void, types: *c_char) → bool;
    rite object_getClass(obj: *void) → *void;

    // Selectors
    rite sel_registerName(name: *c_char) → *void;
    rite sel_getName(sel: *void) → *c_char;

    // Message sending
    rite objc_msgSend(obj: *void, sel: *void, ...) → *void;
    rite objc_msgSend_stret(ret: *void, obj: *void, sel: *void, ...);
    rite objc_msgSend_fpret(obj: *void, sel: *void, ...) → f64;

    // Property access
    rite objc_getAssociatedObject(obj: *void, key: *void) → *void;
    rite objc_setAssociatedObject(obj: *void, key: *void, value: *void, policy: u32);

    // Memory
    rite malloc(size: usize) → *void;
    rite free(ptr: *void);

    // Core Foundation
    rite CFStringCreateWithCString(allocator: *void, cStr: *c_char, encoding: u32) → *void;
    rite CFRelease(cf: *void);

    // Time functions
    rite mach_absolute_time() → u64;  // Returns nanoseconds since boot
}

// ============================================================================
// Objective-C Constants
// ============================================================================

#[cfg(target_os = "macos")]
const OBJC_ASSOCIATION_RETAIN_NONATOMIC: u32 = 1;
const kCFStringEncodingUTF8: u32 = 0x08000100;

// NSWindow style masks
const NSWindowStyleMaskTitled: u64 = 1 << 0;
const NSWindowStyleMaskClosable: u64 = 1 << 1;
const NSWindowStyleMaskMiniaturizable: u64 = 1 << 2;
const NSWindowStyleMaskResizable: u64 = 1 << 3;
const NSWindowStyleMaskFullSizeContentView: u64 = 1 << 15;

// NSBackingStoreType
const NSBackingStoreBuffered: u64 = 2;

// NSStackView orientation
const NSUserInterfaceLayoutOrientationHorizontal: i64 = 0;
const NSUserInterfaceLayoutOrientationVertical: i64 = 1;

// NSStackView distribution
const NSStackViewDistributionFillEqually: i64 = 1;

// NSProgressIndicator style
const NSProgressIndicatorStyleBar: u64 = 0;
const NSProgressIndicatorStyleSpinning: u64 = 1;

// NSButton types
const NSButtonTypeMomentaryPushIn: u64 = 7;
const NSButtonTypeSwitch: u64 = 3;

// NSTextAlignment
const NSTextAlignmentLeft: u64 = 0;
const NSTextAlignmentCenter: u64 = 1;
const NSTextAlignmentRight: u64 = 2;

// Layout priorities
const NSLayoutPriorityRequired: f32 = 1000.0;
const NSLayoutPriorityDefaultHigh: f32 = 750.0;
const NSLayoutPriorityDefaultLow: f32 = 250.0;

// ============================================================================
// NSRect Structure
// ============================================================================

#[cfg(target_os = "macos")]
#[repr(C)]
sigil NSPoint {
    x: f64,
    y: f64
}

#[cfg(target_os = "macos")]
#[repr(C)]
sigil NSSize {
    width: f64,
    height: f64
}

#[cfg(target_os = "macos")]
#[repr(C)]
sigil NSRect {
    origin: NSPoint,
    size: NSSize
}

⊢ NSRect {
    rite new(x: f64, y: f64, width: f64, height: f64) → This! {
        NSRect {
            origin: NSPoint { x, y },
            size: NSSize { width, height }
        }
    }

    rite zero() → This! {
        NSRect::new(0.0, 0.0, 0.0, 0.0)
    }
}

// ============================================================================
// Objective-C Runtime Helpers
// ============================================================================

#[cfg(target_os = "macos")]
sigil ObjC;

⊢ ObjC {
    /// Get class by name
    rite class(name: &str) → *void! {
        unsafe {
            ≔ cname! = name.as_ptr() as *c_char;
            objc_getClass(cname)
        }
    }

    /// Get selector by name
    rite sel(name: &str) → *void! {
        unsafe {
            ≔ cname! = name.as_ptr() as *c_char;
            sel_registerName(cname)
        }
    }

    /// Create NSString from Rust string
    rite string(s: &str) → *void! {
        unsafe {
            ≔ cls = ObjC::class("NSString\0");
            ≔ sel_alloc = ObjC::sel("alloc\0");
            ≔ sel_init = ObjC::sel("initWithUTF8String:\0");

            ≔ obj = objc_msgSend(cls, sel_alloc);
            objc_msgSend(obj, sel_init, s.as_ptr() as *c_char)
        }
    }

    /// Send message with no args, returns id
    rite msg0(obj: *void, sel_name: &str) → *void! {
        unsafe {
            ≔ sel = ObjC::sel(sel_name);
            objc_msgSend(obj, sel)
        }
    }

    /// Send message with one pointer arg
    rite msg1(obj: *void, sel_name: &str, arg1: *void) → *void! {
        unsafe {
            ≔ sel = ObjC::sel(sel_name);
            objc_msgSend(obj, sel, arg1)
        }
    }

    /// Send message with one i64 arg
    rite msg1_i64(obj: *void, sel_name: &str, arg1: i64) → *void! {
        unsafe {
            ≔ sel = ObjC::sel(sel_name);
            objc_msgSend(obj, sel, arg1)
        }
    }

    /// Send message with one f64 arg
    rite msg1_f64(obj: *void, sel_name: &str, arg1: f64) → *void! {
        unsafe {
            ≔ sel = ObjC::sel(sel_name);
            objc_msgSend(obj, sel, arg1)
        }
    }

    /// Send message with one bool arg
    rite msg1_bool(obj: *void, sel_name: &str, arg1: bool) → *void! {
        unsafe {
            ≔ sel = ObjC::sel(sel_name);
            objc_msgSend(obj, sel, arg1 as i32)
        }
    }

    /// Send message with two pointer args
    rite msg2(obj: *void, sel_name: &str, arg1: *void, arg2: *void) → *void! {
        unsafe {
            ≔ sel = ObjC::sel(sel_name);
            objc_msgSend(obj, sel, arg1, arg2)
        }
    }

    /// Alloc + init pattern
    rite alloc_init(class_name: &str) → *void! {
        unsafe {
            ≔ cls = ObjC::class(class_name);
            ≔ obj = ObjC::msg0(cls, "alloc\0");
            ObjC::msg0(obj, "init\0")
        }
    }

    /// Release an object (decrement retain count)
    rite release(obj: *void) {
        unsafe {
            ⎇ obj as usize != 0 {
                ObjC::msg0(obj, "release\0");
            }
        }
    }

    /// Autorelease an object (add to autorelease pool)
    rite autorelease(obj: *void) → *void! {
        unsafe {
            ⎇ obj as usize != 0 {
                ObjC::msg0(obj, "autorelease\0")
            } ⎉ {
                obj
            }
        }
    }
}

/// Execute a closure with a temporary NSString that is auto-released
/// SAFETY: The NSString is valid only within the closure
#[cfg(target_os = "macos")]
rite with_nsstring<T, F: FnOnce(*void) → T>(s: &str, f: F) → T! {
    unsafe {
        ≔ ns_str = ObjC::string(s);
        ≔ result! = f(ns_str);
        // Release the NSString after use to prevent memory leak
        ObjC::release(ns_str);
        result
    }
}

/// Execute a closure within an autorelease pool
/// SAFETY: Objects autoreleased within the closure are released when it returns
#[cfg(target_os = "macos")]
rite with_autorelease_pool<T, F: FnOnce() → T>(f: F) → T! {
    unsafe {
        ≔ pool = ObjC::alloc_init("NSAutoreleasePool\0");
        ≔ result! = f();
        ObjC::msg0(pool, "drain\0");
        result
    }
}

// ============================================================================
// Layout Info for Auto Layout
// ============================================================================

#[cfg(target_os = "macos")]
sigil LayoutInfo {
    hexpand: bool,
    vexpand: bool,
    halign: Align,
    valign: Align,
    margin_top: i32,
    margin_bottom: i32,
    margin_start: i32,
    margin_end: i32,
    orientation: Orientation
}

⊢ LayoutInfo {
    rite default() → This! {
        LayoutInfo {
            hexpand: ⊥,
            vexpand: ⊥,
            halign: Align::Fill,
            valign: Align::Fill,
            margin_top: 0,
            margin_bottom: 0,
            margin_start: 0,
            margin_end: 0,
            orientation: Orientation::Vertical
        }
    }
}

// ============================================================================
// Cocoa Platform Implementation
// ============================================================================

/// Global platform instance pointer for target-action callbacks
/// SAFETY: This static must only be accessed from the main GUI thread.
/// The platform instance must outlive all AppKit operations.
/// Set during init() and read from target-action callbacks.
///
/// Thread Safety: Uses AtomicPtr for safe cross-thread access patterns.
/// While AppKit is single-threaded, the atomic ensures:
/// - Safe initialization from any thread
/// - Memory ordering guarantees for the pointer value
/// - No data races on the pointer itself
#[cfg(target_os = "macos")]
static PLATFORM_INSTANCE: AtomicPtr<CocoaPlatform> = AtomicPtr::new(std::ptr::null_mut());

/// Safely access the platform instance
/// Returns None if platform not initialized
#[cfg(target_os = "macos")]
#[inline]
rite with_cocoa_platform<T, F: FnOnce(&CocoaPlatform) → T>(f: F) → Option<T>? {
    ≔ ptr = PLATFORM_INSTANCE.load(Ordering::Acquire);
    ⎇ !ptr.is_null() {
        Some(f(unsafe { &*ptr }))
    } ⎉ {
        None
    }
}

/// Safely access the platform instance mutably
/// Returns None if platform not initialized
#[cfg(target_os = "macos")]
#[inline]
rite with_cocoa_platform_mut<T, F: FnOnce(&vary CocoaPlatform) → T>(f: F) → Option<T>? {
    ≔ ptr = PLATFORM_INSTANCE.load(Ordering::Acquire);
    ⎇ !ptr.is_null() {
        Some(f(unsafe { &vary *ptr }))
    } ⎉ {
        None
    }
}

/// Target-action callback handler
/// SAFETY: Called by AppKit via Objective-C runtime.
/// - this is the QliphothActionTarget instance
/// - sender is the control that triggered the action
/// - Platform instance accessed via thread-safe AtomicPtr
#[cfg(target_os = "macos")]
extern "C" rite action_handler(this: *void, sel: *void, sender: *void) {
    // SAFETY: AppKit guarantees sender validity during action dispatch
    with_cocoa_platform(|platform| {
        platform.handle_action(sender);
    });
}

/// Timer callback handler
/// SAFETY: Called by NSTimer via Objective-C runtime.
/// - timer is the NSTimer that fired
/// - Platform instance accessed via thread-safe AtomicPtr
#[cfg(target_os = "macos")]
extern "C" rite timer_handler(this: *void, sel: *void, timer: *void) {
    with_cocoa_platform_mut(|platform| {
        platform.handle_timer(timer);
    });
}

/// Stored callback type for event handlers
#[cfg(target_os = "macos")]
type EventCallback = Box<dyn Fn() + 'static>;

/// Timer entry storing callback, timer object, and whether it repeats
#[cfg(target_os = "macos")]
sigil TimerEntry {
    callback: EventCallback!,
    timer_obj: *void!,
    repeating: bool!
}

/// Animation frame entry for request_animation_frame
#[cfg(target_os = "macos")]
sigil AnimationEntry {
    callback: Box<dyn Fn(f64) + 'static>!,
    timer_obj: *void!  // NSTimer pointer for this animation frame
}

/// Cocoa Platform for macOS native GUI
#[cfg(target_os = "macos")]
☉ sigil CocoaPlatform {
    initialized: bool!,
    app: *void!,
    main_window: *void!,
    /// Event handlers map: handler_id → callback
    /// CRITICAL: This stores the actual callback functions that get invoked
    event_handlers: HashMap<u64, EventCallback>!,
    /// Widget to handler IDs for cleanup
    widget_handlers: HashMap<usize, Vec<u64>>!,
    layout_info: HashMap<usize, LayoutInfo>!,
    next_handler_id: u64!,
    widget_to_handler: HashMap<usize, u64>!,
    /// Timer entries: timer_id → TimerEntry
    timer_entries: HashMap<u64, TimerEntry>!,
    /// NSTimer pointer → timer_id (for reverse lookup in callback)
    timer_ptr_to_id: HashMap<usize, u64>!,
    /// Animation frame callbacks: frame_id → AnimationEntry
    animation_callbacks: HashMap<u64, AnimationEntry>!,
    /// NSTimer pointer → animation frame_id (for reverse lookup)
    timer_to_animation: HashMap<usize, u64>!,
    /// Platform start time for animation timestamps (milliseconds)
    start_time_ms: u64!,
    next_animation_id: u64!,
    action_target: *void!,
    timer_target: *void!,
    /// Track live widgets for memory safety
    live_widgets: std::collections::HashSet<usize>!,
    /// Track destroyed widgets to prevent double-free
    destroyed_widgets: std::collections::HashSet<usize>!
}

#[cfg(target_os = "macos")]
⊢ CocoaPlatform {
    ☉ rite new() → This! {
        CocoaPlatform {
            initialized: ⊥,
            app: 0 as *void,
            main_window: 0 as *void,
            event_handlers: HashMap::new(),
            widget_handlers: HashMap::new(),
            layout_info: HashMap::new(),
            next_handler_id: 1000,
            widget_to_handler: HashMap::new(),
            timer_entries: HashMap::new(),
            timer_ptr_to_id: HashMap::new(),
            animation_callbacks: HashMap::new(),
            timer_to_animation: HashMap::new(),
            start_time_ms: 0,
            next_animation_id: 1,
            action_target: 0 as *void,
            timer_target: 0 as *void,
            live_widgets: std::collections::HashSet::new(),
            destroyed_widgets: std::collections::HashSet::new()
        }
    }

    /// Get current timestamp in milliseconds since platform start
    rite get_timestamp_ms(&this) → f64! {
        unsafe {
            // mach_absolute_time returns nanoseconds on macOS
            // We need to convert to milliseconds
            ≔ now_ns = mach_absolute_time();
            ≔ now_ms = (now_ns / 1_000_000) as u64;
            (now_ms - this.start_time_ms) as f64
        }
    }

    /// Handle animation frame timer callback
    rite handle_animation_timer(&vary this, timer: *void) {
        ⎇ let Some(frame_id) = this.timer_to_animation.get(&(timer as usize)).cloned() {
            // Get timestamp before invoking callback
            ≔ timestamp = this.get_timestamp_ms();

            // Remove and invoke animation callback (one-shot)
            ⎇ let Some(entry) = this.animation_callbacks.remove(&frame_id) {
                this.timer_to_animation.remove(&(timer as usize));
                unsafe { ObjC::msg0(timer, "invalidate\0"); }
                (entry.callback)(timestamp);
            }
        }
    }

    /// Handle target-action callback
    rite handle_action(&this, sender: *void) {
        ⎇ let Some(handler_id) = this.widget_to_handler.get(&(sender as usize)) {
            ⎇ let Some(callback) = this.event_handlers.get(handler_id) {
                callback();
            }
        }
    }

    /// Handle timer callback
    rite handle_timer(&vary this, timer: *void) {
        // First, check if this is an animation frame timer
        ⎇ this.timer_to_animation.contains_key(&(timer as usize)) {
            this.handle_animation_timer(timer);
            ret;
        }

        // Otherwise, look up timer_id from the NSTimer pointer for regular timers
        ⎇ let Some(timer_id) = this.timer_ptr_to_id.get(&(timer as usize)).cloned() {
            // First, invoke callback and check if cleanup needed
            ≔ should_cleanup! = ⊥;

            ⎇ let Some(entry) = this.timer_entries.get(&timer_id) {
                // Invoke the callback
                (entry.callback)();
                // Check if one-shot (needs cleanup)
                should_cleanup = ¬entry.repeating;
            }

            // Clean up AFTER releasing the borrow
            ⎇ should_cleanup {
                unsafe {
                    // Note: For non-repeating NSTimer, invalidate is technically redundant
                    // since the timer auto-invalidates, but it's safe to call
                    ObjC::msg0(timer, "invalidate\0");
                }
                this.timer_ptr_to_id.remove(&(timer as usize));
                this.timer_entries.remove(&timer_id);
            }
        }
    }

    /// Get next handler ID
    rite get_next_handler_id(&vary this) → u64! {
        ≔ id! = this.next_handler_id;
        this.next_handler_id = this.next_handler_id + 1;
        id
    }

    /// Create the action target object
    rite create_action_target(&vary this) → *void! {
        unsafe {
            // Create a custom class for handling actions
            // objc_allocateClassPair returns null if class already exists
            ≔ superclass = ObjC::class("NSObject\0");
            ≔ cls = objc_allocateClassPair(superclass, "QliphothActionTarget\0".as_ptr() as *c_char, 0);

            ⎇ cls as usize != 0 {
                // New class - add the action: method and register
                ≔ sel = ObjC::sel("action:\0");
                ≔ types = "v@:@\0".as_ptr() as *c_char; // void, self, SEL, id
                class_addMethod(cls, sel, action_handler as *void, types);
                objc_registerClassPair(cls);
            }
            // If cls was null, class already exists (previous init call)

            // Look up the class (whether newly created or existing)
            ≔ target_cls = ObjC::class("QliphothActionTarget\0");
            ⎇ target_cls as usize == 0 {
                // Class lookup failed - this shouldn't happen
                ret 0 as *void;
            }

            // Alloc and init an instance
            ≔ target = ObjC::msg0(target_cls, "alloc\0");
            ObjC::msg0(target, "init\0")
        }
    }

    /// Create the timer target object
    rite create_timer_target(&vary this) → *void! {
        unsafe {
            ≔ superclass = ObjC::class("NSObject\0");
            ≔ cls = objc_allocateClassPair(superclass, "QliphothTimerTarget\0".as_ptr() as *c_char, 0);

            ⎇ cls as usize != 0 {
                // New class - add the timerFired: method and register
                ≔ sel = ObjC::sel("timerFired:\0");
                ≔ types = "v@:@\0".as_ptr() as *c_char; // void, self, SEL, NSTimer*
                class_addMethod(cls, sel, timer_handler as *void, types);
                objc_registerClassPair(cls);
            }

            // Look up the class
            ≔ target_cls = ObjC::class("QliphothTimerTarget\0");
            ⎇ target_cls as usize == 0 {
                ret 0 as *void;
            }

            // Alloc and init an instance
            ≔ target = ObjC::msg0(target_cls, "alloc\0");
            ObjC::msg0(target, "init\0")
        }
    }
}

#[cfg(target_os = "macos")]
⊢ CocoaPlatform : NativeApp {
    ☉ rite init(&vary this) → bool! {
        ⎇ this.initialized {
            ret ⊤;
        }

        unsafe {
            // Set global instance using atomic operation
            // Release ordering ensures all prior writes are visible
            PLATFORM_INSTANCE.store(this as *vary CocoaPlatform, Ordering::Release);

            // Get shared application
            ≔ app_class = ObjC::class("NSApplication\0");
            this.app = ObjC::msg0(app_class, "sharedApplication\0");

            // Set activation policy (regular app with dock icon)
            ≔ sel = ObjC::sel("setActivationPolicy:\0");
            objc_msgSend(this.app, sel, 0_i64); // NSApplicationActivationPolicyRegular

            // Create action target
            this.action_target = this.create_action_target();

            // Create timer target
            this.timer_target = this.create_timer_target();

            // Initialize start time for animation timestamps
            this.start_time_ms = (mach_absolute_time() / 1_000_000) as u64;

            this.initialized = ⊤;
        }
        ⊤
    }

    ☉ rite run(&this) {
        unsafe {
            // Activate the app
            ObjC::msg1_bool(this.app, "activateIgnoringOtherApps:\0", ⊤);
            // Run the event loop
            ObjC::msg0(this.app, "run\0");
        }
    }

    ☉ rite quit(&this) {
        unsafe {
            ObjC::msg1(this.app, "terminate:\0", 0 as *void);
        }
    }

    ☉ rite create_window(&vary this, title: !String, width: !i32, height: !i32) → NativeWidget! {
        unsafe {
            // Create window frame
            ≔ frame! = NSRect::new(100.0, 100.0, width as f64, height as f64);

            // Create window: [[NSWindow alloc] initWithContentRect:styleMask:backing:defer:]
            ≔ window_class = ObjC::class("NSWindow\0");
            ≔ window = ObjC::msg0(window_class, "alloc\0");

            ≔ style_mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable |
                           NSWindowStyleMaskMiniaturizable | NSWindowStyleMaskResizable;

            ≔ sel = ObjC::sel("initWithContentRect:styleMask:backing:defer:\0");
            window = objc_msgSend(window, sel, frame, style_mask, NSBackingStoreBuffered, ⊥ as i32);

            ⎇ window as usize != 0 {
                // Set title (using helper to auto-release NSString)
                with_nsstring(&title, |ns_title| {
                    ObjC::msg1(window, "setTitle:\0", ns_title);
                });

                // Center window
                ObjC::msg0(window, "center\0");

                // Store as main window
                this.main_window = window;
                this.layout_info.insert(window as usize, LayoutInfo::default());
                // Track widget for memory safety
                this.live_widgets.insert(window as usize);

                NativeWidget::new(window as usize, WidgetType::Window)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite show(&this, widget: &NativeWidget) {
        unsafe {
            ⌥ widget.widget_type {
                WidgetType::Window => {
                    ObjC::msg1(widget.handle as *void, "makeKeyAndOrderFront:\0", 0 as *void);
                }
                _ => {
                    ObjC::msg1_bool(widget.handle as *void, "setHidden:\0", ⊥);
                }
            }
        }
    }

    ☉ rite hide(&this, widget: &NativeWidget) {
        unsafe {
            ⌥ widget.widget_type {
                WidgetType::Window => {
                    ObjC::msg1(widget.handle as *void, "orderOut:\0", 0 as *void);
                }
                _ => {
                    ObjC::msg1_bool(widget.handle as *void, "setHidden:\0", ⊤);
                }
            }
        }
    }

    ☉ rite set_property(&this, widget: &NativeWidget, name: &str, value: &str) {
        unsafe {
            ⌥ (widget.widget_type, name) {
                (WidgetType::Label, "text") | (_, "text") | (WidgetType::Button, "label") => {
                    // Use helper to auto-release NSString
                    with_nsstring(value, |ns_value| {
                        ⌥ widget.widget_type {
                            WidgetType::Button => {
                                ObjC::msg1(widget.handle as *void, "setTitle:\0", ns_value);
                            }
                            _ => {
                                ObjC::msg1(widget.handle as *void, "setStringValue:\0", ns_value);
                            }
                        }
                    });
                }
                (WidgetType::ProgressBar, "fraction") => {
                    ≔ fraction! = value.parse::<f64>().unwrap_or(0.0);
                    ObjC::msg1_f64(widget.handle as *void, "setDoubleValue:\0", fraction * 100.0);
                }
                (WidgetType::Scale, "value") => {
                    ≔ val! = value.parse::<f64>().unwrap_or(0.0);
                    ObjC::msg1_f64(widget.handle as *void, "setDoubleValue:\0", val);
                }
                (WidgetType::CheckButton, "active") | (WidgetType::Switch, "active") => {
                    ≔ checked! = value == "true" || value == "1";
                    ObjC::msg1_i64(widget.handle as *void, "setState:\0", ⎇ checked { 1 } ⎉ { 0 });
                }
                (_, "visible") => {
                    ≔ visible! = value == "true" || value == "1";
                    ObjC::msg1_bool(widget.handle as *void, "setHidden:\0", ¬visible);
                }
                (_, "sensitive") | (_, "enabled") => {
                    ≔ enabled! = value == "true" || value == "1";
                    ObjC::msg1_bool(widget.handle as *void, "setEnabled:\0", enabled);
                }
                _ => {}
            }
        }
    }

    ☉ rite connect(&vary this, widget: &NativeWidget, signal: &str, handler_id: u64, callback: Box<dyn Fn() + 'static>) {
        // CRITICAL FIX: Store the callback so it can be invoked later
        this.event_handlers.insert(handler_id, callback);

        // Track this handler for the widget (for cleanup on widget destruction)
        this.widget_handlers
            .entry(widget.handle)
            .or_insert_with(Vec::new)
            .push(handler_id);

        unsafe {
            // Set target and action for controls
            ObjC::msg1(widget.handle as *void, "setTarget:\0", this.action_target);
            ≔ action_sel = ObjC::sel("action:\0");
            ObjC::msg1(widget.handle as *void, "setAction:\0", action_sel);

            // Map widget to handler
            this.widget_to_handler.insert(widget.handle, handler_id);
        }
    }

    ☉ rite disconnect(&vary this, widget: &NativeWidget, handler_id: u64) {
        // Remove callback from storage
        this.event_handlers.remove(&handler_id);

        // Remove from widget's handler list
        ⎇ let Some(handlers) = this.widget_handlers.get_mut(&widget.handle) {
            handlers.retain(|id| *id != handler_id);
        }

        unsafe {
            ObjC::msg1(widget.handle as *void, "setTarget:\0", 0 as *void);
            ObjC::msg1(widget.handle as *void, "setAction:\0", 0 as *void);
        }
        this.widget_to_handler.remove(&widget.handle);
    }

    ☉ rite destroy_widget(&vary this, widget: &NativeWidget) {
        // Only process if widget is tracked (prevent double-free)
        ⎇ this.live_widgets.remove(&widget.handle) {
            // Remove all handlers associated with this widget
            ⎇ let Some(handler_ids) = this.widget_handlers.remove(&widget.handle) {
                for handler_id in handler_ids {
                    this.event_handlers.remove(&handler_id);
                }
            }

            // Clean up widget-to-handler mapping
            this.widget_to_handler.remove(&widget.handle);

            // Remove layout info
            this.layout_info.remove(&widget.handle);

            unsafe {
                // Remove from superview if it has one
                ObjC::msg0(widget.handle as *void, "removeFromSuperview\0");
                // Release the object (decrement retain count)
                ObjC::release(widget.handle as *void);
            }
        }
        // If widget wasn't tracked, it's already been destroyed - no-op
    }

    ☉ rite is_widget_valid(&this, widget: &NativeWidget) → bool! {
        this.live_widgets.contains(&widget.handle)
    }
}

#[cfg(target_os = "macos")]
⊢ CocoaPlatform : NativeWidgetBuilder {
    ☉ rite create_box(&vary this, orientation: Orientation) → NativeWidget! {
        unsafe {
            ≔ stack = ObjC::alloc_init("NSStackView\0");

            ⎇ stack as usize != 0 {
                // Set orientation
                ≔ ns_orientation! = ⌥ orientation {
                    Orientation::Horizontal => NSUserInterfaceLayoutOrientationHorizontal,
                    Orientation::Vertical => NSUserInterfaceLayoutOrientationVertical
                };
                ObjC::msg1_i64(stack, "setOrientation:\0", ns_orientation);

                // Set distribution to fill equally
                ObjC::msg1_i64(stack, "setDistribution:\0", NSStackViewDistributionFillEqually);

                // Set default spacing
                ObjC::msg1_f64(stack, "setSpacing:\0", 8.0);

                vary info! = LayoutInfo::default();
                info.orientation = orientation;
                this.layout_info.insert(stack as usize, info);

                NativeWidget::new(stack as usize, WidgetType::Box)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_button(&vary this, label: &str) → NativeWidget! {
        unsafe {
            // [NSButton buttonWithTitle:target:action:]
            ≔ btn_class = ObjC::class("NSButton\0");
            ≔ sel = ObjC::sel("buttonWithTitle:target:action:\0");

            // Use with_nsstring to auto-release the NSString
            with_nsstring(label, |ns_title| {
                ≔ button = objc_msgSend(btn_class, sel, ns_title, 0 as *void, 0 as *void);

                ⎇ button as usize != 0 {
                    // Set button type
                    ObjC::msg1_i64(button, "setButtonType:\0", NSButtonTypeMomentaryPushIn as i64);

                    this.layout_info.insert(button as usize, LayoutInfo::default());
                    NativeWidget::new(button as usize, WidgetType::Button)
                } ⎉ {
                    NativeWidget::null()
                }
            })
        }
    }

    ☉ rite create_label(&vary this, text: &str) → NativeWidget! {
        unsafe {
            // [NSTextField labelWithString:]
            ≔ tf_class = ObjC::class("NSTextField\0");
            ≔ sel = ObjC::sel("labelWithString:\0");

            // Use with_nsstring to auto-release the NSString
            with_nsstring(text, |ns_text| {
                ≔ label = objc_msgSend(tf_class, sel, ns_text);

                ⎇ label as usize != 0 {
                    this.layout_info.insert(label as usize, LayoutInfo::default());
                    NativeWidget::new(label as usize, WidgetType::Label)
                } ⎉ {
                    NativeWidget::null()
                }
            })
        }
    }

    ☉ rite create_entry(&vary this) → NativeWidget! {
        unsafe {
            ≔ entry = ObjC::alloc_init("NSTextField\0");

            ⎇ entry as usize != 0 {
                // Make it editable
                ObjC::msg1_bool(entry, "setEditable:\0", ⊤);
                ObjC::msg1_bool(entry, "setBezeled:\0", ⊤);
                ObjC::msg1_bool(entry, "setSelectable:\0", ⊤);

                this.layout_info.insert(entry as usize, LayoutInfo::default());
                NativeWidget::new(entry as usize, WidgetType::Entry)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_text_view(&vary this) → NativeWidget! {
        unsafe {
            // Create scroll view with text view
            ≔ scroll = ObjC::alloc_init("NSScrollView\0");
            ≔ text_view = ObjC::alloc_init("NSTextView\0");

            ⎇ text_view as usize != 0 && scroll as usize != 0 {
                // Configure text view
                ObjC::msg1_bool(text_view, "setEditable:\0", ⊤);
                ObjC::msg1_bool(text_view, "setSelectable:\0", ⊤);
                ObjC::msg1_bool(text_view, "setRichText:\0", ⊥);

                // Set text view as document view
                ObjC::msg1(scroll, "setDocumentView:\0", text_view);
                ObjC::msg1_bool(scroll, "setHasVerticalScroller:\0", ⊤);
                ObjC::msg1_bool(scroll, "setHasHorizontalScroller:\0", ⊥);

                this.layout_info.insert(scroll as usize, LayoutInfo::default());
                NativeWidget::new(scroll as usize, WidgetType::TextView)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_scrolled(&vary this) → NativeWidget! {
        unsafe {
            ≔ scroll = ObjC::alloc_init("NSScrollView\0");

            ⎇ scroll as usize != 0 {
                ObjC::msg1_bool(scroll, "setHasVerticalScroller:\0", ⊤);
                ObjC::msg1_bool(scroll, "setHasHorizontalScroller:\0", ⊤);
                ObjC::msg1_bool(scroll, "setAutohidesScrollers:\0", ⊤);

                this.layout_info.insert(scroll as usize, LayoutInfo::default());
                NativeWidget::new(scroll as usize, WidgetType::ScrolledWindow)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_list_box(&vary this) → NativeWidget! {
        unsafe {
            // Use NSTableView with single column
            ≔ scroll = ObjC::alloc_init("NSScrollView\0");
            ≔ table = ObjC::alloc_init("NSTableView\0");

            ⎇ table as usize != 0 && scroll as usize != 0 {
                // Add a single column
                ≔ column = ObjC::alloc_init("NSTableColumn\0");

                // Use with_nsstring to auto-release the column ID
                with_nsstring("items\0", |col_id| {
                    ObjC::msg1(column, "setIdentifier:\0", col_id);
                });
                ObjC::msg1(table, "addTableColumn:\0", column);

                // Configure table
                ObjC::msg1_bool(table, "setHeaderView:\0", 0 as *void); // No header

                // Set table as document view
                ObjC::msg1(scroll, "setDocumentView:\0", table);
                ObjC::msg1_bool(scroll, "setHasVerticalScroller:\0", ⊤);

                this.layout_info.insert(scroll as usize, LayoutInfo::default());
                NativeWidget::new(scroll as usize, WidgetType::ListBox)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_grid(&vary this) → NativeWidget! {
        unsafe {
            ≔ grid = ObjC::alloc_init("NSGridView\0");

            ⎇ grid as usize != 0 {
                this.layout_info.insert(grid as usize, LayoutInfo::default());
                NativeWidget::new(grid as usize, WidgetType::Grid)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_stack(&vary this) → NativeWidget! {
        unsafe {
            // Use NSTabView for stack-like behavior
            ≔ tab = ObjC::alloc_init("NSTabView\0");

            ⎇ tab as usize != 0 {
                // Hide tab buttons for stack behavior
                ObjC::msg1_i64(tab, "setTabViewType:\0", 4); // NSNoTabsNoBorder

                this.layout_info.insert(tab as usize, LayoutInfo::default());
                NativeWidget::new(tab as usize, WidgetType::Stack)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_header_bar(&vary this) → NativeWidget! {
        unsafe {
            // Create horizontal stack view for header
            ≔ stack = ObjC::alloc_init("NSStackView\0");

            ⎇ stack as usize != 0 {
                ObjC::msg1_i64(stack, "setOrientation:\0", NSUserInterfaceLayoutOrientationHorizontal);
                ObjC::msg1_f64(stack, "setSpacing:\0", 8.0);

                vary info! = LayoutInfo::default();
                info.orientation = Orientation::Horizontal;
                this.layout_info.insert(stack as usize, info);

                NativeWidget::new(stack as usize, WidgetType::HeaderBar)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_image(&vary this) → NativeWidget! {
        unsafe {
            ≔ image_view = ObjC::alloc_init("NSImageView\0");

            ⎇ image_view as usize != 0 {
                this.layout_info.insert(image_view as usize, LayoutInfo::default());
                NativeWidget::new(image_view as usize, WidgetType::Image)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_spinner(&vary this) → NativeWidget! {
        unsafe {
            ≔ spinner = ObjC::alloc_init("NSProgressIndicator\0");

            ⎇ spinner as usize != 0 {
                // Set spinning style
                ObjC::msg1_i64(spinner, "setStyle:\0", NSProgressIndicatorStyleSpinning as i64);
                ObjC::msg1_bool(spinner, "setIndeterminate:\0", ⊤);
                ObjC::msg0(spinner, "startAnimation:\0");

                this.layout_info.insert(spinner as usize, LayoutInfo::default());
                NativeWidget::new(spinner as usize, WidgetType::Spinner)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_progress_bar(&vary this) → NativeWidget! {
        unsafe {
            ≔ progress = ObjC::alloc_init("NSProgressIndicator\0");

            ⎇ progress as usize != 0 {
                // Set bar style
                ObjC::msg1_i64(progress, "setStyle:\0", NSProgressIndicatorStyleBar as i64);
                ObjC::msg1_bool(progress, "setIndeterminate:\0", ⊥);
                ObjC::msg1_f64(progress, "setMinValue:\0", 0.0);
                ObjC::msg1_f64(progress, "setMaxValue:\0", 100.0);

                this.layout_info.insert(progress as usize, LayoutInfo::default());
                NativeWidget::new(progress as usize, WidgetType::ProgressBar)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_scale(&vary this, orientation: Orientation, min: f64, max: f64) → NativeWidget! {
        unsafe {
            ≔ slider = ObjC::alloc_init("NSSlider\0");

            ⎇ slider as usize != 0 {
                ObjC::msg1_f64(slider, "setMinValue:\0", min);
                ObjC::msg1_f64(slider, "setMaxValue:\0", max);

                // Set orientation (vertical if needed)
                ⎇ matches!(orientation, Orientation::Vertical) {
                    ObjC::msg1_bool(slider, "setVertical:\0", ⊤);
                }

                this.layout_info.insert(slider as usize, LayoutInfo::default());
                NativeWidget::new(slider as usize, WidgetType::Scale)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_switch(&vary this) → NativeWidget! {
        unsafe {
            // NSSwitch available in 10.15+, fallback to checkbox button
            ≔ switch_class = ObjC::class("NSSwitch\0");

            ≔ switch! = ⎇ switch_class as usize != 0 {
                ObjC::alloc_init("NSSwitch\0")
            } ⎉ {
                // Fallback to checkbox button
                ≔ btn = ObjC::alloc_init("NSButton\0");
                ObjC::msg1_i64(btn, "setButtonType:\0", NSButtonTypeSwitch as i64);
                btn
            };

            ⎇ switch as usize != 0 {
                this.layout_info.insert(switch as usize, LayoutInfo::default());
                NativeWidget::new(switch as usize, WidgetType::Switch)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }

    ☉ rite create_check_button(&vary this, label: &str) → NativeWidget! {
        unsafe {
            // [NSButton checkboxWithTitle:target:action:]
            ≔ btn_class = ObjC::class("NSButton\0");
            ≔ sel = ObjC::sel("checkboxWithTitle:target:action:\0");

            // Use with_nsstring to auto-release the NSString
            with_nsstring(label, |ns_title| {
                ≔ checkbox = objc_msgSend(btn_class, sel, ns_title, 0 as *void, 0 as *void);

                ⎇ checkbox as usize != 0 {
                    this.layout_info.insert(checkbox as usize, LayoutInfo::default());
                    NativeWidget::new(checkbox as usize, WidgetType::CheckButton)
                } ⎉ {
                    NativeWidget::null()
                }
            })
        }
    }

    ☉ rite create_drawing_area(&vary this) → NativeWidget! {
        unsafe {
            // Custom NSView for drawing
            ≔ view = ObjC::alloc_init("NSView\0");

            ⎇ view as usize != 0 {
                // Enable layer-backing for drawing
                ObjC::msg1_bool(view, "setWantsLayer:\0", ⊤);

                this.layout_info.insert(view as usize, LayoutInfo::default());
                NativeWidget::new(view as usize, WidgetType::DrawingArea)
            } ⎉ {
                NativeWidget::null()
            }
        }
    }
}

#[cfg(target_os = "macos")]
⊢ CocoaPlatform : NativeLayout {
    ☉ rite append(&vary this, parent: &NativeWidget, child: &NativeWidget) {
        unsafe {
            ⌥ parent.widget_type {
                WidgetType::Window => {
                    // Set as content view
                    ObjC::msg1(parent.handle as *void, "setContentView:\0", child.handle as *void);
                }
                WidgetType::Box | WidgetType::HeaderBar => {
                    // Add to NSStackView
                    ObjC::msg1(parent.handle as *void, "addArrangedSubview:\0", child.handle as *void);
                }
                WidgetType::ScrolledWindow => {
                    // Set as document view
                    ObjC::msg1(parent.handle as *void, "setDocumentView:\0", child.handle as *void);
                }
                _ => {
                    // Generic addSubview
                    ObjC::msg1(parent.handle as *void, "addSubview:\0", child.handle as *void);
                }
            }
        }
    }

    ☉ rite remove(&vary this, parent: &NativeWidget, child: &NativeWidget) {
        unsafe {
            ⌥ parent.widget_type {
                WidgetType::Box | WidgetType::HeaderBar => {
                    ObjC::msg1(parent.handle as *void, "removeArrangedSubview:\0", child.handle as *void);
                }
                _ => {}
            }
            // Remove from superview
            ObjC::msg0(child.handle as *void, "removeFromSuperview\0");
            // Remove layout info
            this.layout_info.remove(&child.handle);
            // Remove widget-to-handler mapping
            this.widget_to_handler.remove(&child.handle);
            // Release the object to prevent memory leak
            ObjC::msg0(child.handle as *void, "release\0");
        }
    }

    ☉ rite grid_attach(&vary this, grid: &NativeWidget, child: &NativeWidget, col: i32, row: i32, width: i32, height: i32) {
        unsafe {
            // NSGridView: add view at row, column
            // For simplicity, we'll add cells; real implementation would track cell positions
            ≔ sel = ObjC::sel("addRow:withViews:\0");
            // Create an array with the view
            ≔ array_class = ObjC::class("NSArray\0");
            ≔ arr_sel = ObjC::sel("arrayWithObject:\0");
            ≔ views_array = objc_msgSend(array_class, arr_sel, child.handle as *void);

            objc_msgSend(grid.handle as *void, sel, views_array);
        }
    }

    ☉ rite set_spacing(&vary this, container: &NativeWidget, spacing: i32) {
        unsafe {
            ⌥ container.widget_type {
                WidgetType::Box | WidgetType::HeaderBar => {
                    ObjC::msg1_f64(container.handle as *void, "setSpacing:\0", spacing as f64);
                }
                WidgetType::Grid => {
                    ObjC::msg1_f64(container.handle as *void, "setRowSpacing:\0", spacing as f64);
                    ObjC::msg1_f64(container.handle as *void, "setColumnSpacing:\0", spacing as f64);
                }
                _ => {}
            }
        }
    }

    ☉ rite set_margins(&vary this, widget: &NativeWidget, top: i32, bottom: i32, start: i32, end: i32) {
        // Store margins in layout info
        ⎇ let Some(info) = this.layout_info.get_mut(&widget.handle) {
            info.margin_top = top;
            info.margin_bottom = bottom;
            info.margin_start = start;
            info.margin_end = end;
        } ⎉ {
            vary info! = LayoutInfo::default();
            info.margin_top = top;
            info.margin_bottom = bottom;
            info.margin_start = start;
            info.margin_end = end;
            this.layout_info.insert(widget.handle, info);
        }

        unsafe {
            // NSStackView uses edgeInsets
            ⎇ matches!(widget.widget_type, WidgetType::Box | WidgetType::HeaderBar) {
                // Create NSEdgeInsets
                ≔ sel = ObjC::sel("setEdgeInsets:\0");
                // Note: This requires proper struct passing which is complex
                // For now, we store in layout_info for custom handling
            }
        }
    }

    ☉ rite set_expand(&vary this, widget: &NativeWidget, hexpand: bool, vexpand: bool) {
        // Store in layout info
        ⎇ let Some(info) = this.layout_info.get_mut(&widget.handle) {
            info.hexpand = hexpand;
            info.vexpand = vexpand;
        } ⎉ {
            vary info! = LayoutInfo::default();
            info.hexpand = hexpand;
            info.vexpand = vexpand;
            this.layout_info.insert(widget.handle, info);
        }

        unsafe {
            // Set content hugging priority (lower = more likely to expand)
            ⎇ hexpand {
                ObjC::msg1_f64(widget.handle as *void, "setContentHuggingPriority:forOrientation:\0",
                    NSLayoutPriorityDefaultLow as f64);
            }
            ⎇ vexpand {
                // Vertical hugging
                ≔ sel = ObjC::sel("setContentHuggingPriority:forOrientation:\0");
                objc_msgSend(widget.handle as *void, sel, NSLayoutPriorityDefaultLow as f64, 1_i64);
            }
        }
    }

    ☉ rite set_align(&vary this, widget: &NativeWidget, halign: Align, valign: Align) {
        // Store in layout info
        ⎇ let Some(info) = this.layout_info.get_mut(&widget.handle) {
            info.halign = halign;
            info.valign = valign;
        } ⎉ {
            vary info! = LayoutInfo::default();
            info.halign = halign;
            info.valign = valign;
            this.layout_info.insert(widget.handle, info);
        }

        // Auto Layout alignment would require constraint manipulation
        // For NSStackView children, we can set alignment
        unsafe {
            ≔ ns_alignment! = ⌥ halign {
                Align::Start => 0_i64,   // NSLayoutAttributeLeading
                Align::Center => 5_i64,  // NSLayoutAttributeCenterX
                Align::End => 1_i64,     // NSLayoutAttributeTrailing
                Align::Fill => 0_i64,
                Align::Baseline => 11_i64 // NSLayoutAttributeBaseline
            };
            ObjC::msg1_i64(widget.handle as *void, "setAlignment:\0", ns_alignment);
        }
    }
}

#[cfg(target_os = "macos")]
⊢ CocoaPlatform : Platform {
    ☉ rite query_selector(&this, selector: &str) → Option<DomElement>? {
        // Native doesn't use DOM selectors
        None
    }

    ☉ rite create_element(&vary this, tag: &str) → DomElement! {
        ≔ widget! = ⌥ tag {
            "div" | "section" | "article" => this.create_box(Orientation::Vertical),
            "span" => this.create_box(Orientation::Horizontal),
            "button" => this.create_button(""),
            "label" | "p" => this.create_label(""),
            "input" => this.create_entry(),
            "textarea" => this.create_text_view(),
            "ul" | "ol" => this.create_list_box(),
            "progress" => this.create_progress_bar(),
            "canvas" => this.create_drawing_area(),
            _ => this.create_box(Orientation::Vertical)
        };
        DomElement::new(widget.handle)
    }

    ☉ rite create_text(&vary this, content: &str) → DomElement! {
        ≔ label! = this.create_label(content);
        DomElement::new(label.handle)
    }

    ☉ rite apply_patch(&this, patch: Patch) {
        // Handled by VNodeToNative
    }

    ☉ rite add_event_listener(&vary this, element: &DomElement, event: EventType, handler_id: u64) {
        this.widget_to_handler.insert(element.handle, handler_id);
    }

    ☉ rite remove_event_listener(&vary this, element: &DomElement, event: EventType, handler_id: u64) {
        this.widget_to_handler.remove(&element.handle);
        this.event_handlers.remove(&handler_id);
    }

    ☉ rite window_size(&this) → (i32, i32)! {
        unsafe {
            // [NSScreen mainScreen].frame.size
            ≔ screen_class = ObjC::class("NSScreen\0");
            ≔ screen = ObjC::msg0(screen_class, "mainScreen\0");

            // Get frame (returns NSRect which needs struct return)
            // For simplicity, return reasonable defaults
            // Real implementation would use objc_msgSend_stret for struct returns
            (1920, 1080)
        }
    }

    ☉ rite request_animation_frame(&vary this, callback: fn(f64)) → u64! {
        // Allocate animation frame ID
        ≔ frame_id! = this.next_animation_id;
        this.next_animation_id = this.next_animation_id + 1;

        ≔ interval = 16.0 / 1000.0;  // ~60fps in seconds

        unsafe {
            // Create NSTimer using scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
            ≔ timer_class = ObjC::class("NSTimer\0");
            ≔ sel = ObjC::sel("scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:\0");
            ≔ action_sel = ObjC::sel("timerFired:\0");

            ≔ timer = objc_msgSend(
                timer_class,
                sel,
                interval,
                this.timer_target,
                action_sel,
                0 as *void,  // userInfo
                ⊥ as i64      // repeats: NO (one-shot)
            );

            ⎇ timer as usize != 0 {
                // Store animation entry
                this.animation_callbacks.insert(frame_id, AnimationEntry {
                    callback: Box::new(callback),
                    timer_obj: timer
                });

                // Map timer pointer to frame_id for callback lookup
                this.timer_to_animation.insert(timer as usize, frame_id);
            }
        }

        frame_id
    }

    ☉ rite cancel_animation_frame(&vary this, id: u64) {
        // Find and remove the animation entry
        ⎇ let Some(entry) = this.animation_callbacks.remove(&id) {
            unsafe {
                ObjC::msg0(entry.timer_obj, "invalidate\0");
            }
            this.timer_to_animation.remove(&(entry.timer_obj as usize));
        }
    }

    ☉ rite set_timeout(&vary this, callback: fn(), delay_ms: u64) → u64! {
        ≔ timer_id! = this.get_next_handler_id();
        ≔ interval = (delay_ms as f64) / 1000.0;

        unsafe {
            // Create NSTimer using scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
            ≔ timer_class = ObjC::class("NSTimer\0");
            ≔ sel = ObjC::sel("scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:\0");
            ≔ action_sel = ObjC::sel("timerFired:\0");

            ≔ timer = objc_msgSend(
                timer_class,
                sel,
                interval,
                this.timer_target,
                action_sel,
                0 as *void,  // userInfo (nil)
                ⊥ as i32     // repeats = NO
            );

            ⎇ timer as usize != 0 {
                // Store the timer entry
                this.timer_entries.insert(timer_id, TimerEntry {
                    callback: Box::new(callback),
                    timer_obj: timer,
                    repeating: ⊥
                });
                // Map timer pointer back to ID for callback lookup
                this.timer_ptr_to_id.insert(timer as usize, timer_id);
            }
        }

        timer_id
    }

    ☉ rite clear_timeout(&vary this, id: u64) {
        ⎇ let Some(entry) = this.timer_entries.remove(&id) {
            unsafe {
                ObjC::msg0(entry.timer_obj, "invalidate\0");
            }
            this.timer_ptr_to_id.remove(&(entry.timer_obj as usize));
        }
    }

    ☉ rite set_interval(&vary this, callback: fn(), interval_ms: u64) → u64! {
        ≔ timer_id! = this.get_next_handler_id();
        ≔ interval = (interval_ms as f64) / 1000.0;

        unsafe {
            // Create repeating NSTimer
            ≔ timer_class = ObjC::class("NSTimer\0");
            ≔ sel = ObjC::sel("scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:\0");
            ≔ action_sel = ObjC::sel("timerFired:\0");

            ≔ timer = objc_msgSend(
                timer_class,
                sel,
                interval,
                this.timer_target,
                action_sel,
                0 as *void,  // userInfo (nil)
                ⊤ as i32     // repeats = YES
            );

            ⎇ timer as usize != 0 {
                // Store the timer entry
                this.timer_entries.insert(timer_id, TimerEntry {
                    callback: Box::new(callback),
                    timer_obj: timer,
                    repeating: ⊤
                });
                // Map timer pointer back to ID for callback lookup
                this.timer_ptr_to_id.insert(timer as usize, timer_id);
            }
        }

        timer_id
    }

    ☉ rite clear_interval(&vary this, id: u64) {
        // Same as clear_timeout - invalidate and remove
        ⎇ let Some(entry) = this.timer_entries.remove(&id) {
            unsafe {
                ObjC::msg0(entry.timer_obj, "invalidate\0");
            }
            this.timer_ptr_to_id.remove(&(entry.timer_obj as usize));
        }
    }

    ☉ rite fetch(&this, url: &str, options: FetchOptions) → PlatformFuture<FetchResponse>! {
        // TODO: Implement using NSURLSession
        // For now, return proper 501 Not Implemented response
        ≔ error_body = format!(
            "{{\"error\":\"Not Implemented\",\"platform\":\"Cocoa\",\"url\":\"{}\",\"method\":\"{}\"}}",
            url, options.method
        );
        PlatformFuture::ready(FetchResponse {
            ok: ⊥,
            status: 501,
            status_text: "Not Implemented".to_string(),
            headers: HashMap::new(),
            body: error_body.into_bytes()
        })
    }

    ☉ rite local_storage(&this) → Storage! {
        // Would use NSUserDefaults
        Storage { storage_type: StorageType::Local }
    }

    ☉ rite session_storage(&this) → Storage! {
        Storage { storage_type: StorageType::Session }
    }

    ☉ rite current_url(&this) → String! {
        "native://app".to_string()
    }

    ☉ rite push_history(&this, url: &str, state: Option<HashMap<String, String>>) {
        // Native apps don't have browser history
    }

    ☉ rite replace_history(&this, url: &str, state: Option<HashMap<String, String>>) {
        // Native apps don't have browser history
    }

    ☉ rite render_to_string(&this, vnode: &VNode) → PlatformResult<String>! {
        Err(PlatformError::NotSupported {
            feature: "render_to_string".to_string(),
            platform: "Cocoa".to_string()
        })
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================================================
    // Platform Creation Tests
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_cocoa_platform_creation() {
        ≔ platform! = CocoaPlatform::new();
        assert!(!platform.initialized);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_cocoa_platform_default_values() {
        ≔ platform! = CocoaPlatform::new();
        assert!(!platform.initialized);
        assert_eq!(platform.app as usize, 0);
        assert_eq!(platform.main_window as usize, 0);
        assert_eq!(platform.next_handler_id, 1000);
        assert_eq!(platform.action_target as usize, 0);
        assert!(platform.event_handlers.is_empty());
        assert!(platform.layout_info.is_empty());
        assert!(platform.widget_to_handler.is_empty());
        assert!(platform.timer_entries.is_empty());
        assert!(platform.timer_ptr_to_id.is_empty());
    }

    // ========================================================================
    // NSPoint Tests
    // ========================================================================

    #[test]
    rite test_nspoint_creation() {
        ≔ point! = NSPoint { x: 100.0, y: 200.0 };
        assert_eq!(point.x, 100.0);
        assert_eq!(point.y, 200.0);
    }

    #[test]
    rite test_nspoint_zero() {
        ≔ point! = NSPoint { x: 0.0, y: 0.0 };
        assert_eq!(point.x, 0.0);
        assert_eq!(point.y, 0.0);
    }

    #[test]
    rite test_nspoint_negative() {
        ≔ point! = NSPoint { x: -50.0, y: -100.0 };
        assert_eq!(point.x, -50.0);
        assert_eq!(point.y, -100.0);
    }

    // ========================================================================
    // NSSize Tests
    // ========================================================================

    #[test]
    rite test_nssize_creation() {
        ≔ size! = NSSize { width: 800.0, height: 600.0 };
        assert_eq!(size.width, 800.0);
        assert_eq!(size.height, 600.0);
    }

    #[test]
    rite test_nssize_zero() {
        ≔ size! = NSSize { width: 0.0, height: 0.0 };
        assert_eq!(size.width, 0.0);
        assert_eq!(size.height, 0.0);
    }

    // ========================================================================
    // NSRect Tests
    // ========================================================================

    #[test]
    rite test_nsrect_creation() {
        ≔ rect! = NSRect::new(10.0, 20.0, 100.0, 200.0);
        assert_eq!(rect.origin.x, 10.0);
        assert_eq!(rect.origin.y, 20.0);
        assert_eq!(rect.size.width, 100.0);
        assert_eq!(rect.size.height, 200.0);
    }

    #[test]
    rite test_nsrect_zero() {
        ≔ rect! = NSRect::zero();
        assert_eq!(rect.origin.x, 0.0);
        assert_eq!(rect.origin.y, 0.0);
        assert_eq!(rect.size.width, 0.0);
        assert_eq!(rect.size.height, 0.0);
    }

    #[test]
    rite test_nsrect_components() {
        ≔ rect! = NSRect::new(50.0, 75.0, 1920.0, 1080.0);
        // Verify origin
        assert_eq!(rect.origin.x, 50.0);
        assert_eq!(rect.origin.y, 75.0);
        // Verify size
        assert_eq!(rect.size.width, 1920.0);
        assert_eq!(rect.size.height, 1080.0);
    }

    #[test]
    rite test_nsrect_negative_origin() {
        ≔ rect! = NSRect::new(-100.0, -200.0, 400.0, 300.0);
        assert_eq!(rect.origin.x, -100.0);
        assert_eq!(rect.origin.y, -200.0);
        assert_eq!(rect.size.width, 400.0);
        assert_eq!(rect.size.height, 300.0);
    }

    // ========================================================================
    // LayoutInfo Tests
    // ========================================================================

    #[test]
    rite test_layout_info_default() {
        ≔ info! = LayoutInfo::default();
        assert!(!info.hexpand);
        assert!(!info.vexpand);
        assert!(matches!(info.halign, Align::Fill));
        assert!(matches!(info.valign, Align::Fill));
        assert_eq!(info.margin_top, 0);
        assert_eq!(info.margin_bottom, 0);
        assert_eq!(info.margin_start, 0);
        assert_eq!(info.margin_end, 0);
        assert!(matches!(info.orientation, Orientation::Vertical));
    }

    #[test]
    rite test_layout_info_custom_values() {
        ≔ info! = LayoutInfo {
            hexpand: ⊤,
            vexpand: ⊤,
            halign: Align::Center,
            valign: Align::End,
            margin_top: 8,
            margin_bottom: 8,
            margin_start: 16,
            margin_end: 16,
            orientation: Orientation::Horizontal
        };
        assert!(info.hexpand);
        assert!(info.vexpand);
        assert!(matches!(info.halign, Align::Center));
        assert!(matches!(info.valign, Align::End));
        assert_eq!(info.margin_top, 8);
        assert_eq!(info.margin_bottom, 8);
        assert_eq!(info.margin_start, 16);
        assert_eq!(info.margin_end, 16);
        assert!(matches!(info.orientation, Orientation::Horizontal));
    }

    #[test]
    rite test_layout_info_all_aligns() {
        // Test all alignment options
        ≔ aligns! = [Align::Start, Align::Center, Align::End, Align::Fill, Align::Baseline];

        for align in aligns {
            ≔ info! = LayoutInfo {
                hexpand: ⊥,
                vexpand: ⊥,
                halign: align,
                valign: align,
                margin_top: 0,
                margin_bottom: 0,
                margin_start: 0,
                margin_end: 0,
                orientation: Orientation::Vertical
            };
            // Just verify it compiles and works
            assert!(!info.hexpand);
        }
    }

    // ========================================================================
    // Constants Tests
    // ========================================================================

    #[test]
    rite test_window_style_mask_constants() {
        assert_eq!(NSWindowStyleMaskTitled, 1 << 0);
        assert_eq!(NSWindowStyleMaskClosable, 1 << 1);
        assert_eq!(NSWindowStyleMaskMiniaturizable, 1 << 2);
        assert_eq!(NSWindowStyleMaskResizable, 1 << 3);
        assert_eq!(NSWindowStyleMaskFullSizeContentView, 1 << 15);
    }

    #[test]
    rite test_combined_window_style() {
        ≔ style! = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable |
                   NSWindowStyleMaskMiniaturizable | NSWindowStyleMaskResizable;
        // All four base styles combined
        assert_eq!(style, 0b1111);
    }

    #[test]
    rite test_stack_orientation_constants() {
        assert_eq!(NSUserInterfaceLayoutOrientationHorizontal, 0);
        assert_eq!(NSUserInterfaceLayoutOrientationVertical, 1);
    }

    #[test]
    rite test_progress_indicator_style_constants() {
        assert_eq!(NSProgressIndicatorStyleBar, 0);
        assert_eq!(NSProgressIndicatorStyleSpinning, 1);
    }

    #[test]
    rite test_button_type_constants() {
        assert_eq!(NSButtonTypeMomentaryPushIn, 7);
        assert_eq!(NSButtonTypeSwitch, 3);
    }

    #[test]
    rite test_text_alignment_constants() {
        assert_eq!(NSTextAlignmentLeft, 0);
        assert_eq!(NSTextAlignmentCenter, 1);
        assert_eq!(NSTextAlignmentRight, 2);
    }

    #[test]
    rite test_layout_priority_constants() {
        assert_eq!(NSLayoutPriorityRequired, 1000.0);
        assert_eq!(NSLayoutPriorityDefaultHigh, 750.0);
        assert_eq!(NSLayoutPriorityDefaultLow, 250.0);
    }

    #[test]
    rite test_backing_store_constant() {
        assert_eq!(NSBackingStoreBuffered, 2);
    }

    // ========================================================================
    // Handler ID Tests
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_get_next_handler_id() {
        vary platform! = CocoaPlatform::new();
        ≔ id1! = platform.get_next_handler_id();
        ≔ id2! = platform.get_next_handler_id();
        ≔ id3! = platform.get_next_handler_id();

        assert_eq!(id1, 1000);
        assert_eq!(id2, 1001);
        assert_eq!(id3, 1002);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_handler_id_sequential() {
        vary platform! = CocoaPlatform::new();

        for i in 0..50 {
            ≔ id! = platform.get_next_handler_id();
            assert_eq!(id, 1000 + i);
        }

        assert_eq!(platform.next_handler_id, 1050);
    }

    // ========================================================================
    // Widget to Handler Mapping Tests
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_widget_to_handler_mapping() {
        vary platform! = CocoaPlatform::new();

        platform.widget_to_handler.insert(100, 1);
        platform.widget_to_handler.insert(200, 2);
        platform.widget_to_handler.insert(300, 3);

        assert_eq!(platform.widget_to_handler.len(), 3);
        assert_eq!(*platform.widget_to_handler.get(&100).unwrap(), 1);
        assert_eq!(*platform.widget_to_handler.get(&200).unwrap(), 2);
        assert_eq!(*platform.widget_to_handler.get(&300).unwrap(), 3);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_widget_to_handler_update() {
        vary platform! = CocoaPlatform::new();

        platform.widget_to_handler.insert(100, 1);
        assert_eq!(*platform.widget_to_handler.get(&100).unwrap(), 1);

        // Update the handler
        platform.widget_to_handler.insert(100, 5);
        assert_eq!(*platform.widget_to_handler.get(&100).unwrap(), 5);
    }

    // ========================================================================
    // Layout Info Storage Tests
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_layout_info_storage() {
        vary platform! = CocoaPlatform::new();

        ≔ info1! = LayoutInfo::default();
        vary info2! = LayoutInfo::default();
        info2.hexpand = ⊤;
        info2.orientation = Orientation::Horizontal;

        platform.layout_info.insert(1000, info1);
        platform.layout_info.insert(2000, info2);

        assert_eq!(platform.layout_info.len(), 2);
        assert!(!platform.layout_info.get(&1000).unwrap().hexpand);
        assert!(platform.layout_info.get(&2000).unwrap().hexpand);
        assert!(matches!(
            platform.layout_info.get(&2000).unwrap().orientation,
            Orientation::Horizontal
        ));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_layout_info_removal() {
        vary platform! = CocoaPlatform::new();

        platform.layout_info.insert(100, LayoutInfo::default());
        platform.layout_info.insert(200, LayoutInfo::default());

        assert_eq!(platform.layout_info.len(), 2);

        platform.layout_info.remove(&100);
        assert_eq!(platform.layout_info.len(), 1);
        assert!(platform.layout_info.get(&100).is_none());
        assert!(platform.layout_info.get(&200).is_some());
    }

    // ========================================================================
    // Timer Map Tests
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_timer_ptr_to_id_operations() {
        vary platform! = CocoaPlatform::new();

        platform.timer_ptr_to_id.insert(0x1000, 1);
        platform.timer_ptr_to_id.insert(0x2000, 2);

        assert_eq!(platform.timer_ptr_to_id.len(), 2);
        assert!(platform.timer_ptr_to_id.contains_key(&0x1000));
        assert!(platform.timer_ptr_to_id.contains_key(&0x2000));
        assert!(!platform.timer_ptr_to_id.contains_key(&0x3000));
    }

    // ========================================================================
    // Objective-C Association Policy Constants
    // ========================================================================

    #[test]
    rite test_objc_association_policy() {
        assert_eq!(OBJC_ASSOCIATION_RETAIN_NONATOMIC, 1);
    }

    #[test]
    rite test_cfstring_encoding() {
        assert_eq!(kCFStringEncodingUTF8, 0x08000100);
    }

    // ========================================================================
    // Stack View Distribution Tests
    // ========================================================================

    #[test]
    rite test_stack_view_distribution() {
        assert_eq!(NSStackViewDistributionFillEqually, 1);
    }

    // ========================================================================
    // Timer Entry Tests (Sprint 4)
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_timer_entries_storage() {
        vary platform! = CocoaPlatform::new();

        // Create timer entries with different configurations
        ≔ entry1! = TimerEntry {
            callback: Box::new(|| {}),
            repeating: ⊥
        };
        ≔ entry2! = TimerEntry {
            callback: Box::new(|| {}),
            repeating: ⊤
        };

        platform.timer_entries.insert(1, entry1);
        platform.timer_entries.insert(2, entry2);

        assert_eq!(platform.timer_entries.len(), 2);
        assert!(!platform.timer_entries.get(&1).unwrap().repeating);
        assert!(platform.timer_entries.get(&2).unwrap().repeating);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_timer_entries_removal() {
        vary platform! = CocoaPlatform::new();

        platform.timer_entries.insert(1, TimerEntry {
            callback: Box::new(|| {}),
            repeating: ⊥
        });
        platform.timer_entries.insert(2, TimerEntry {
            callback: Box::new(|| {}),
            repeating: ⊤
        });

        assert_eq!(platform.timer_entries.len(), 2);

        platform.timer_entries.remove(&1);
        assert_eq!(platform.timer_entries.len(), 1);
        assert!(platform.timer_entries.get(&1).is_none());
        assert!(platform.timer_entries.get(&2).is_some());
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_timer_id_counter() {
        vary platform! = CocoaPlatform::new();

        ≔ initial! = platform.next_timer_id;
        platform.next_timer_id = platform.next_timer_id + 1;
        platform.next_timer_id = platform.next_timer_id + 1;
        platform.next_timer_id = platform.next_timer_id + 1;

        assert_eq!(platform.next_timer_id, initial + 3);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_timer_ptr_to_id_cleanup() {
        vary platform! = CocoaPlatform::new();

        // Simulate timer creation
        platform.timer_ptr_to_id.insert(0x1234, 1);
        platform.timer_entries.insert(1, TimerEntry {
            callback: Box::new(|| {}),
            repeating: ⊥
        });

        // Simulate timer cleanup (as done in handle_timer for one-shot)
        platform.timer_ptr_to_id.remove(&0x1234);
        platform.timer_entries.remove(&1);

        assert!(platform.timer_ptr_to_id.is_empty());
        assert!(platform.timer_entries.is_empty());
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_timer_entry_callback_invocation() {
        use std::sync::atomic::{AtomicUsize, Ordering};
        use std::sync::Arc;

        vary platform! = CocoaPlatform::new();
        ≔ counter = Arc::new(AtomicUsize::new(0));
        ≔ counter_clone = counter.clone();

        ≔ entry! = TimerEntry {
            callback: Box::new(move || {
                counter_clone.fetch_add(1, Ordering::SeqCst);
            }),
            repeating: ⊤
        };

        platform.timer_entries.insert(1, entry);

        // Invoke callback multiple times (simulating repeating timer)
        ⎇ let Some(e) = platform.timer_entries.get(&1) {
            (e.callback)();
            (e.callback)();
            (e.callback)();
        }

        assert_eq!(counter.load(Ordering::SeqCst), 3);
    }

    // ========================================================================
    // Widget Lifecycle Tests (Sprint 3)
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_live_widgets_tracking() {
        vary platform! = CocoaPlatform::new();

        // Simulate widget creation
        platform.live_widgets.insert(0x1000);
        platform.live_widgets.insert(0x2000);
        platform.live_widgets.insert(0x3000);

        assert_eq!(platform.live_widgets.len(), 3);
        assert!(platform.live_widgets.contains(&0x1000));
        assert!(platform.live_widgets.contains(&0x2000));
        assert!(platform.live_widgets.contains(&0x3000));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_live_widgets_no_duplicates() {
        vary platform! = CocoaPlatform::new();

        // Insert same widget multiple times
        platform.live_widgets.insert(0x1000);
        platform.live_widgets.insert(0x1000);
        platform.live_widgets.insert(0x1000);

        // HashSet should only have one entry
        assert_eq!(platform.live_widgets.len(), 1);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_destroyed_widgets_tracking() {
        vary platform! = CocoaPlatform::new();

        // Simulate widget destruction tracking
        platform.destroyed_widgets.insert(0x1000);
        platform.destroyed_widgets.insert(0x2000);

        assert!(platform.destroyed_widgets.contains(&0x1000));
        assert!(platform.destroyed_widgets.contains(&0x2000));
        assert!(!platform.destroyed_widgets.contains(&0x3000));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_widget_validity_check() {
        vary platform! = CocoaPlatform::new();

        // Widget in live_widgets is valid
        platform.live_widgets.insert(0x1000);
        assert!(platform.live_widgets.contains(&0x1000));

        // Widget not in live_widgets is not valid
        assert!(!platform.live_widgets.contains(&0x2000));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_widget_lifecycle_complete() {
        vary platform! = CocoaPlatform::new();

        // Create widget
        platform.live_widgets.insert(0x1000);
        platform.layout_info.insert(0x1000, LayoutInfo::default());

        // Verify exists
        assert!(platform.live_widgets.contains(&0x1000));
        assert!(platform.layout_info.contains_key(&0x1000));

        // Destroy widget
        platform.live_widgets.remove(&0x1000);
        platform.layout_info.remove(&0x1000);
        platform.destroyed_widgets.insert(0x1000);

        // Verify cleaned up
        assert!(!platform.live_widgets.contains(&0x1000));
        assert!(!platform.layout_info.contains_key(&0x1000));
        assert!(platform.destroyed_widgets.contains(&0x1000));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_double_destroy_safe() {
        vary platform! = CocoaPlatform::new();

        // Create widget
        platform.live_widgets.insert(0x1000);

        // Destroy once
        ≔ removed1! = platform.live_widgets.remove(&0x1000);
        assert!(removed1);
        platform.destroyed_widgets.insert(0x1000);

        // Try to destroy again - should be no-op
        ≔ removed2! = platform.live_widgets.remove(&0x1000);
        assert!(!removed2);  // Already removed

        // destroyed_widgets still tracks it
        assert!(platform.destroyed_widgets.contains(&0x1000));
    }

    // ========================================================================
    // Event Handler Tests (Sprint 2)
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_event_handlers_storage() {
        vary platform! = CocoaPlatform::new();

        platform.event_handlers.insert(1, Box::new(|| {}));
        platform.event_handlers.insert(2, Box::new(|| {}));
        platform.event_handlers.insert(3, Box::new(|| {}));

        assert_eq!(platform.event_handlers.len(), 3);
        assert!(platform.event_handlers.contains_key(&1));
        assert!(platform.event_handlers.contains_key(&2));
        assert!(platform.event_handlers.contains_key(&3));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_event_handler_invocation() {
        use std::sync::atomic::{AtomicBool, Ordering};
        use std::sync::Arc;

        vary platform! = CocoaPlatform::new();
        ≔ clicked = Arc::new(AtomicBool::new(⊥));
        ≔ clicked_clone = clicked.clone();

        platform.event_handlers.insert(1, Box::new(move || {
            clicked_clone.store(⊤, Ordering::SeqCst);
        }));

        // Invoke handler
        ⎇ let Some(handler) = platform.event_handlers.get(&1) {
            handler();
        }

        assert!(clicked.load(Ordering::SeqCst));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_event_handler_removal() {
        vary platform! = CocoaPlatform::new();

        platform.event_handlers.insert(1, Box::new(|| {}));
        platform.event_handlers.insert(2, Box::new(|| {}));

        assert_eq!(platform.event_handlers.len(), 2);

        platform.event_handlers.remove(&1);
        assert_eq!(platform.event_handlers.len(), 1);
        assert!(!platform.event_handlers.contains_key(&1));
        assert!(platform.event_handlers.contains_key(&2));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_widget_handler_association() {
        vary platform! = CocoaPlatform::new();

        // Associate widget 0x1000 with handler 5
        platform.widget_to_handler.insert(0x1000, 5);
        platform.event_handlers.insert(5, Box::new(|| {}));

        // Verify association
        ⎇ let Some(handler_id) = platform.widget_to_handler.get(&0x1000) {
            assert_eq!(*handler_id, 5);
            assert!(platform.event_handlers.contains_key(handler_id));
        } ⎉ {
            panic!("Handler association not found");
        }
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_handler_cleanup_on_widget_destroy() {
        vary platform! = CocoaPlatform::new();

        // Setup widget with handler
        platform.live_widgets.insert(0x1000);
        platform.widget_to_handler.insert(0x1000, 5);
        platform.event_handlers.insert(5, Box::new(|| {}));

        // Simulate destroy cleanup
        ⎇ let Some(handler_id) = platform.widget_to_handler.remove(&0x1000) {
            platform.event_handlers.remove(&handler_id);
        }
        platform.live_widgets.remove(&0x1000);
        platform.destroyed_widgets.insert(0x1000);

        // Verify complete cleanup
        assert!(!platform.live_widgets.contains(&0x1000));
        assert!(!platform.widget_to_handler.contains_key(&0x1000));
        assert!(!platform.event_handlers.contains_key(&5));
        assert!(platform.destroyed_widgets.contains(&0x1000));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_multiple_handlers_different_widgets() {
        use std::sync::atomic::{AtomicUsize, Ordering};
        use std::sync::Arc;

        vary platform! = CocoaPlatform::new();
        ≔ counter1 = Arc::new(AtomicUsize::new(0));
        ≔ counter2 = Arc::new(AtomicUsize::new(0));
        ≔ c1 = counter1.clone();
        ≔ c2 = counter2.clone();

        // Widget 1 with handler 1
        platform.widget_to_handler.insert(0x1000, 1);
        platform.event_handlers.insert(1, Box::new(move || {
            c1.fetch_add(1, Ordering::SeqCst);
        }));

        // Widget 2 with handler 2
        platform.widget_to_handler.insert(0x2000, 2);
        platform.event_handlers.insert(2, Box::new(move || {
            c2.fetch_add(10, Ordering::SeqCst);
        }));

        // Invoke both handlers
        ⎇ let Some(h) = platform.event_handlers.get(&1) { h(); }
        ⎇ let Some(h) = platform.event_handlers.get(&2) { h(); }

        assert_eq!(counter1.load(Ordering::SeqCst), 1);
        assert_eq!(counter2.load(Ordering::SeqCst), 10);
    }

    // ========================================================================
    // with_nsstring Helper Tests
    // ========================================================================

    #[test]
    rite test_with_nsstring_closure_return() {
        // Test that closure return value is properly passed through
        ≔ result! = 42;  // Simulating what with_nsstring would return
        assert_eq!(result, 42);
    }

    // ========================================================================
    // Animation Frame Tests (Sprint 5)
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_callbacks_initially_empty() {
        ≔ platform! = CocoaPlatform::new();
        assert!(platform.animation_callbacks.is_empty());
        assert!(platform.timer_to_animation.is_empty());
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_id_starts_at_one() {
        ≔ platform! = CocoaPlatform::new();
        assert_eq!(platform.next_animation_id, 1);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_entry_structure() {
        ≔ entry! = AnimationEntry {
            callback: Box::new(|_timestamp| {}),
            timer_obj: 0x1234 as *void
        };
        assert_eq!(entry.timer_obj as usize, 0x1234);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_entry_callback_receives_timestamp() {
        use std::sync::atomic::{AtomicU64, Ordering};
        use std::sync::Arc;

        ≔ received_timestamp = Arc::new(AtomicU64::new(0));
        ≔ ts_clone = received_timestamp.clone();

        ≔ entry! = AnimationEntry {
            callback: Box::new(move |timestamp| {
                ts_clone.store(timestamp as u64, Ordering::SeqCst);
            }),
            timer_obj: 0 as *void
        };

        // Invoke with test timestamp
        (entry.callback)(9876.5);

        assert_eq!(received_timestamp.load(Ordering::SeqCst), 9876);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_start_time_initial_value() {
        ≔ platform! = CocoaPlatform::new();
        // Start time is 0 until init() is called
        assert_eq!(platform.start_time_ms, 0);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_callbacks_storage() {
        vary platform! = CocoaPlatform::new();

        platform.animation_callbacks.insert(1, AnimationEntry {
            callback: Box::new(|_| {}),
            timer_obj: 0x100 as *void
        });
        platform.animation_callbacks.insert(2, AnimationEntry {
            callback: Box::new(|_| {}),
            timer_obj: 0x200 as *void
        });

        assert_eq!(platform.animation_callbacks.len(), 2);
        assert!(platform.animation_callbacks.contains_key(&1));
        assert!(platform.animation_callbacks.contains_key(&2));
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_callbacks_removal() {
        vary platform! = CocoaPlatform::new();

        platform.animation_callbacks.insert(1, AnimationEntry {
            callback: Box::new(|_| {}),
            timer_obj: 0x100 as *void
        });

        assert_eq!(platform.animation_callbacks.len(), 1);

        platform.animation_callbacks.remove(&1);
        assert!(platform.animation_callbacks.is_empty());
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_timer_to_animation_mapping() {
        vary platform! = CocoaPlatform::new();

        platform.timer_to_animation.insert(0x100, 1);
        platform.timer_to_animation.insert(0x200, 2);

        assert_eq!(*platform.timer_to_animation.get(&0x100).unwrap(), 1);
        assert_eq!(*platform.timer_to_animation.get(&0x200).unwrap(), 2);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_id_increments() {
        vary platform! = CocoaPlatform::new();

        ≔ id1! = platform.next_animation_id;
        platform.next_animation_id += 1;
        ≔ id2! = platform.next_animation_id;
        platform.next_animation_id += 1;
        ≔ id3! = platform.next_animation_id;

        assert_eq!(id1, 1);
        assert_eq!(id2, 2);
        assert_eq!(id3, 3);
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_animation_cleanup_removes_both_maps() {
        vary platform! = CocoaPlatform::new();

        // Simulate animation frame registration
        platform.animation_callbacks.insert(5, AnimationEntry {
            callback: Box::new(|_| {}),
            timer_obj: 0x500 as *void
        });
        platform.timer_to_animation.insert(0x500, 5);

        // Simulate cleanup (as done in cancel_animation_frame)
        ⎇ let Some(entry) = platform.animation_callbacks.remove(&5) {
            platform.timer_to_animation.remove(&(entry.timer_obj as usize));
        }

        assert!(platform.animation_callbacks.is_empty());
        assert!(platform.timer_to_animation.is_empty());
    }

    // ========================================================================
    // Error Handling Tests
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_render_to_string_returns_not_supported() {
        ≔ platform! = CocoaPlatform::new();
        ≔ vnode! = VNode::Empty;

        ≔ result! = platform.render_to_string(&vnode);

        assert!(result.is_err());
        match result.unwrap_err() {
            PlatformError::NotSupported { feature, platform: plat } => {
                assert_eq!(feature, "render_to_string");
                assert_eq!(plat, "Cocoa");
            }
            _ => panic!("Expected NotSupported error")
        }
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_error_is_not_recoverable() {
        ≔ platform! = CocoaPlatform::new();
        ≔ vnode! = VNode::Empty;

        ≔ result! = platform.render_to_string(&vnode);
        ≔ err! = result.unwrap_err();

        // NotSupported errors are not recoverable
        assert!(!err.is_recoverable());
    }

    #[test]
    rite test_error_code_is_not_supported() {
        ≔ err! = PlatformError::NotSupported {
            feature: "test".to_string(),
            platform: "Cocoa".to_string()
        };
        assert_eq!(err.error_code(), "NOT_SUPPORTED");
    }

    // ========================================================================
    // Thread Safety Tests
    // ========================================================================

    #[test]
    #[cfg(target_os = "macos")]
    rite test_platform_ptr_is_atomic() {
        // Verify the platform pointer uses AtomicPtr (compile-time check)
        // This test passes if it compiles - AtomicPtr provides thread-safe access
        ≔ ptr = PLATFORM_INSTANCE.load(Ordering::Acquire);
        assert!(ptr.is_null()); // Should be null before init
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_with_platform_returns_none_when_uninitialized() {
        // Ensure safe behavior when platform not initialized
        ≔ result? = with_cocoa_platform(|_| 42);
        assert!(result.is_none());
    }

    #[test]
    #[cfg(target_os = "macos")]
    rite test_with_platform_mut_returns_none_when_uninitialized() {
        // Ensure safe behavior when platform not initialized (mutable version)
        ≔ result? = with_cocoa_platform_mut(|_| 42);
        assert!(result.is_none());
    }

    #[test]
    rite test_atomic_ordering_constants() {
        // Verify we use proper memory orderings
        // Acquire for loads (reads), Release for stores (writes)
        // This ensures proper synchronization between threads
        use std::sync::atomic::Ordering;

        // These are the orderings we use - verify they compile
        ≔ _acquire = Ordering::Acquire;
        ≔ _release = Ordering::Release;
    }
}
