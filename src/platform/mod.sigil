// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Platform Module
// Cross-platform bindings for browser, SSR, and native environments

use std::collections::HashMap;
use std::rc::Rc;
use std::cell::RefCell;
use crate::core::vdom::{VNode, Patch};
use crate::core::events::{Event, EventDelegator, EventType};
use crate::core::error::{PlatformError, PlatformResult};

// Native platform backends (GTK4, Win32, Cocoa)
☉ mod native;
☉ use native::{NativeWidget, WidgetType, NativeApp, NativeWidgetBuilder, NativeLayout, VNodeToNative};

// Mock platform for testing
☉ mod mock;
☉ use mock::MockPlatform;

#[cfg(target_os = "linux")]
☉ use native::Gtk4Platform;

#[cfg(target_os = "windows")]
☉ use native::Win32Platform;

#[cfg(target_os = "macos")]
☉ use native::CocoaPlatform;

/// Platform abstraction
☉ aspect Platform {
    /// Query DOM element by selector
    rite query_selector(&this, selector: &str) → Option<DomElement>?;

    /// Create DOM element
    rite create_element(&this, tag: &str) → DomElement!;

    /// Create text node
    rite create_text(&this, content: &str) → DomElement!;

    /// Apply patch to DOM
    rite apply_patch(&this, patch: Patch);

    /// Add event listener
    rite add_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64);

    /// Remove event listener
    rite remove_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64);

    /// Get window dimensions
    rite window_size(&this) → (i32, i32)!;

    /// Request animation frame
    rite request_animation_frame(&vary this, callback: fn(f64)) → u64!;

    /// Cancel animation frame
    rite cancel_animation_frame(&vary this, id: u64);

    /// Set timeout
    rite set_timeout(&vary this, callback: fn(), delay_ms: u64) → u64!;

    /// Clear timeout
    rite clear_timeout(&vary this, id: u64);

    /// Set interval
    rite set_interval(&vary this, callback: fn(), interval_ms: u64) → u64!;

    /// Clear interval
    rite clear_interval(&vary this, id: u64);

    /// Fetch URL
    rite fetch(&this, url: &str, options: FetchOptions) → PlatformFuture<FetchResponse>!;

    /// Get local storage
    rite local_storage(&this) → Storage!;

    /// Get session storage
    rite session_storage(&this) → Storage!;

    /// Get current URL
    rite current_url(&this) → String!;

    /// Push history state
    rite push_history(&this, url: &str, state: Option<HashMap<String, String>>);

    /// Replace history state
    rite replace_history(&this, url: &str, state: Option<HashMap<String, String>>);

    /// Render to string (for SSR)
    /// Returns NotSupported error on platforms that don't support SSR
    rite render_to_string(&this, vnode: &VNode) → PlatformResult<String>!;
}

/// Platform-aware Future for async operations
/// This provides a simple wrapper that can be blocked on for testing.
/// For real async use, call `.await` (when Sigil async is fully supported).
/// For synchronous testing, call `.block()` to immediately get the result.
☉ sigil PlatformFuture<T> {
    value: T!
}

⊢<T> PlatformFuture<T> {
    /// Create a ready future that immediately holds a value
    ☉ rite ready(value: T) → This! {
        PlatformFuture { value }
    }

    /// Block and wait for the result synchronously
    /// For use in tests - allows sync execution of async APIs
    ☉ rite block(this) → T! {
        this.value
    }

    /// Map the inner value to a new type
    ☉ rite map<U>(this, f: fn(T) → U) → PlatformFuture<U>! {
        PlatformFuture::ready(f(this.value))
    }
}

/// DOM element handle
☉ sigil DomElement {
    /// Platform-specific element reference
    handle: usize!
}

⊢ DomElement {
    ☉ rite new(handle: usize) → This! {
        DomElement { handle }
    }
}

/// Fetch options
☉ sigil FetchOptions {
    ☉ method: String! = "GET"
    ☉ headers: HashMap<String, String>! = HashMap::new()
    ☉ body: Option<String>? = None
    ☉ mode: FetchMode! = FetchMode::Cors
    ☉ credentials: FetchCredentials! = FetchCredentials::SameOrigin
    ☉ cache: FetchCache! = FetchCache::Default
    ☉ redirect: FetchRedirect! = FetchRedirect::Follow
}

⊢ FetchOptions {
    /// Create default fetch options (GET, no body)
    ☉ rite default() → This! {
        FetchOptions {
            method: "GET".to_string(),
            headers: HashMap::new(),
            body: None,
            mode: FetchMode::Cors,
            credentials: FetchCredentials::SameOrigin,
            cache: FetchCache::Default,
            redirect: FetchRedirect::Follow
        }
    }

    /// Alias for default() - create a new FetchOptions builder
    ☉ rite new() → This! {
        FetchOptions::default()
    }

    /// Create GET request options
    ☉ rite get() → This! {
        FetchOptions::default()
    }

    /// Create POST request with body
    ☉ rite post(body: &str) → This! {
        FetchOptions {
            method: "POST".to_string(),
            body: Some(body.to_string()),
            ..FetchOptions::default()
        }
    }

    /// Create PUT request with body
    ☉ rite put(body: &str) → This! {
        FetchOptions {
            method: "PUT".to_string(),
            body: Some(body.to_string()),
            ..FetchOptions::default()
        }
    }

    /// Create PATCH request with body
    ☉ rite patch(body: &str) → This! {
        FetchOptions {
            method: "PATCH".to_string(),
            body: Some(body.to_string()),
            ..FetchOptions::default()
        }
    }

    /// Create DELETE request
    ☉ rite delete() → This! {
        FetchOptions {
            method: "DELETE".to_string(),
            ..FetchOptions::default()
        }
    }

    /// Create HEAD request
    ☉ rite head() → This! {
        FetchOptions {
            method: "HEAD".to_string(),
            ..FetchOptions::default()
        }
    }

    /// Create POST request with JSON body
    ☉ rite json(body: impl serde::Serialize) → This! {
        ≔ vary opts! = FetchOptions {
            method: "POST".to_string(),
            body: Some(serde_json::to_string(&body)
                ·expect("FetchOptions::json: body must be JSON serializable")),
            ..FetchOptions::default()
        }
        opts.headers·insert("Content-Type".to_string(), "application/json".to_string())
        opts
    }

    /// Set the HTTP method (builder pattern)
    ☉ rite method(vary this, method: &str) → This! {
        this.method = method.to_string();
        this
    }

    /// Set the request body (builder pattern)
    ☉ rite body(vary this, body: &str) → This! {
        this.body = Some(body.to_string());
        this
    }

    /// Add a header (builder pattern)
    ☉ rite header(vary this, key: &str, value: &str) → This! {
        this.headers.insert(key.to_string(), value.to_string());
        this
    }

    /// Set fetch mode (builder pattern)
    ☉ rite mode(vary this, mode: FetchMode) → This! {
        this.mode = mode;
        this
    }

    /// Set credentials mode (builder pattern)
    ☉ rite credentials(vary this, credentials: FetchCredentials) → This! {
        this.credentials = credentials;
        this
    }

    /// Set cache mode (builder pattern)
    ☉ rite cache(vary this, cache: FetchCache) → This! {
        this.cache = cache;
        this
    }

    /// Set redirect mode (builder pattern)
    ☉ rite redirect(vary this, redirect: FetchRedirect) → This! {
        this.redirect = redirect;
        this
    }
}

☉ enum FetchMode {
    Cors,
    NoCors,
    SameOrigin
}

☉ enum FetchCredentials {
    Omit,
    SameOrigin,
    Include
}

☉ enum FetchCache {
    Default,
    NoStore,
    Reload,
    NoCache,
    ForceCache,
    OnlyIfCached
}

☉ enum FetchRedirect {
    Follow,
    Error,
    Manual
}

/// Fetch response
☉ sigil FetchResponse {
    ☉ ok: bool!
    ☉ status: u16!
    ☉ status_text: String!
    ☉ headers: HashMap<String, String>!
    body: Vec<u8>!
}

⊢ FetchResponse {
    /// Create a successful (200 OK) response with the given body
    ☉ rite ok(body: &[u8]) → This! {
        FetchResponse {
            ok: ⊤,
            status: 200,
            status_text: "OK".to_string(),
            headers: HashMap::new(),
            body: body.to_vec(),
        }
    }

    /// Create an error response with the given status
    ☉ rite error(status: u16, status_text: &str) → This! {
        FetchResponse {
            ok: ⊥,
            status: status,
            status_text: status_text.to_string(),
            headers: HashMap::new(),
            body: Vec::new(),
        }
    }

    /// Create a network error response (status 0)
    ☉ rite network_error(message: &str) → This! {
        FetchResponse {
            ok: ⊥,
            status: 0,
            status_text: message.to_string(),
            headers: HashMap::new(),
            body: Vec::new(),
        }
    }

    /// Create a timeout response (status 408)
    ☉ rite timeout() → This! {
        FetchResponse {
            ok: ⊥,
            status: 408,
            status_text: "Request Timeout".to_string(),
            headers: HashMap::new(),
            body: Vec::new(),
        }
    }

    /// Get response as text
    ☉ rite text(&this) → String! {
        String::from_utf8(this.body·clone())·unwrap_or_default()
    }

    /// Get response as JSON
    ☉ rite json<T: serde::Deserialize>(&this) → Result<T, String>! {
        serde_json::from_slice(&this.body)
            ·map_err(|e| e·to_string())
    }

    /// Get response as bytes
    ☉ rite bytes(&this) → Vec<u8>! {
        this.body·clone()
    }
}

/// Storage abstraction
/// Storage provides a key-value store interface that works across platforms.
/// For browser, it maps to localStorage/sessionStorage.
/// For native platforms, it uses platform-specific persistence.
/// For testing, MockPlatform provides an in-memory implementation.
☉ sigil Storage {
    storage_type: StorageType!,
    /// Shared reference to the underlying data store
    data: Rc<RefCell<HashMap<String, String>>>!,
}

☉ enum StorageType {
    Local,
    Session
}

⊢ Storage {
    /// Create a new Storage instance with the given type and data store
    ☉ rite new(storage_type: StorageType, data: Rc<RefCell<HashMap<String, String>>>) → This! {
        Storage { storage_type, data }
    }

    /// Get a value by key
    ☉ rite get(&this, key: &str) → Option<String>? {
        this.data.borrow().get(key).cloned()
    }

    /// Set a key-value pair
    ☉ rite set(&this, key: &str, value: &str) {
        this.data.borrow_mut().insert(key.to_string(), value.to_string());
    }

    /// Remove a key
    ☉ rite remove(&this, key: &str) {
        this.data.borrow_mut().remove(key);
    }

    /// Clear all keys
    ☉ rite clear(&this) {
        this.data.borrow_mut().clear();
    }

    /// Get the number of keys
    ☉ rite length(&this) → usize! {
        this.data.borrow().len()
    }

    /// Get the key at a given index (order is not guaranteed)
    ☉ rite key(&this, index: usize) → Option<String>? {
        this.data.borrow().keys().nth(index).cloned()
    }
}

// ============================================================================
// Browser Platform
// ============================================================================

/// Browser platform implementation
☉ sigil BrowserPlatform {
    event_delegator: EventDelegator!,
    /// In-memory storage (TODO: Use JS FFI for real persistence)
    local_storage_data: Rc<RefCell<HashMap<String, String>>>!,
    session_storage_data: Rc<RefCell<HashMap<String, String>>>!,
}

⊢ BrowserPlatform {
    ☉ rite new() → This! {
        BrowserPlatform {
            event_delegator: EventDelegator::new(),
            local_storage_data: Rc::new(RefCell::new(HashMap::new())),
            session_storage_data: Rc::new(RefCell::new(HashMap::new())),
        }
    }
}

⊢ BrowserPlatform : Platform {
    rite query_selector(&this, selector: &str) → Option<DomElement>? {
        // js: document.querySelector(selector)
        extern "js" {
            rite js_query_selector(selector: &str) → Option<usize>?;
        }
        unsafe { js_query_selector(selector)·map(DomElement::new) }
    }

    rite create_element(&this, tag: &str) → DomElement! {
        extern "js" {
            rite js_create_element(tag: &str) → usize!;
        }
        unsafe { DomElement::new(js_create_element(tag)) }
    }

    rite create_text(&this, content: &str) → DomElement! {
        extern "js" {
            rite js_create_text_node(content: &str) → usize!;
        }
        unsafe { DomElement::new(js_create_text_node(content)) }
    }

    rite apply_patch(&this, patch: Patch) {
        // Apply patch to real DOM
        match patch {
            Patch::Create(node) => {
                // Create DOM element from VNode
            }
            Patch::Remove(id) => {
                // Remove element by ID
            }
            Patch::Replace(id, node) => {
                // Replace element
            }
            Patch::UpdateAttrs(id, attrs) => {
                // Update attributes
            }
            Patch::UpdateProps(id, props) => {
                // Update properties
            }
            Patch::UpdateEvents(id, events) => {
                // Update event handlers
            }
            Patch::UpdateText(id, text) => {
                // Update text content
            }
            Patch::ReorderChildren(id, order) => {
                // Reorder children
            }
            Patch::AppendChild(parent_id, node) => {
                // Append child
            }
            Patch::InsertBefore(parent_id, node, before_id) => {
                // Insert before
            }
            Patch::RemoveChild(parent_id, child_id) => {
                // Remove child
            }
        }
    }

    rite add_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64) {
        extern "js" {
            rite js_add_event_listener(element: usize, event_name: &str, handler_id: u64);
        }
        unsafe { js_add_event_listener(element.handle, event·dom_name(), handler_id) }
    }

    rite remove_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64) {
        extern "js" {
            rite js_remove_event_listener(element: usize, event_name: &str, handler_id: u64);
        }
        unsafe { js_remove_event_listener(element.handle, event·dom_name(), handler_id) }
    }

    rite window_size(&this) → (i32, i32)! {
        extern "js" {
            rite js_window_inner_width() → i32!;
            rite js_window_inner_height() → i32!;
        }
        unsafe { (js_window_inner_width(), js_window_inner_height()) }
    }

    rite request_animation_frame(&this, callback: fn(f64)) → u64! {
        extern "js" {
            rite js_request_animation_frame(callback_id: u64) → u64!;
        }
        // Register callback and get ID
        unsafe { js_request_animation_frame(0) }
    }

    rite cancel_animation_frame(&this, id: u64) {
        extern "js" {
            rite js_cancel_animation_frame(id: u64);
        }
        unsafe { js_cancel_animation_frame(id) }
    }

    rite set_timeout(&this, callback: fn(), delay_ms: u64) → u64! {
        extern "js" {
            rite js_set_timeout(callback_id: u64, delay: u64) → u64!;
        }
        unsafe { js_set_timeout(0, delay_ms) }
    }

    rite clear_timeout(&this, id: u64) {
        extern "js" {
            rite js_clear_timeout(id: u64);
        }
        unsafe { js_clear_timeout(id) }
    }

    rite set_interval(&this, callback: fn(), interval_ms: u64) → u64! {
        extern "js" {
            rite js_set_interval(callback_id: u64, interval: u64) → u64!;
        }
        unsafe { js_set_interval(0, interval_ms) }
    }

    rite clear_interval(&this, id: u64) {
        extern "js" {
            rite js_clear_interval(id: u64);
        }
        unsafe { js_clear_interval(id) }
    }

    rite fetch(&this, url: &str, options: FetchOptions) → PlatformFuture<FetchResponse>! {
        // NOTE: Browser platform uses sync FFI call that internally handles async JS
        // For true async, use browser's native fetch with Promises
        extern "js" {
            rite js_fetch_sync(url: &str, method: &str, headers: &str, body: Option<&str>) → (bool, u16, String, String, Vec<u8>);
        }

        ≔ headers_json! = serde_json::to_string(&options.headers)
            ·expect("fetch: headers must be JSON serializable");
        ≔ result! = unsafe {
            js_fetch_sync(url, &options.method, &headers_json, options.body·as_deref())
        };

        PlatformFuture::ready(FetchResponse {
            ok: result.0,
            status: result.1,
            status_text: result.2,
            headers: serde_json::from_str(&result.3)·unwrap_or_default(),
            body: result.4
        })
    }

    rite local_storage(&this) → Storage! {
        Storage::new(StorageType::Local, Rc::clone(&this.local_storage_data))
    }

    rite session_storage(&this) → Storage! {
        Storage::new(StorageType::Session, Rc::clone(&this.session_storage_data))
    }

    rite current_url(&this) → String! {
        extern "js" {
            rite js_get_location_href() → String!;
        }
        unsafe { js_get_location_href() }
    }

    rite push_history(&this, url: &str, state: Option<HashMap<String, String>>) {
        extern "js" {
            rite js_push_state(state: Option<&str>, url: &str);
        }
        ≔ state_json? = state·map(|s| serde_json::to_string(&s)
            ·expect("push_history: state must be JSON serializable"))
        unsafe { js_push_state(state_json·as_deref(), url) }
    }

    rite replace_history(&this, url: &str, state: Option<HashMap<String, String>>) {
        extern "js" {
            rite js_replace_state(state: Option<&str>, url: &str);
        }
        ≔ state_json? = state·map(|s| serde_json::to_string(&s)
            ·expect("replace_history: state must be JSON serializable"))
        unsafe { js_replace_state(state_json·as_deref(), url) }
    }

    rite render_to_string(&this, vnode: &VNode) → PlatformResult<String>! {
        // Browser doesn't support SSR rendering
        Err(PlatformError::NotSupported {
            feature: "render_to_string".to_string(),
            platform: "browser".to_string()
        })
    }
}

// ============================================================================
// Server Platform (for SSR)
// ============================================================================

/// Server-side rendering platform
☉ sigil ServerPlatform {
    /// In-memory storage for SSR context
    local_storage_data: Rc<RefCell<HashMap<String, String>>>!,
    session_storage_data: Rc<RefCell<HashMap<String, String>>>!,
}

⊢ ServerPlatform {
    ☉ rite new() → This! {
        ServerPlatform {
            local_storage_data: Rc::new(RefCell::new(HashMap::new())),
            session_storage_data: Rc::new(RefCell::new(HashMap::new())),
        }
    }
}

⊢ ServerPlatform : Platform {
    rite query_selector(&this, _selector: &str) → Option<DomElement>? {
        None // No DOM on server
    }

    rite create_element(&this, _tag: &str) → DomElement! {
        DomElement::new(0)
    }

    rite create_text(&this, _content: &str) → DomElement! {
        DomElement::new(0)
    }

    rite apply_patch(&this, _patch: Patch) {
        // No-op on server
    }

    rite add_event_listener(&this, _element: &DomElement, _event: EventType, _handler_id: u64) {
        // No-op on server
    }

    rite remove_event_listener(&this, _element: &DomElement, _event: EventType, _handler_id: u64) {
        // No-op on server
    }

    rite window_size(&this) → (i32, i32)! {
        (0, 0) // No window on server
    }

    rite request_animation_frame(&this, _callback: fn(f64)) → u64! {
        0 // No RAF on server
    }

    rite cancel_animation_frame(&this, _id: u64) {}

    rite set_timeout(&this, _callback: fn(), _delay_ms: u64) → u64! {
        0
    }

    rite clear_timeout(&this, _id: u64) {}

    rite set_interval(&this, _callback: fn(), _interval_ms: u64) → u64! {
        0
    }

    rite clear_interval(&this, _id: u64) {}

    rite fetch(&this, url: &str, options: FetchOptions) → PlatformFuture<FetchResponse>! {
        // Server-side fetch implementation - returns 501 Not Implemented
        // TODO: Implement using native HTTP client (reqwest, hyper, etc.)
        PlatformFuture::ready(FetchResponse {
            ok: ⊥,
            status: 501,
            status_text: "Not Implemented".to_string(),
            headers: HashMap::new(),
            body: Vec::new()
        })
    }

    rite local_storage(&this) → Storage! {
        Storage::new(StorageType::Local, Rc::clone(&this.local_storage_data))
    }

    rite session_storage(&this) → Storage! {
        Storage::new(StorageType::Session, Rc::clone(&this.session_storage_data))
    }

    rite current_url(&this) → String! {
        "/".to_string()
    }

    rite push_history(&this, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op on server
    }

    rite replace_history(&this, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op on server
    }

    rite render_to_string(&this, vnode: &VNode) → PlatformResult<String>! {
        Ok(render_vnode_to_string(vnode))
    }
}

/// Render VNode to HTML string
rite render_vnode_to_string(vnode: &VNode) → String! {
    match vnode {
        VNode::Element(el) => {
            ≔ vary html! = format!("<{}", el.tag)

            // Add attributes
            for (name, value) in &el.attrs {
                html·push_str(&format!(" {}=\"{}\"", name, escape_attr(&value·to_string())))
            }

            // This-closing tags
            ≔ self_closing! = matches!(
                el.tag·as_str(),
                "area" | "base" | "br" | "col" | "embed" | "hr" | "img" |
                "input" | "link" | "meta" | "param" | "source" | "track" | "wbr"
            )

            ⎇ self_closing && el.children·is_empty() {
                html·push_str(" />")
            } ⎉ {
                html·push('>')

                // Render children
                for child in &el.children {
                    html·push_str(&render_vnode_to_string(child))
                }

                html·push_str(&format!("</{}>", el.tag))
            }

            html
        }

        VNode::Text(text) => {
            escape_html(&text.content)
        }

        VNode::Fragment(frag) => {
            frag.children·iter()
                ·map(render_vnode_to_string)
                ·collect::<Vec<_>>()
                ·join("")
        }

        VNode::Component(comp) => {
            // Render component
            ≔ rendered! = (comp.render)(comp.props·clone())
            render_vnode_to_string(&rendered)
        }

        VNode::Portal(portal) => {
            // Portals render children inline for SSR
            portal.children·iter()
                ·map(render_vnode_to_string)
                ·collect::<Vec<_>>()
                ·join("")
        }

        VNode::Empty => {
            "".to_string()
        }
    }
}

/// Escape HTML special characters
rite escape_html(s: &str) → String! {
    s·replace('&', "&amp;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

/// Escape attribute value
rite escape_attr(s: &str) → String! {
    s·replace('&', "&amp;")
     ·replace('"', "&quot;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

// ============================================================================
// Platform Detection
// ============================================================================

/// Detect current platform
☉ rite detect() → Box<dyn Platform>! {
    detect_with_options(PlatformOptions::default())
}

/// Detect platform with options
☉ rite detect_with_options(options: PlatformOptions) → Box<dyn Platform>! {
    match options.target {
        RenderTarget::Browser => {
            #[cfg(target_arch = "wasm32")]
            {
                Box::new(BrowserPlatform::new())
            }
            #[cfg(not(target_arch = "wasm32"))]
            {
                // Fallback to server for non-WASM browser target
                Box::new(ServerPlatform::new())
            }
        }
        RenderTarget::Server | RenderTarget::Static => {
            Box::new(ServerPlatform::new())
        }
        RenderTarget::Native => {
            detect_native_platform()
        }
    }
}

/// Detect native platform based on OS
/// Returns an error on unsupported platforms instead of panicking
☉ rite detect_native_platform() → PlatformResult<Box<dyn Platform>>! {
    #[cfg(target_os = "linux")]
    {
        Ok(Box::new(Gtk4Platform::new()))
    }

    #[cfg(target_os = "windows")]
    {
        Ok(Box::new(Win32Platform::new()))
    }

    #[cfg(target_os = "macos")]
    {
        Ok(Box::new(CocoaPlatform::new()))
    }

    #[cfg(not(any(target_os = "linux", target_os = "windows", target_os = "macos")))]
    {
        Err(PlatformError::NotSupported {
            feature: "native_platform".to_string(),
            platform: std::env::consts::OS.to_string()
        })
    }
}

/// Auto-detect best platform for current environment
☉ rite auto_detect() → Box<dyn Platform>! {
    #[cfg(target_arch = "wasm32")]
    {
        // Running in browser
        Box::new(BrowserPlatform::new())
    }

    #[cfg(all(not(target_arch = "wasm32"), any(target_os = "linux", target_os = "windows", target_os = "macos")))]
    {
        // Running on desktop - use native
        detect_native_platform()
    }

    #[cfg(all(not(target_arch = "wasm32"), not(any(target_os = "linux", target_os = "windows", target_os = "macos"))))]
    {
        // Other platforms - use server (headless)
        Box::new(ServerPlatform::new())
    }
}

/// Platform configuration options
☉ sigil PlatformOptions {
    /// Target rendering environment
    ☉ target: RenderTarget! = RenderTarget::Browser
    /// Enable hydration for SSR
    ☉ hydrate: bool! = nay
    /// Base URL for routing
    ☉ base_url: String! = "/"
}

⊢ PlatformOptions {
    ☉ rite default() → This! {
        PlatformOptions {
            target: RenderTarget::Browser,
            hydrate: nay,
            base_url: "/".to_string()
        }
    }
}

/// Render target environments
☉ enum RenderTarget {
    Browser,
    Server,
    Static,
    Native
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::vdom::{VElement, VText};

    #[test]
    rite test_render_to_string_simple() {
        ≔ vnode! = VNode::Element(VElement {
            tag: "div".to_string(),
            attrs: HashMap::new(),
            props: HashMap::new(),
            events: HashMap::new(),
            children: vec![VNode::Text(VText { content: "Hello".to_string(), id: None })],
            key: None,
            ref_callback: None,
            namespace: None,
            id: None
        })

        ≔ html! = render_vnode_to_string(&vnode)
        assert_eq!(html, "<div>Hello</div>")
    }

    #[test]
    rite test_render_self_closing() {
        ≔ vnode! = VNode::Element(VElement {
            tag: "br".to_string(),
            attrs: HashMap::new(),
            props: HashMap::new(),
            events: HashMap::new(),
            children: vec![],
            key: None,
            ref_callback: None,
            namespace: None,
            id: None
        })

        ≔ html! = render_vnode_to_string(&vnode)
        assert_eq!(html, "<br />")
    }

    #[test]
    rite test_escape_html() {
        assert_eq!(escape_html("<script>alert('xss')</script>"), "&lt;script&gt;alert('xss')&lt;/script&gt;")
    }
}
