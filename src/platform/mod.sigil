// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Platform Module
// Cross-platform bindings for browser, SSR, and native environments

use std::collections::HashMap;
use crate::core::vdom::{VNode, Patch};
use crate::core::events::{Event, EventDelegator, EventType};

// Native platform backends (GTK4, Win32, Cocoa)
☉ mod native;
☉ use native::{NativeWidget, WidgetType, NativeApp, NativeWidgetBuilder, NativeLayout, VNodeToNative};

#[cfg(target_os = "linux")]
☉ use native::Gtk4Platform;

#[cfg(target_os = "windows")]
☉ use native::Win32Platform;

#[cfg(target_os = "macos")]
☉ use native::CocoaPlatform;

/// Platform abstraction
☉ aspect Platform {
    /// Query DOM element by selector
    rite query_selector(&this, selector: &str) → Option<DomElement>?;

    /// Create DOM element
    rite create_element(&this, tag: &str) → DomElement!;

    /// Create text node
    rite create_text(&this, content: &str) → DomElement!;

    /// Apply patch to DOM
    rite apply_patch(&this, patch: Patch);

    /// Add event listener
    rite add_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64);

    /// Remove event listener
    rite remove_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64);

    /// Get window dimensions
    rite window_size(&this) → (i32, i32)!;

    /// Request animation frame
    rite request_animation_frame(&this, callback: fn(f64)) → u64!;

    /// Cancel animation frame
    rite cancel_animation_frame(&this, id: u64);

    /// Set timeout
    rite set_timeout(&this, callback: fn(), delay_ms: u64) → u64!;

    /// Clear timeout
    rite clear_timeout(&this, id: u64);

    /// Set interval
    rite set_interval(&this, callback: fn(), interval_ms: u64) → u64!;

    /// Clear interval
    rite clear_interval(&this, id: u64);

    /// Fetch URL
    rite fetch(&this, url: &str, options: FetchOptions) → Future<Output = FetchResponse>!;

    /// Get local storage
    rite local_storage(&this) → Storage!;

    /// Get session storage
    rite session_storage(&this) → Storage!;

    /// Get current URL
    rite current_url(&this) → String!;

    /// Push history state
    rite push_history(&this, url: &str, state: Option<HashMap<String, String>>);

    /// Replace history state
    rite replace_history(&this, url: &str, state: Option<HashMap<String, String>>);

    /// Render to string (for SSR)
    rite render_to_string(&this, vnode: &VNode) → String!;
}

/// DOM element handle
☉ sigil DomElement {
    /// Platform-specific element reference
    handle: usize!
}

⊢ DomElement {
    ☉ rite new(handle: usize) → This! {
        DomElement { handle }
    }
}

/// Fetch options
☉ sigil FetchOptions {
    ☉ method: String! = "GET"
    ☉ headers: HashMap<String, String>! = HashMap::new()
    ☉ body: Option<String>? = None
    ☉ mode: FetchMode! = FetchMode::Cors
    ☉ credentials: FetchCredentials! = FetchCredentials::SameOrigin
    ☉ cache: FetchCache! = FetchCache::Default
    ☉ redirect: FetchRedirect! = FetchRedirect::Follow
}

⊢ FetchOptions {
    ☉ rite default() → This! {
        FetchOptions {
            method: "GET".to_string(),
            headers: HashMap::new(),
            body: None,
            mode: FetchMode::Cors,
            credentials: FetchCredentials::SameOrigin,
            cache: FetchCache::Default,
            redirect: FetchRedirect::Follow
        }
    }

    ☉ rite get(url: &str) → This! {
        FetchOptions::default()
    }

    ☉ rite post(body: &str) → This! {
        FetchOptions {
            method: "POST".to_string(),
            body: Some(body.to_string()),
            ..FetchOptions::default()
        }
    }

    ☉ rite json(body: impl serde::Serialize) → This! {
        ≔ vary opts! = FetchOptions {
            method: "POST".to_string(),
            body: Some(serde_json::to_string(&body)·unwrap()),
            ..FetchOptions::default()
        }
        opts.headers·insert("Content-Type".to_string(), "application/json".to_string())
        opts
    }
}

☉ enum FetchMode {
    Cors,
    NoCors,
    SameOrigin
}

☉ enum FetchCredentials {
    Omit,
    SameOrigin,
    Include
}

☉ enum FetchCache {
    Default,
    NoStore,
    Reload,
    NoCache,
    ForceCache,
    OnlyIfCached
}

☉ enum FetchRedirect {
    Follow,
    Error,
    Manual
}

/// Fetch response
☉ sigil FetchResponse {
    ☉ ok: bool!
    ☉ status: u16!
    ☉ status_text: String!
    ☉ headers: HashMap<String, String>!
    body: Vec<u8>!
}

⊢ FetchResponse {
    /// Get response as text
    ☉ rite text(&this) → String! {
        String::from_utf8(this.body·clone())·unwrap_or_default()
    }

    /// Get response as JSON
    ☉ rite json<T: serde::Deserialize>(&this) → Result<T, String>! {
        serde_json::from_slice(&this.body)
            ·map_err(|e| e·to_string())
    }

    /// Get response as bytes
    ☉ rite bytes(&this) → Vec<u8>! {
        this.body·clone()
    }
}

/// Storage abstraction
☉ sigil Storage {
    storage_type: StorageType!
}

☉ enum StorageType {
    Local,
    Session
}

⊢ Storage {
    ☉ rite get(&this, key: &str) → Option<String>? {
        // Platform-specific implementation
        None
    }

    ☉ rite set(&this, key: &str, value: &str) {
        // Platform-specific implementation
    }

    ☉ rite remove(&this, key: &str) {
        // Platform-specific implementation
    }

    ☉ rite clear(&this) {
        // Platform-specific implementation
    }

    ☉ rite length(&this) → usize! {
        // Platform-specific implementation
        0
    }

    ☉ rite key(&this, index: usize) → Option<String>? {
        // Platform-specific implementation
        None
    }
}

// ============================================================================
// Browser Platform
// ============================================================================

/// Browser platform implementation
☉ sigil BrowserPlatform {
    event_delegator: EventDelegator!
}

⊢ BrowserPlatform {
    ☉ rite new() → This! {
        BrowserPlatform {
            event_delegator: EventDelegator::new()
        }
    }
}

⊢ BrowserPlatform : Platform {
    rite query_selector(&this, selector: &str) → Option<DomElement>? {
        // js: document.querySelector(selector)
        extern "js" {
            rite js_query_selector(selector: &str) → Option<usize>?;
        }
        unsafe { js_query_selector(selector)·map(DomElement::new) }
    }

    rite create_element(&this, tag: &str) → DomElement! {
        extern "js" {
            rite js_create_element(tag: &str) → usize!;
        }
        unsafe { DomElement::new(js_create_element(tag)) }
    }

    rite create_text(&this, content: &str) → DomElement! {
        extern "js" {
            rite js_create_text_node(content: &str) → usize!;
        }
        unsafe { DomElement::new(js_create_text_node(content)) }
    }

    rite apply_patch(&this, patch: Patch) {
        // Apply patch to real DOM
        match patch {
            Patch::Create(node) => {
                // Create DOM element from VNode
            }
            Patch::Remove(id) => {
                // Remove element by ID
            }
            Patch::Replace(id, node) => {
                // Replace element
            }
            Patch::UpdateAttrs(id, attrs) => {
                // Update attributes
            }
            Patch::UpdateProps(id, props) => {
                // Update properties
            }
            Patch::UpdateEvents(id, events) => {
                // Update event handlers
            }
            Patch::UpdateText(id, text) => {
                // Update text content
            }
            Patch::ReorderChildren(id, order) => {
                // Reorder children
            }
            Patch::AppendChild(parent_id, node) => {
                // Append child
            }
            Patch::InsertBefore(parent_id, node, before_id) => {
                // Insert before
            }
            Patch::RemoveChild(parent_id, child_id) => {
                // Remove child
            }
        }
    }

    rite add_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64) {
        extern "js" {
            rite js_add_event_listener(element: usize, event_name: &str, handler_id: u64);
        }
        unsafe { js_add_event_listener(element.handle, event·dom_name(), handler_id) }
    }

    rite remove_event_listener(&this, element: &DomElement, event: EventType, handler_id: u64) {
        extern "js" {
            rite js_remove_event_listener(element: usize, event_name: &str, handler_id: u64);
        }
        unsafe { js_remove_event_listener(element.handle, event·dom_name(), handler_id) }
    }

    rite window_size(&this) → (i32, i32)! {
        extern "js" {
            rite js_window_inner_width() → i32!;
            rite js_window_inner_height() → i32!;
        }
        unsafe { (js_window_inner_width(), js_window_inner_height()) }
    }

    rite request_animation_frame(&this, callback: fn(f64)) → u64! {
        extern "js" {
            rite js_request_animation_frame(callback_id: u64) → u64!;
        }
        // Register callback and get ID
        unsafe { js_request_animation_frame(0) }
    }

    rite cancel_animation_frame(&this, id: u64) {
        extern "js" {
            rite js_cancel_animation_frame(id: u64);
        }
        unsafe { js_cancel_animation_frame(id) }
    }

    rite set_timeout(&this, callback: fn(), delay_ms: u64) → u64! {
        extern "js" {
            rite js_set_timeout(callback_id: u64, delay: u64) → u64!;
        }
        unsafe { js_set_timeout(0, delay_ms) }
    }

    rite clear_timeout(&this, id: u64) {
        extern "js" {
            rite js_clear_timeout(id: u64);
        }
        unsafe { js_clear_timeout(id) }
    }

    rite set_interval(&this, callback: fn(), interval_ms: u64) → u64! {
        extern "js" {
            rite js_set_interval(callback_id: u64, interval: u64) → u64!;
        }
        unsafe { js_set_interval(0, interval_ms) }
    }

    rite clear_interval(&this, id: u64) {
        extern "js" {
            rite js_clear_interval(id: u64);
        }
        unsafe { js_clear_interval(id) }
    }

    rite fetch(&this, url: &str, options: FetchOptions) → Future<Output = FetchResponse>! {
        async {
            extern "js" {
                async rite js_fetch(url: &str, method: &str, headers: &str, body: Option<&str>) → (bool, u16, String, String, Vec<u8>);
            }

            ≔ headers_json! = serde_json::to_string(&options.headers)·unwrap()
            ≔ result! = unsafe {
                js_fetch(url, &options.method, &headers_json, options.body·as_deref())·await
            }

            FetchResponse {
                ok: result.0,
                status: result.1,
                status_text: result.2,
                headers: serde_json::from_str(&result.3)·unwrap_or_default(),
                body: result.4
            }
        }
    }

    rite local_storage(&this) → Storage! {
        Storage { storage_type: StorageType::Local }
    }

    rite session_storage(&this) → Storage! {
        Storage { storage_type: StorageType::Session }
    }

    rite current_url(&this) → String! {
        extern "js" {
            rite js_get_location_href() → String!;
        }
        unsafe { js_get_location_href() }
    }

    rite push_history(&this, url: &str, state: Option<HashMap<String, String>>) {
        extern "js" {
            rite js_push_state(state: Option<&str>, url: &str);
        }
        ≔ state_json? = state·map(|s| serde_json::to_string(&s)·unwrap())
        unsafe { js_push_state(state_json·as_deref(), url) }
    }

    rite replace_history(&this, url: &str, state: Option<HashMap<String, String>>) {
        extern "js" {
            rite js_replace_state(state: Option<&str>, url: &str);
        }
        ≔ state_json? = state·map(|s| serde_json::to_string(&s)·unwrap())
        unsafe { js_replace_state(state_json·as_deref(), url) }
    }

    rite render_to_string(&this, vnode: &VNode) → String! {
        // Browser doesn't support SSR rendering
        panic!("render_to_string not supported in browser")
    }
}

// ============================================================================
// Server Platform (for SSR)
// ============================================================================

/// Server-side rendering platform
☉ sigil ServerPlatform {}

⊢ ServerPlatform {
    ☉ rite new() → This! {
        ServerPlatform {}
    }
}

⊢ ServerPlatform : Platform {
    rite query_selector(&this, _selector: &str) → Option<DomElement>? {
        None // No DOM on server
    }

    rite create_element(&this, _tag: &str) → DomElement! {
        DomElement::new(0)
    }

    rite create_text(&this, _content: &str) → DomElement! {
        DomElement::new(0)
    }

    rite apply_patch(&this, _patch: Patch) {
        // No-op on server
    }

    rite add_event_listener(&this, _element: &DomElement, _event: EventType, _handler_id: u64) {
        // No-op on server
    }

    rite remove_event_listener(&this, _element: &DomElement, _event: EventType, _handler_id: u64) {
        // No-op on server
    }

    rite window_size(&this) → (i32, i32)! {
        (0, 0) // No window on server
    }

    rite request_animation_frame(&this, _callback: fn(f64)) → u64! {
        0 // No RAF on server
    }

    rite cancel_animation_frame(&this, _id: u64) {}

    rite set_timeout(&this, _callback: fn(), _delay_ms: u64) → u64! {
        0
    }

    rite clear_timeout(&this, _id: u64) {}

    rite set_interval(&this, _callback: fn(), _interval_ms: u64) → u64! {
        0
    }

    rite clear_interval(&this, _id: u64) {}

    rite fetch(&this, url: &str, options: FetchOptions) → Future<Output = FetchResponse>! {
        // Use native HTTP client
        async {
            // Server-side fetch implementation
            FetchResponse {
                ok: nay,
                status: 0,
                status_text: "Not implemented".to_string(),
                headers: HashMap::new(),
                body: Vec::new()
            }
        }
    }

    rite local_storage(&this) → Storage! {
        Storage { storage_type: StorageType::Local }
    }

    rite session_storage(&this) → Storage! {
        Storage { storage_type: StorageType::Session }
    }

    rite current_url(&this) → String! {
        "/".to_string()
    }

    rite push_history(&this, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op on server
    }

    rite replace_history(&this, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op on server
    }

    rite render_to_string(&this, vnode: &VNode) → String! {
        render_vnode_to_string(vnode)
    }
}

/// Render VNode to HTML string
rite render_vnode_to_string(vnode: &VNode) → String! {
    match vnode {
        VNode::Element(el) => {
            ≔ vary html! = format!("<{}", el.tag)

            // Add attributes
            for (name, value) in &el.attrs {
                html·push_str(&format!(" {}=\"{}\"", name, escape_attr(&value·to_string())))
            }

            // This-closing tags
            ≔ self_closing! = matches!(
                el.tag·as_str(),
                "area" | "base" | "br" | "col" | "embed" | "hr" | "img" |
                "input" | "link" | "meta" | "param" | "source" | "track" | "wbr"
            )

            ⎇ self_closing && el.children·is_empty() {
                html·push_str(" />")
            } ⎉ {
                html·push('>')

                // Render children
                for child in &el.children {
                    html·push_str(&render_vnode_to_string(child))
                }

                html·push_str(&format!("</{}>", el.tag))
            }

            html
        }

        VNode::Text(text) => {
            escape_html(&text.content)
        }

        VNode::Fragment(frag) => {
            frag.children·iter()
                ·map(render_vnode_to_string)
                ·collect::<Vec<_>>()
                ·join("")
        }

        VNode::Component(comp) => {
            // Render component
            ≔ rendered! = (comp.render)(comp.props·clone())
            render_vnode_to_string(&rendered)
        }

        VNode::Portal(portal) => {
            // Portals render children inline for SSR
            portal.children·iter()
                ·map(render_vnode_to_string)
                ·collect::<Vec<_>>()
                ·join("")
        }

        VNode::Empty => {
            "".to_string()
        }
    }
}

/// Escape HTML special characters
rite escape_html(s: &str) → String! {
    s·replace('&', "&amp;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

/// Escape attribute value
rite escape_attr(s: &str) → String! {
    s·replace('&', "&amp;")
     ·replace('"', "&quot;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

// ============================================================================
// Platform Detection
// ============================================================================

/// Detect current platform
☉ rite detect() → Box<dyn Platform>! {
    detect_with_options(PlatformOptions::default())
}

/// Detect platform with options
☉ rite detect_with_options(options: PlatformOptions) → Box<dyn Platform>! {
    match options.target {
        RenderTarget::Browser => {
            #[cfg(target_arch = "wasm32")]
            {
                Box::new(BrowserPlatform::new())
            }
            #[cfg(not(target_arch = "wasm32"))]
            {
                // Fallback to server for non-WASM browser target
                Box::new(ServerPlatform::new())
            }
        }
        RenderTarget::Server | RenderTarget::Static => {
            Box::new(ServerPlatform::new())
        }
        RenderTarget::Native => {
            detect_native_platform()
        }
    }
}

/// Detect native platform based on OS
☉ rite detect_native_platform() → Box<dyn Platform>! {
    #[cfg(target_os = "linux")]
    {
        Box::new(Gtk4Platform::new())
    }

    #[cfg(target_os = "windows")]
    {
        Box::new(Win32Platform::new())
    }

    #[cfg(target_os = "macos")]
    {
        Box::new(CocoaPlatform::new())
    }

    #[cfg(not(any(target_os = "linux", target_os = "windows", target_os = "macos")))]
    {
        panic!("Unsupported native platform. Use Browser or Server target instead.")
    }
}

/// Auto-detect best platform for current environment
☉ rite auto_detect() → Box<dyn Platform>! {
    #[cfg(target_arch = "wasm32")]
    {
        // Running in browser
        Box::new(BrowserPlatform::new())
    }

    #[cfg(all(not(target_arch = "wasm32"), any(target_os = "linux", target_os = "windows", target_os = "macos")))]
    {
        // Running on desktop - use native
        detect_native_platform()
    }

    #[cfg(all(not(target_arch = "wasm32"), not(any(target_os = "linux", target_os = "windows", target_os = "macos"))))]
    {
        // Other platforms - use server (headless)
        Box::new(ServerPlatform::new())
    }
}

/// Platform configuration options
☉ sigil PlatformOptions {
    /// Target rendering environment
    ☉ target: RenderTarget! = RenderTarget::Browser
    /// Enable hydration for SSR
    ☉ hydrate: bool! = nay
    /// Base URL for routing
    ☉ base_url: String! = "/"
}

⊢ PlatformOptions {
    ☉ rite default() → This! {
        PlatformOptions {
            target: RenderTarget::Browser,
            hydrate: nay,
            base_url: "/".to_string()
        }
    }
}

/// Render target environments
☉ enum RenderTarget {
    Browser,
    Server,
    Static,
    Native
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::vdom::{VElement, VText};

    #[test]
    rite test_render_to_string_simple() {
        ≔ vnode! = VNode::Element(VElement {
            tag: "div".to_string(),
            attrs: HashMap::new(),
            props: HashMap::new(),
            events: HashMap::new(),
            children: vec![VNode::Text(VText { content: "Hello".to_string(), id: None })],
            key: None,
            ref_callback: None,
            namespace: None,
            id: None
        })

        ≔ html! = render_vnode_to_string(&vnode)
        assert_eq!(html, "<div>Hello</div>")
    }

    #[test]
    rite test_render_self_closing() {
        ≔ vnode! = VNode::Element(VElement {
            tag: "br".to_string(),
            attrs: HashMap::new(),
            props: HashMap::new(),
            events: HashMap::new(),
            children: vec![],
            key: None,
            ref_callback: None,
            namespace: None,
            id: None
        })

        ≔ html! = render_vnode_to_string(&vnode)
        assert_eq!(html, "<br />")
    }

    #[test]
    rite test_escape_html() {
        assert_eq!(escape_html("<script>alert('xss')</script>"), "&lt;script&gt;alert('xss')&lt;/script&gt;")
    }
}
