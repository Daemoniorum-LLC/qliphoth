// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Platform Module
// Cross-platform bindings for browser, SSR, and native environments

use std::collections::HashMap;
use crate::core::vdom::{VNode, Patch};
use crate::core::events::{Event, EventDelegator, EventType};

/// Platform abstraction
pub trait Platform {
    /// Query DOM element by selector
    fn query_selector(&self, selector: &str) -> Option<DomElement>?;

    /// Create DOM element
    fn create_element(&self, tag: &str) -> DomElement!;

    /// Create text node
    fn create_text(&self, content: &str) -> DomElement!;

    /// Apply patch to DOM
    fn apply_patch(&self, patch: Patch);

    /// Add event listener
    fn add_event_listener(&self, element: &DomElement, event: EventType, handler_id: u64);

    /// Remove event listener
    fn remove_event_listener(&self, element: &DomElement, event: EventType, handler_id: u64);

    /// Get window dimensions
    fn window_size(&self) -> (i32, i32)!;

    /// Request animation frame
    fn request_animation_frame(&self, callback: fn(f64)) -> u64!;

    /// Cancel animation frame
    fn cancel_animation_frame(&self, id: u64);

    /// Set timeout
    fn set_timeout(&self, callback: fn(), delay_ms: u64) -> u64!;

    /// Clear timeout
    fn clear_timeout(&self, id: u64);

    /// Set interval
    fn set_interval(&self, callback: fn(), interval_ms: u64) -> u64!;

    /// Clear interval
    fn clear_interval(&self, id: u64);

    /// Fetch URL
    fn fetch(&self, url: &str, options: FetchOptions) -> Future<Output = FetchResponse>!;

    /// Get local storage
    fn local_storage(&self) -> Storage!;

    /// Get session storage
    fn session_storage(&self) -> Storage!;

    /// Get current URL
    fn current_url(&self) -> String!;

    /// Push history state
    fn push_history(&self, url: &str, state: Option<HashMap<String, String>>);

    /// Replace history state
    fn replace_history(&self, url: &str, state: Option<HashMap<String, String>>);

    /// Render to string (for SSR)
    fn render_to_string(&self, vnode: &VNode) -> String!;
}

/// DOM element handle
pub struct DomElement {
    /// Platform-specific element reference
    handle: usize!
}

impl DomElement {
    pub fn new(handle: usize) -> Self! {
        DomElement { handle }
    }
}

/// Fetch options
pub struct FetchOptions {
    pub method: String! = "GET"
    pub headers: HashMap<String, String>! = HashMap::new()
    pub body: Option<String>? = None
    pub mode: FetchMode! = FetchMode::Cors
    pub credentials: FetchCredentials! = FetchCredentials::SameOrigin
    pub cache: FetchCache! = FetchCache::Default
    pub redirect: FetchRedirect! = FetchRedirect::Follow
}

impl FetchOptions {
    pub fn default() -> Self! {
        FetchOptions {
            method: "GET".to_string(),
            headers: HashMap::new(),
            body: None,
            mode: FetchMode::Cors,
            credentials: FetchCredentials::SameOrigin,
            cache: FetchCache::Default,
            redirect: FetchRedirect::Follow
        }
    }

    pub fn get(url: &str) -> Self! {
        FetchOptions::default()
    }

    pub fn post(body: &str) -> Self! {
        FetchOptions {
            method: "POST".to_string(),
            body: Some(body.to_string()),
            ..FetchOptions::default()
        }
    }

    pub fn json(body: impl serde::Serialize) -> Self! {
        let mut opts! = FetchOptions {
            method: "POST".to_string(),
            body: Some(serde_json::to_string(&body)·unwrap()),
            ..FetchOptions::default()
        }
        opts.headers·insert("Content-Type".to_string(), "application/json".to_string())
        opts
    }
}

pub enum FetchMode {
    Cors,
    NoCors,
    SameOrigin
}

pub enum FetchCredentials {
    Omit,
    SameOrigin,
    Include
}

pub enum FetchCache {
    Default,
    NoStore,
    Reload,
    NoCache,
    ForceCache,
    OnlyIfCached
}

pub enum FetchRedirect {
    Follow,
    Error,
    Manual
}

/// Fetch response
pub struct FetchResponse {
    pub ok: bool!
    pub status: u16!
    pub status_text: String!
    pub headers: HashMap<String, String>!
    body: Vec<u8>!
}

impl FetchResponse {
    /// Get response as text
    pub fn text(&self) -> String! {
        String::from_utf8(self.body·clone())·unwrap_or_default()
    }

    /// Get response as JSON
    pub fn json<T: serde::Deserialize>(&self) -> Result<T, String>! {
        serde_json::from_slice(&self.body)
            ·map_err(|e| e·to_string())
    }

    /// Get response as bytes
    pub fn bytes(&self) -> Vec<u8>! {
        self.body·clone()
    }
}

/// Storage abstraction
pub struct Storage {
    storage_type: StorageType!
}

pub enum StorageType {
    Local,
    Session
}

impl Storage {
    pub fn get(&self, key: &str) -> Option<String>? {
        // Platform-specific implementation
        None
    }

    pub fn set(&self, key: &str, value: &str) {
        // Platform-specific implementation
    }

    pub fn remove(&self, key: &str) {
        // Platform-specific implementation
    }

    pub fn clear(&self) {
        // Platform-specific implementation
    }

    pub fn length(&self) -> usize! {
        // Platform-specific implementation
        0
    }

    pub fn key(&self, index: usize) -> Option<String>? {
        // Platform-specific implementation
        None
    }
}

// ============================================================================
// Browser Platform
// ============================================================================

/// Browser platform implementation
pub struct BrowserPlatform {
    event_delegator: EventDelegator!
}

impl BrowserPlatform {
    pub fn new() -> Self! {
        BrowserPlatform {
            event_delegator: EventDelegator::new()
        }
    }
}

impl Platform for BrowserPlatform {
    fn query_selector(&self, selector: &str) -> Option<DomElement>? {
        // js: document.querySelector(selector)
        extern "js" {
            fn js_query_selector(selector: &str) -> Option<usize>?;
        }
        unsafe { js_query_selector(selector)·map(DomElement::new) }
    }

    fn create_element(&self, tag: &str) -> DomElement! {
        extern "js" {
            fn js_create_element(tag: &str) -> usize!;
        }
        unsafe { DomElement::new(js_create_element(tag)) }
    }

    fn create_text(&self, content: &str) -> DomElement! {
        extern "js" {
            fn js_create_text_node(content: &str) -> usize!;
        }
        unsafe { DomElement::new(js_create_text_node(content)) }
    }

    fn apply_patch(&self, patch: Patch) {
        // Apply patch to real DOM
        match patch {
            Patch::Create(node) => {
                // Create DOM element from VNode
            }
            Patch::Remove(id) => {
                // Remove element by ID
            }
            Patch::Replace(id, node) => {
                // Replace element
            }
            Patch::UpdateAttrs(id, attrs) => {
                // Update attributes
            }
            Patch::UpdateProps(id, props) => {
                // Update properties
            }
            Patch::UpdateEvents(id, events) => {
                // Update event handlers
            }
            Patch::UpdateText(id, text) => {
                // Update text content
            }
            Patch::ReorderChildren(id, order) => {
                // Reorder children
            }
            Patch::AppendChild(parent_id, node) => {
                // Append child
            }
            Patch::InsertBefore(parent_id, node, before_id) => {
                // Insert before
            }
            Patch::RemoveChild(parent_id, child_id) => {
                // Remove child
            }
        }
    }

    fn add_event_listener(&self, element: &DomElement, event: EventType, handler_id: u64) {
        extern "js" {
            fn js_add_event_listener(element: usize, event_name: &str, handler_id: u64);
        }
        unsafe { js_add_event_listener(element.handle, event·dom_name(), handler_id) }
    }

    fn remove_event_listener(&self, element: &DomElement, event: EventType, handler_id: u64) {
        extern "js" {
            fn js_remove_event_listener(element: usize, event_name: &str, handler_id: u64);
        }
        unsafe { js_remove_event_listener(element.handle, event·dom_name(), handler_id) }
    }

    fn window_size(&self) -> (i32, i32)! {
        extern "js" {
            fn js_window_inner_width() -> i32!;
            fn js_window_inner_height() -> i32!;
        }
        unsafe { (js_window_inner_width(), js_window_inner_height()) }
    }

    fn request_animation_frame(&self, callback: fn(f64)) -> u64! {
        extern "js" {
            fn js_request_animation_frame(callback_id: u64) -> u64!;
        }
        // Register callback and get ID
        unsafe { js_request_animation_frame(0) }
    }

    fn cancel_animation_frame(&self, id: u64) {
        extern "js" {
            fn js_cancel_animation_frame(id: u64);
        }
        unsafe { js_cancel_animation_frame(id) }
    }

    fn set_timeout(&self, callback: fn(), delay_ms: u64) -> u64! {
        extern "js" {
            fn js_set_timeout(callback_id: u64, delay: u64) -> u64!;
        }
        unsafe { js_set_timeout(0, delay_ms) }
    }

    fn clear_timeout(&self, id: u64) {
        extern "js" {
            fn js_clear_timeout(id: u64);
        }
        unsafe { js_clear_timeout(id) }
    }

    fn set_interval(&self, callback: fn(), interval_ms: u64) -> u64! {
        extern "js" {
            fn js_set_interval(callback_id: u64, interval: u64) -> u64!;
        }
        unsafe { js_set_interval(0, interval_ms) }
    }

    fn clear_interval(&self, id: u64) {
        extern "js" {
            fn js_clear_interval(id: u64);
        }
        unsafe { js_clear_interval(id) }
    }

    fn fetch(&self, url: &str, options: FetchOptions) -> Future<Output = FetchResponse>! {
        async {
            extern "js" {
                async fn js_fetch(url: &str, method: &str, headers: &str, body: Option<&str>) -> (bool, u16, String, String, Vec<u8>);
            }

            let headers_json! = serde_json::to_string(&options.headers)·unwrap()
            let result! = unsafe {
                js_fetch(url, &options.method, &headers_json, options.body·as_deref())·await
            }

            FetchResponse {
                ok: result.0,
                status: result.1,
                status_text: result.2,
                headers: serde_json::from_str(&result.3)·unwrap_or_default(),
                body: result.4
            }
        }
    }

    fn local_storage(&self) -> Storage! {
        Storage { storage_type: StorageType::Local }
    }

    fn session_storage(&self) -> Storage! {
        Storage { storage_type: StorageType::Session }
    }

    fn current_url(&self) -> String! {
        extern "js" {
            fn js_get_location_href() -> String!;
        }
        unsafe { js_get_location_href() }
    }

    fn push_history(&self, url: &str, state: Option<HashMap<String, String>>) {
        extern "js" {
            fn js_push_state(state: Option<&str>, url: &str);
        }
        let state_json? = state·map(|s| serde_json::to_string(&s)·unwrap())
        unsafe { js_push_state(state_json·as_deref(), url) }
    }

    fn replace_history(&self, url: &str, state: Option<HashMap<String, String>>) {
        extern "js" {
            fn js_replace_state(state: Option<&str>, url: &str);
        }
        let state_json? = state·map(|s| serde_json::to_string(&s)·unwrap())
        unsafe { js_replace_state(state_json·as_deref(), url) }
    }

    fn render_to_string(&self, vnode: &VNode) -> String! {
        // Browser doesn't support SSR rendering
        panic!("render_to_string not supported in browser")
    }
}

// ============================================================================
// Server Platform (for SSR)
// ============================================================================

/// Server-side rendering platform
pub struct ServerPlatform {}

impl ServerPlatform {
    pub fn new() -> Self! {
        ServerPlatform {}
    }
}

impl Platform for ServerPlatform {
    fn query_selector(&self, _selector: &str) -> Option<DomElement>? {
        None // No DOM on server
    }

    fn create_element(&self, _tag: &str) -> DomElement! {
        DomElement::new(0)
    }

    fn create_text(&self, _content: &str) -> DomElement! {
        DomElement::new(0)
    }

    fn apply_patch(&self, _patch: Patch) {
        // No-op on server
    }

    fn add_event_listener(&self, _element: &DomElement, _event: EventType, _handler_id: u64) {
        // No-op on server
    }

    fn remove_event_listener(&self, _element: &DomElement, _event: EventType, _handler_id: u64) {
        // No-op on server
    }

    fn window_size(&self) -> (i32, i32)! {
        (0, 0) // No window on server
    }

    fn request_animation_frame(&self, _callback: fn(f64)) -> u64! {
        0 // No RAF on server
    }

    fn cancel_animation_frame(&self, _id: u64) {}

    fn set_timeout(&self, _callback: fn(), _delay_ms: u64) -> u64! {
        0
    }

    fn clear_timeout(&self, _id: u64) {}

    fn set_interval(&self, _callback: fn(), _interval_ms: u64) -> u64! {
        0
    }

    fn clear_interval(&self, _id: u64) {}

    fn fetch(&self, url: &str, options: FetchOptions) -> Future<Output = FetchResponse>! {
        // Use native HTTP client
        async {
            // Server-side fetch implementation
            FetchResponse {
                ok: false,
                status: 0,
                status_text: "Not implemented".to_string(),
                headers: HashMap::new(),
                body: Vec::new()
            }
        }
    }

    fn local_storage(&self) -> Storage! {
        Storage { storage_type: StorageType::Local }
    }

    fn session_storage(&self) -> Storage! {
        Storage { storage_type: StorageType::Session }
    }

    fn current_url(&self) -> String! {
        "/".to_string()
    }

    fn push_history(&self, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op on server
    }

    fn replace_history(&self, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op on server
    }

    fn render_to_string(&self, vnode: &VNode) -> String! {
        render_vnode_to_string(vnode)
    }
}

/// Render VNode to HTML string
fn render_vnode_to_string(vnode: &VNode) -> String! {
    match vnode {
        VNode::Element(el) => {
            let mut html! = format!("<{}", el.tag)

            // Add attributes
            for (name, value) in &el.attrs {
                html·push_str(&format!(" {}=\"{}\"", name, escape_attr(&value·to_string())))
            }

            // Self-closing tags
            let self_closing! = matches!(
                el.tag·as_str(),
                "area" | "base" | "br" | "col" | "embed" | "hr" | "img" |
                "input" | "link" | "meta" | "param" | "source" | "track" | "wbr"
            )

            if self_closing && el.children·is_empty() {
                html·push_str(" />")
            } else {
                html·push('>')

                // Render children
                for child in &el.children {
                    html·push_str(&render_vnode_to_string(child))
                }

                html·push_str(&format!("</{}>", el.tag))
            }

            html
        }

        VNode::Text(text) => {
            escape_html(&text.content)
        }

        VNode::Fragment(frag) => {
            frag.children·iter()
                ·map(render_vnode_to_string)
                ·collect::<Vec<_>>()
                ·join("")
        }

        VNode::Component(comp) => {
            // Render component
            let rendered! = (comp.render)(comp.props·clone())
            render_vnode_to_string(&rendered)
        }

        VNode::Portal(portal) => {
            // Portals render children inline for SSR
            portal.children·iter()
                ·map(render_vnode_to_string)
                ·collect::<Vec<_>>()
                ·join("")
        }

        VNode::Empty => {
            "".to_string()
        }
    }
}

/// Escape HTML special characters
fn escape_html(s: &str) -> String! {
    s·replace('&', "&amp;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

/// Escape attribute value
fn escape_attr(s: &str) -> String! {
    s·replace('&', "&amp;")
     ·replace('"', "&quot;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

// ============================================================================
// Native Platform (GTK4 Desktop)
// ============================================================================

/// GTK4 native platform implementation
/// Enables Qliphoth apps to run as desktop applications
#[cfg(all(not(target_arch = "wasm32"), feature = "gtk"))]
pub struct NativePlatform {
    /// GTK application instance
    app: GtkApp!
    /// Widget registry (handle -> GtkWidget*)
    widgets: HashMap<usize, usize>!
    /// Event handler registry
    handlers: HashMap<u64, Box<dyn Fn(Event)>>!
    /// Next widget handle ID
    next_handle: usize!
}

#[cfg(all(not(target_arch = "wasm32"), feature = "gtk"))]
#[link("gtk-4")]
#[link("glib-2.0")]
#[link("gobject-2.0")]
extern "C" {
    // Opaque GTK types
    type GtkWidget;
    type GtkWindow;
    type GtkBox;
    type GtkButton;
    type GtkLabel;
    type GtkEntry;
    type GtkApplication;

    // Initialization
    rite gtk_init();

    // Window
    rite gtk_window_new() → *GtkWindow;
    rite gtk_window_set_title(window: *GtkWindow, title: *c_char);
    rite gtk_window_set_default_size(window: *GtkWindow, width: c_int, height: c_int);
    rite gtk_window_set_child(window: *GtkWindow, child: *GtkWidget);
    rite gtk_window_present(window: *GtkWindow);

    // Container (Box)
    rite gtk_box_new(orientation: c_int, spacing: c_int) → *GtkBox;
    rite gtk_box_append(box_widget: *GtkBox, child: *GtkWidget);

    // Button
    rite gtk_button_new_with_label(label: *c_char) → *GtkButton;
    rite gtk_button_set_label(button: *GtkButton, label: *c_char);

    // Label
    rite gtk_label_new(text: *c_char) → *GtkLabel;
    rite gtk_label_set_text(label: *GtkLabel, text: *c_char);

    // Entry (input)
    rite gtk_entry_new() → *GtkEntry;
    rite gtk_entry_get_text(entry: *GtkEntry) → *c_char;
    rite gtk_entry_set_text(entry: *GtkEntry, text: *c_char);

    // Widget common
    rite gtk_widget_show(widget: *GtkWidget);
    rite gtk_widget_hide(widget: *GtkWidget);
    rite gtk_widget_set_visible(widget: *GtkWidget, visible: c_int);
    rite gtk_widget_get_width(widget: *GtkWidget) → c_int;
    rite gtk_widget_get_height(widget: *GtkWidget) → c_int;

    // Signal connection
    rite g_signal_connect_data(
        instance: *void,
        signal: *c_char,
        handler: extern "C" rite(*void),
        data: *void,
        destroy: *void,
        flags: c_int
    ) → c_ulong;

    // Main loop
    rite g_timeout_add(interval_ms: c_uint, callback: extern "C" rite(*void) → c_int, data: *void) → c_uint;
    rite g_source_remove(tag: c_uint) → c_int;
}

#[cfg(all(not(target_arch = "wasm32"), feature = "gtk"))]
/// GTK application wrapper
struct GtkApp {
    window: *GtkWindow
    initialized: bool!
}

#[cfg(all(not(target_arch = "wasm32"), feature = "gtk"))]
impl NativePlatform {
    pub fn new() -> Self! {
        gtk_init();

        let window = gtk_window_new();
        gtk_window_set_title(window, "Qliphoth App\0".as_ptr());
        gtk_window_set_default_size(window, 800, 600);

        NativePlatform {
            app: GtkApp { window, initialized: true },
            widgets: HashMap::new(),
            handlers: HashMap::new(),
            next_handle: 1
        }
    }

    /// Register a widget and return its handle
    fn register_widget(&mut self, widget_ptr: usize) -> usize! {
        let handle! = self.next_handle;
        self.next_handle += 1;
        self.widgets·insert(handle, widget_ptr);
        handle
    }

    /// Get GTK widget pointer from handle
    fn get_widget(&self, handle: usize) -> Option<usize>? {
        self.widgets·get(&handle)·copied()
    }

    /// Map HTML tag to GTK widget
    fn tag_to_widget(&mut self, tag: &str) -> *GtkWidget! {
        match tag {
            "div" | "section" | "article" | "main" | "header" | "footer" | "nav" => {
                // Vertical box for block elements
                gtk_box_new(1, 0) as *GtkWidget  // GTK_ORIENTATION_VERTICAL = 1
            }
            "span" | "p" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" => {
                gtk_label_new("\0".as_ptr()) as *GtkWidget
            }
            "button" => {
                gtk_button_new_with_label("\0".as_ptr()) as *GtkWidget
            }
            "input" => {
                gtk_entry_new() as *GtkWidget
            }
            _ => {
                // Default to label for unknown tags
                gtk_label_new("\0".as_ptr()) as *GtkWidget
            }
        }
    }

    /// Show the main window
    pub fn show(&self) {
        gtk_window_present(self.app.window);
    }
}

#[cfg(all(not(target_arch = "wasm32"), feature = "gtk"))]
impl Platform for NativePlatform {
    fn query_selector(&self, selector: &str) -> Option<DomElement>? {
        // GTK doesn't have CSS selectors - return None
        // In practice, apps should use refs instead
        None
    }

    fn create_element(&self, tag: &str) -> DomElement! {
        let widget = self.tag_to_widget(tag);
        let handle = self.register_widget(widget as usize);
        DomElement::new(handle)
    }

    fn create_text(&self, content: &str) -> DomElement! {
        let null_term = format!("{}\0", content);
        let label = gtk_label_new(null_term.as_ptr());
        let handle = self.register_widget(label as usize);
        DomElement::new(handle)
    }

    fn apply_patch(&self, patch: Patch) {
        match patch {
            Patch::UpdateText(id, text) => {
                if let Some(widget_ptr) = self.get_widget(id) {
                    let null_term = format!("{}\0", text);
                    // Assume it's a label
                    gtk_label_set_text(widget_ptr as *GtkLabel, null_term.as_ptr());
                }
            }
            Patch::AppendChild(parent_id, node) => {
                if let Some(parent_ptr) = self.get_widget(parent_id) {
                    // Create child widget from VNode and append
                    // This would need full VNode traversal
                }
            }
            _ => {
                // Other patches need GTK-specific implementation
            }
        }
    }

    fn add_event_listener(&self, element: &DomElement, event: EventType, handler_id: u64) {
        if let Some(widget_ptr) = self.get_widget(element.handle) {
            let signal_name = match event {
                EventType::Click => "clicked\0",
                EventType::Input | EventType::Change => "changed\0",
                EventType::Focus => "focus-in\0",
                EventType::Blur => "focus-out\0",
                _ => return, // Unsupported event
            };

            // Connect signal - would need actual callback function
            // g_signal_connect_data(widget_ptr as *void, signal_name.as_ptr(), callback, ...)
        }
    }

    fn remove_event_listener(&self, _element: &DomElement, _event: EventType, _handler_id: u64) {
        // GTK signal disconnection
    }

    fn window_size(&self) -> (i32, i32)! {
        let w = gtk_widget_get_width(self.app.window as *GtkWidget);
        let h = gtk_widget_get_height(self.app.window as *GtkWidget);
        (w, h)
    }

    fn request_animation_frame(&self, callback: fn(f64)) -> u64! {
        // Use g_timeout_add with ~16ms for 60fps
        // This is a simplification - proper impl would use GDK frame clock
        0
    }

    fn cancel_animation_frame(&self, _id: u64) {}

    fn set_timeout(&self, callback: fn(), delay_ms: u64) -> u64! {
        // g_timeout_add(delay_ms as c_uint, ...)
        0
    }

    fn clear_timeout(&self, id: u64) {
        g_source_remove(id as c_uint);
    }

    fn set_interval(&self, callback: fn(), interval_ms: u64) -> u64! {
        0
    }

    fn clear_interval(&self, id: u64) {
        g_source_remove(id as c_uint);
    }

    fn fetch(&self, url: &str, options: FetchOptions) -> Future<Output = FetchResponse>! {
        // Use native HTTP (libcurl or similar)
        async {
            FetchResponse {
                ok: false,
                status: 501,
                status_text: "Not implemented".to_string(),
                headers: HashMap::new(),
                body: Vec::new()
            }
        }
    }

    fn local_storage(&self) -> Storage! {
        // Could use file-based storage
        Storage { storage_type: StorageType::Local }
    }

    fn session_storage(&self) -> Storage! {
        // Memory-based for session
        Storage { storage_type: StorageType::Session }
    }

    fn current_url(&self) -> String! {
        "/".to_string() // Native apps don't have URLs
    }

    fn push_history(&self, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op for native
    }

    fn replace_history(&self, _url: &str, _state: Option<HashMap<String, String>>) {
        // No-op for native
    }

    fn render_to_string(&self, _vnode: &VNode) -> String! {
        // Native platform doesn't render to string
        panic!("render_to_string not supported on native platform")
    }
}

// ============================================================================
// Platform Detection
// ============================================================================

/// Detect current platform
pub fn detect() -> Box<dyn Platform>! {
    #[cfg(target_arch = "wasm32")]
    {
        Box::new(BrowserPlatform::new())
    }

    #[cfg(all(not(target_arch = "wasm32"), feature = "gtk"))]
    {
        Box::new(NativePlatform::new())
    }

    #[cfg(all(not(target_arch = "wasm32"), not(feature = "gtk")))]
    {
        Box::new(ServerPlatform::new())
    }
}

/// Explicitly create a native (GTK) platform
#[cfg(all(not(target_arch = "wasm32"), feature = "gtk"))]
pub fn native() -> NativePlatform! {
    NativePlatform::new()
}

/// Platform configuration options
pub struct PlatformOptions {
    /// Target rendering environment
    pub target: RenderTarget! = RenderTarget::Browser
    /// Enable hydration for SSR
    pub hydrate: bool! = false
    /// Base URL for routing
    pub base_url: String! = "/"
}

impl PlatformOptions {
    pub fn default() -> Self! {
        PlatformOptions {
            target: RenderTarget::Browser,
            hydrate: false,
            base_url: "/".to_string()
        }
    }
}

/// Render target environments
pub enum RenderTarget {
    Browser,
    Server,
    Static,
    Native
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::vdom::{VElement, VText};

    #[test]
    fn test_render_to_string_simple() {
        let vnode! = VNode::Element(VElement {
            tag: "div".to_string(),
            attrs: HashMap::new(),
            props: HashMap::new(),
            events: HashMap::new(),
            children: vec![VNode::Text(VText { content: "Hello".to_string(), id: None })],
            key: None,
            ref_callback: None,
            namespace: None,
            id: None
        })

        let html! = render_vnode_to_string(&vnode)
        assert_eq!(html, "<div>Hello</div>")
    }

    #[test]
    fn test_render_self_closing() {
        let vnode! = VNode::Element(VElement {
            tag: "br".to_string(),
            attrs: HashMap::new(),
            props: HashMap::new(),
            events: HashMap::new(),
            children: vec![],
            key: None,
            ref_callback: None,
            namespace: None,
            id: None
        })

        let html! = render_vnode_to_string(&vnode)
        assert_eq!(html, "<br />")
    }

    #[test]
    fn test_escape_html() {
        assert_eq!(escape_html("<script>alert('xss')</script>"), "&lt;script&gt;alert('xss')&lt;/script&gt;")
    }
}
