// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Platform Module - Agent-Centric Design
// Cross-platform bindings using message-based patterns instead of callbacks

invoke std·collections·HashMap;
invoke crate·core·vdom·{VNode, Patch};
invoke crate·core·events·{Event, EventType};
invoke crate·platform·native·NativePlatform;

// =============================================================================
// Core Types
// =============================================================================

/// DOM element handle
☉ Σ DomElement {
    /// Platform-specific element reference
    handle: usize!
}

⊢ DomElement {
    ☉ rite new(handle: usize) -> Self! {
        DomElement { handle }
    }
}

/// Render target environments
☉ ᛈ RenderTarget {
    Browser,
    Server,
    Static,
    Native
}

/// Platform configuration options
☉ Σ PlatformOptions {
    /// Target rendering environment
    ☉ target: RenderTarget! = RenderTarget·Browser
    /// Enable hydration for SSR
    ☉ hydrate: bool! = false
    /// Base URL for routing
    ☉ base_url: String! = "/"
}

⊢ PlatformOptions {
    ☉ rite default() -> Self! {
        PlatformOptions {
            target: RenderTarget·Browser,
            hydrate: false,
            base_url: "/".to_string()
        }
    }
}

// =============================================================================
// Fetch Types
// =============================================================================

☉ ᛈ FetchMode {
    Cors,
    NoCors,
    SameOrigin
}

☉ ᛈ FetchCredentials {
    Omit,
    SameOrigin,
    Include
}

☉ ᛈ FetchCache {
    Default,
    NoStore,
    Reload,
    NoCache,
    ForceCache,
    OnlyIfCached
}

☉ ᛈ FetchRedirect {
    Follow,
    Error,
    Manual
}

/// Fetch options
☉ Σ FetchOptions {
    ☉ method: String! = "GET"
    ☉ headers: HashMap<String, String>!
    ☉ body: Option<String>?
    ☉ mode: FetchMode! = FetchMode·Cors
    ☉ credentials: FetchCredentials! = FetchCredentials·SameOrigin
    ☉ cache: FetchCache! = FetchCache·Default
    ☉ redirect: FetchRedirect! = FetchRedirect·Follow
}

⊢ FetchOptions {
    ☉ rite default() -> Self! {
        FetchOptions {
            method: "GET".to_string(),
            headers: HashMap·new(),
            body: None,
            mode: FetchMode·Cors,
            credentials: FetchCredentials·SameOrigin,
            cache: FetchCache·Default,
            redirect: FetchRedirect·Follow
        }
    }

    ☉ rite get() -> Self! {
        FetchOptions·default()
    }

    ☉ rite post(body: &str) -> Self! {
        FetchOptions {
            method: "POST".to_string(),
            body: Some(body.to_string()),
            ..FetchOptions·default()
        }
    }
}

/// Fetch response
☉ Σ FetchResponse {
    ☉ ok: bool!
    ☉ status: u16!
    ☉ status_text: String!
    ☉ headers: HashMap<String, String>!
    body: Vec<u8>!
}

⊢ FetchResponse {
    /// Get response as text
    ☉ rite text(&self) -> String! {
        String·from_utf8(self.body·clone())·unwrap_or_default()
    }

    /// Get response as bytes
    ☉ rite bytes(&self) -> Vec<u8>! {
        self.body·clone()
    }
}

/// Storage abstraction
☉ Σ Storage {
    storage_type: StorageType!
}

☉ ᛈ StorageType {
    Local,
    Session
}

⊢ Storage {
    ☉ rite get(&self, key: &str) -> Option<String>? {
        // Platform-specific implementation
        None
    }

    ☉ rite set(&self, key: &str, value: &str) {
        // Platform-specific implementation
    }

    ☉ rite remove(&self, key: &str) {
        // Platform-specific implementation
    }

    ☉ rite clear(&self) {
        // Platform-specific implementation
    }
}

// =============================================================================
// Platform Enum (not trait - avoids dyn)
// =============================================================================

/// Platform implementation
☉ ᛈ Platform {
    Browser(BrowserPlatform),
    Server(ServerPlatform),
    Native(NativePlatform),
}

⊢ Platform {
    /// Create browser platform
    ☉ rite browser() -> Self! {
        Platform·Browser(BrowserPlatform·new())
    }

    /// Create server platform
    ☉ rite server() -> Self! {
        Platform·Server(ServerPlatform·new())
    }

    /// Create native platform
    ☉ rite native(title: &str, width: i32, height: i32) -> Self! {
        Platform·Native(NativePlatform·new(title, width, height))
    }

    /// Create native platform with defaults
    ☉ rite native_default() -> Self! {
        Platform·Native(NativePlatform·default())
    }

    /// Query DOM element by selector
    ☉ rite query_selector(&self, selector: &str) -> Option<DomElement>? {
        ⌥ self {
            Platform·Browser(p) => p·query_selector(selector),
            Platform·Server(_) => None,
            Platform·Native(p) => p·query_selector(selector),
        }
    }

    /// Create DOM element
    ☉ rite create_element(&self, tag: &str) -> DomElement! {
        ⌥ self {
            Platform·Browser(p) => p·create_element(tag),
            Platform·Server(p) => p·create_element(tag),
            Platform·Native(p) => p·create_element(tag),
        }
    }

    /// Create text node
    ☉ rite create_text(&self, content: &str) -> DomElement! {
        ⌥ self {
            Platform·Browser(p) => p·create_text(content),
            Platform·Server(p) => p·create_text(content),
            Platform·Native(p) => p·create_text(content),
        }
    }

    /// Apply patch to DOM
    ☉ rite apply_patch(&self, patch: Patch) {
        ⌥ self {
            Platform·Browser(p) => p·apply_patch(patch),
            Platform·Server(_) => {},
            Platform·Native(p) => p·apply_patch(patch),
        }
    }

    /// Add event listener (using message ID, not callback)
    ☉ rite add_event_listener(&self, element: &DomElement, event: EventType, message_id: u64) {
        ⌥ self {
            Platform·Browser(p) => p·add_event_listener(element, event, message_id),
            Platform·Server(_) => {},
            Platform·Native(p) => p·add_event_listener(element, event, message_id),
        }
    }

    /// Remove event listener
    ☉ rite remove_event_listener(&self, element: &DomElement, event: EventType, message_id: u64) {
        ⌥ self {
            Platform·Browser(p) => p·remove_event_listener(element, event, message_id),
            Platform·Server(_) => {},
            Platform·Native(p) => p·remove_event_listener(element, event, message_id),
        }
    }

    /// Get window dimensions
    ☉ rite window_size(&self) -> (i32, i32)! {
        ⌥ self {
            Platform·Browser(p) => p·window_size(),
            Platform·Server(_) => (0, 0),
            Platform·Native(p) => p·window_size(),
        }
    }

    /// Request animation frame (returns frame ID, dispatches message when fired)
    ☉ rite request_animation_frame(&self, message_id: u64) -> u64! {
        ⌥ self {
            Platform·Browser(p) => p·request_animation_frame(message_id),
            Platform·Server(_) => 0,
            Platform·Native(p) => p·request_animation_frame(message_id),
        }
    }

    /// Cancel animation frame
    ☉ rite cancel_animation_frame(&self, id: u64) {
        ⌥ self {
            Platform·Browser(p) => p·cancel_animation_frame(id),
            Platform·Server(_) => {},
            Platform·Native(p) => p·cancel_animation_frame(id),
        }
    }

    /// Set timeout (dispatches message when fired)
    ☉ rite set_timeout(&self, message_id: u64, delay_ms: u64) -> u64! {
        ⌥ self {
            Platform·Browser(p) => p·set_timeout(message_id, delay_ms),
            Platform·Server(_) => 0,
            Platform·Native(p) => p·set_timeout(message_id, delay_ms),
        }
    }

    /// Clear timeout
    ☉ rite clear_timeout(&self, id: u64) {
        ⌥ self {
            Platform·Browser(p) => p·clear_timeout(id),
            Platform·Server(_) => {},
            Platform·Native(p) => p·clear_timeout(id),
        }
    }

    /// Set interval (dispatches message on each tick)
    ☉ rite set_interval(&self, message_id: u64, interval_ms: u64) -> u64! {
        ⌥ self {
            Platform·Browser(p) => p·set_interval(message_id, interval_ms),
            Platform·Server(_) => 0,
            Platform·Native(p) => p·set_interval(message_id, interval_ms),
        }
    }

    /// Clear interval
    ☉ rite clear_interval(&self, id: u64) {
        ⌥ self {
            Platform·Browser(p) => p·clear_interval(id),
            Platform·Native(p) => p·clear_interval(id),
            Platform·Server(_) => {},
        }
    }

    /// Fetch URL (blocking - for async, use actor message pattern)
    ☉ rite fetch_sync(&self, url: &str, options: FetchOptions) -> FetchResponse! {
        ⌥ self {
            Platform·Browser(p) => p·fetch_sync(url, options),
            Platform·Server(p) => p·fetch_sync(url, options),
        }
    }

    /// Get local storage
    ☉ rite local_storage(&self) -> Storage! {
        Storage { storage_type: StorageType·Local }
    }

    /// Get session storage
    ☉ rite session_storage(&self) -> Storage! {
        Storage { storage_type: StorageType·Session }
    }

    /// Get current URL
    ☉ rite current_url(&self) -> String! {
        ⌥ self {
            Platform·Browser(p) => p·current_url(),
            Platform·Server(_) => "/".to_string(),
        }
    }

    /// Push history state
    ☉ rite push_history(&self, url: &str) {
        ⌥ self {
            Platform·Browser(p) => p·push_history(url),
            Platform·Server(_) => {},
        }
    }

    /// Replace history state
    ☉ rite replace_history(&self, url: &str) {
        ⌥ self {
            Platform·Browser(p) => p·replace_history(url),
            Platform·Server(_) => {},
        }
    }

    /// Render to string (for SSR)
    ☉ rite render_to_string(&self, vnode: &VNode) -> String! {
        ⌥ self {
            Platform·Browser(_) => "<!-- SSR not supported in browser -->".to_string(),
            Platform·Server(p) => p·render_to_string(vnode),
        }
    }
}

// =============================================================================
// Browser Platform
// =============================================================================

/// Browser platform implementation
/// Note: FFI to JavaScript is handled by the runtime, not compiled into WASM.
/// These are stub implementations for compilation - the runtime provides real bindings.
☉ Σ BrowserPlatform {
    next_handle: usize!
}

⊢ BrowserPlatform {
    ☉ rite new() -> Self! {
        BrowserPlatform { next_handle: 1 }
    }

    rite query_selector(&self, _selector: &str) -> Option<DomElement>? {
        // Stub - runtime provides real implementation
        None
    }

    rite create_element(&Δ self, _tag: &str) -> DomElement! {
        // Stub - runtime provides real implementation
        ≔ handle! = self.next_handle;
        self.next_handle = self.next_handle + 1;
        DomElement·new(handle)
    }

    rite create_text(&Δ self, _content: &str) -> DomElement! {
        // Stub - runtime provides real implementation
        ≔ handle! = self.next_handle;
        self.next_handle = self.next_handle + 1;
        DomElement·new(handle)
    }

    rite apply_patch(&self, patch: Patch) {
        // Stub - runtime applies patches
        ⌥ patch {
            Patch·Create(_) => {}
            Patch·Remove(_) => {}
            Patch·Replace { id: _, node: _ } => {}
            Patch·UpdateAttrs { id: _, attrs: _ } => {}
            Patch·UpdateText { id: _, content: _ } => {}
            Patch·AppendChild { parent_id: _, node: _ } => {}
            Patch·RemoveChild { parent_id: _, child_id: _ } => {}
        }
    }

    rite add_event_listener(&self, _element: &DomElement, _event: EventType, _message_id: u64) {
        // Stub - runtime registers listeners
    }

    rite remove_event_listener(&self, _element: &DomElement, _event: EventType, _message_id: u64) {
        // Stub - runtime removes listeners
    }

    rite window_size(&self) -> (i32, i32)! {
        // Stub - runtime provides actual dimensions
        (1920, 1080)
    }

    rite request_animation_frame(&self, _message_id: u64) -> u64! {
        // Stub - runtime schedules frame
        0
    }

    rite cancel_animation_frame(&self, _id: u64) {
        // Stub
    }

    rite set_timeout(&self, _message_id: u64, _delay_ms: u64) -> u64! {
        // Stub
        0
    }

    rite clear_timeout(&self, _id: u64) {
        // Stub
    }

    rite set_interval(&self, _message_id: u64, _interval_ms: u64) -> u64! {
        // Stub
        0
    }

    rite clear_interval(&self, _id: u64) {
        // Stub
    }

    rite fetch_sync(&self, _url: &str, _options: FetchOptions) -> FetchResponse! {
        // Stub - runtime handles fetch
        FetchResponse {
            ok: false,
            status: 0,
            status_text: "Stub".to_string(),
            headers: HashMap·new(),
            body: Vec·new()
        }
    }

    rite current_url(&self) -> String! {
        // Stub
        "/".to_string()
    }

    rite push_history(&self, _url: &str) {
        // Stub
    }

    rite replace_history(&self, _url: &str) {
        // Stub
    }
}

// =============================================================================
// Server Platform (for SSR)
// =============================================================================

/// Server-side rendering platform
☉ Σ ServerPlatform {}

⊢ ServerPlatform {
    ☉ rite new() -> Self! {
        ServerPlatform {}
    }

    rite create_element(&self, _tag: &str) -> DomElement! {
        DomElement·new(0)
    }

    rite create_text(&self, _content: &str) -> DomElement! {
        DomElement·new(0)
    }

    rite fetch_sync(&self, _url: &str, _options: FetchOptions) -> FetchResponse! {
        // Server-side fetch - stub for now
        FetchResponse {
            ok: false,
            status: 501,
            status_text: "Not implemented".to_string(),
            headers: HashMap·new(),
            body: Vec·new()
        }
    }

    rite render_to_string(&self, vnode: &VNode) -> String! {
        render_vnode_to_string(vnode)
    }
}

/// Render VNode to HTML string
☉ rite render_vnode_to_string(vnode: &VNode) -> String! {
    ⌥ vnode {
        VNode·Element(el) => {
            ≔ Δ html! = format!("<{}", el.tag);

            // Add attributes
            ∀ (name, value) ∈ &el.attrs {
                html·push_str(&format!(" {}=\"{}\"", name, escape_attr(value)))
            }

            // Add styles
            ⎇ !el.styles·is_empty() {
                ≔ Δ style_parts! = Vec·new();
                ∀ (k, v) ∈ &el.styles {
                    style_parts·push(format!("{}: {}", k, v))
                }
                ≔ style_str! = style_parts·join("; ");
                html·push_str(&format!(" style=\"{}\"", style_str))
            }

            // Self-closing tags
            ≔ self_closing! = is_void_element(&el.tag);

            ⎇ self_closing && el.children·is_empty() {
                html·push_str(" />")
            } ⎉ {
                html·push('>');

                // Render children
                ∀ child ∈ &el.children {
                    html·push_str(&render_vnode_to_string(child))
                }

                html·push_str(&format!("</{}>", el.tag))
            }

            html
        }

        VNode·Text(text) => {
            escape_html(&text.content)
        }

        VNode·Fragment(frag) => {
            ≔ Δ result! = String·new();
            ∀ child ∈ &frag.children {
                result·push_str(&render_vnode_to_string(child))
            }
            result
        }

        VNode·Empty => {
            "".to_string()
        }
    }
}

/// Escape HTML special characters
rite escape_html(s: &str) -> String! {
    s·replace('&', "&amp;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

/// Escape attribute value
rite escape_attr(s: &str) -> String! {
    s·replace('&', "&amp;")
     ·replace('"', "&quot;")
     ·replace('<', "&lt;")
     ·replace('>', "&gt;")
}

/// Check if an element is a void element (self-closing)
rite is_void_element(tag: &str) -> bool! {
    tag == "area" || tag == "base" || tag == "br" || tag == "col" ||
    tag == "embed" || tag == "hr" || tag == "img" || tag == "input" ||
    tag == "link" || tag == "meta" || tag == "param" || tag == "source" ||
    tag == "track" || tag == "wbr"
}

// =============================================================================
// Platform Detection
// =============================================================================

/// Detect current platform
☉ rite detect() -> Platform! {
    // In WASM, this returns Browser; otherwise Server
    // The actual detection happens at compile time via cfg attributes
    Platform·browser()
}

// =============================================================================
// Tests
// =============================================================================

// cfg(test)
scroll tests {
    invoke super·*;
    invoke crate·core·vdom·{VElement, VText};

    //@ rune: test
    rite test_render_to_string_simple() {
        ≔ el! = VElement·new("div")·child(VNode·text("Hello"));
        ≔ vnode! = VNode·Element(el);
        ≔ html! = render_vnode_to_string(&vnode);
        assert_eq!(html, "<div>Hello</div>")
    }

    //@ rune: test
    rite test_render_self_closing() {
        ≔ el! = VElement·new("br");
        ≔ vnode! = VNode·Element(el);
        ≔ html! = render_vnode_to_string(&vnode);
        assert_eq!(html, "<br />")
    }

    //@ rune: test
    rite test_escape_html() {
        assert_eq!(escape_html("<script>"), "&lt;script&gt;")
    }
}
