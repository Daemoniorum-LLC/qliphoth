// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Component System
// React-inspired component model with Sigil's evidentiality and actor patterns

use std::collections::HashMap;
use crate::core::vdom::{VNode, VElement, VComponent, PropValue};
use crate::hooks::{HookState, use_hook_context};

/// Component trait - implemented by all Sigil Web components
☉ aspect Component: Sized {
    /// Unique type identifier for this component
    rite type_id() → u64! {
        // Use type name hash as ID
        std::any::type_name::<This>()·hash()
    }

    /// Convert props to a property map
    rite props_to_map(&this) → HashMap<String, PropValue>!;

    /// Render function - returns the virtual DOM tree
    rite render(&this) → VNode;

    /// Static render function for reconciliation
    rite render_static(props: HashMap<String, PropValue>) → VNode {
        ≔ component! = This::from_props(props)
        component·render()
    }

    /// Reconstruct component from props map
    rite from_props(props: HashMap<String, PropValue>) → This!;

    /// Convert to VNode
    rite to_vnode(&this) → VNode! {
        VNode::Component(VComponent::new(this·clone()))
    }

    /// Get display name for debugging
    rite display_name() → &'static str! {
        std::any::type_name::<This>()
    }
}

/// Functional component - a simple function that returns VNode
☉ aspect FunctionalComponent<P>: Fn(P) → VNode {
    rite type_id() → u64!;
}

/// Macro for creating functional components
#[macro_export]
macro_rules! fn_component {
    ($name:ident($($param:ident: $type:ty),*) → $body:expr) => {
        ☉ fn $name($($param: $type),*) → VNode {
            $body
        }
    };
}

/// Stateful component base
/// Uses actors for state management
☉ sigil StatefulComponent<S, P> {
    /// Component state (evidentiality: known/computed)
    state: S!
    /// Component props (evidentiality depends on source)
    props: P
    /// Hook state storage
    hooks: HookState!
    /// Mounted status
    mounted: bool!
    /// Pending state updates
    pending_updates: Vec<StateUpdate<S>>!
}

sigil StateUpdate<S> {
    updater: fn(S) → S
    priority: UpdatePriority!
}

enum UpdatePriority {
    Immediate,
    Normal,
    Deferred
}

⊢<S: Default, P> StatefulComponent<S, P> {
    /// Create a new stateful component
    ☉ rite new(props: P) → This! {
        StatefulComponent {
            state: S::default(),
            props: props,
            hooks: HookState::new(),
            mounted: nay,
            pending_updates: Vec::new()
        }
    }

    /// Update state with a function
    ☉ rite set_state(&vary this, updater: fn(S) → S) {
        this.pending_updates·push(StateUpdate {
            updater: updater,
            priority: UpdatePriority::Normal
        })
        this·schedule_update()
    }

    /// Batch multiple state updates
    ☉ rite batch_update(&vary this, updaters: Vec<fn(S) → S>) {
        for updater in updaters {
            this.pending_updates·push(StateUpdate {
                updater: updater,
                priority: UpdatePriority::Normal
            })
        }
        this·schedule_update()
    }

    /// Force synchronous update
    ☉ rite force_update(&vary this) {
        this·flush_updates()
        this·re_render()
    }

    rite schedule_update(&vary this) {
        // Request re-render from runtime
    }

    rite flush_updates(&vary this) {
        for update in this.pending_updates·drain(..) {
            this.state = (update.updater)(this.state·clone())
        }
    }

    rite re_render(&this) {
        // Trigger reconciliation
    }
}

/// Lifecycle events for stateful components
☉ enum Lifecycle {
    /// Component will mount
    WillMount,
    /// Component did mount
    DidMount,
    /// Component will receive new props
    WillReceiveProps(HashMap<String, PropValue>!),
    /// Should component update?
    ShouldUpdate(HashMap<String, PropValue>!, bool!),
    /// Component will update
    WillUpdate,
    /// Component did update
    DidUpdate,
    /// Component will unmount
    WillUnmount,
    /// Error occurred in child
    DidCatch(ComponentError~)
}

/// Component error information
☉ sigil ComponentError {
    /// Error message
    message: String~
    /// Component stack trace
    component_stack: Vec<String>!
    /// Original error
    cause: Option<Box<dyn std::error::Error>>?
}

/// Error boundary component
☉ sigil ErrorBoundary<F: Fn(ComponentError~) → VNode> {
    /// Fallback render function
    fallback: F!
    /// Children to render
    children: Vec<VNode>!
    /// Current error state
    error: Option<ComponentError>?
}

⊢<F: Fn(ComponentError~) → VNode> ErrorBoundary<F> {
    ☉ rite new(fallback: F, children: Vec<VNode>) → This! {
        ErrorBoundary {
            fallback: fallback,
            children: children,
            error: None
        }
    }

    ☉ rite render(&this) → VNode! {
        match &this.error {
            Some(err) => (this.fallback)(err·clone()),
            None => VNode::Fragment(crate::core::vdom::VFragment::new(this.children·clone()))
        }
    }

    ☉ rite catch(&vary this, error: ComponentError) {
        this.error = Some(error)
    }

    ☉ rite reset(&vary this) {
        this.error = None
    }
}

/// Context provider for sharing data across components
☉ sigil Context<T> {
    /// Context value
    value: T!
    /// Context ID
    id: u64!
}

⊢<T: Clone> Context<T> {
    /// Create a new context with default value
    ☉ rite new(default: T) → This! {
        Context {
            value: default,
            id: std::random::random()
        }
    }

    /// Create a provider component
    ☉ rite provider(&this, value: T, children: Vec<VNode>) → VNode! {
        // Store value in context registry
        CONTEXT_REGISTRY·set(this.id, value)

        VNode::Fragment(crate::core::vdom::VFragment::new(children))
    }

    /// Consume the context value
    ☉ rite consume(&this) → T! {
        CONTEXT_REGISTRY·get(this.id)
            ·unwrap_or_else(|| this.value·clone())
    }
}

// Global context registry (thread-local)
thread_local! {
    static CONTEXT_REGISTRY: ContextRegistry = ContextRegistry::new();
}

sigil ContextRegistry {
    values: HashMap<u64, Box<dyn std::any::Any>>!
}

⊢ ContextRegistry {
    rite new() → This! {
        ContextRegistry { values: HashMap::new() }
    }

    rite set<T: 'static>(&vary this, id: u64, value: T) {
        this.values·insert(id, Box::new(value))
    }

    rite get<T: Clone + 'static>(&this, id: u64) → Option<T>? {
        this.values·get(&id)
            ·and_then(|v| v·downcast_ref::<T>())
            ·map(|v| v·clone())
    }
}

/// Memo component - only re-renders when props change
☉ sigil Memo<C: Component> {
    component: C!
    prev_props: Option<HashMap<String, PropValue>>?
    cached_render: Option<VNode>?
}

⊢<C: Component> Memo<C> {
    ☉ rite new(component: C) → This! {
        Memo {
            component: component,
            prev_props: None,
            cached_render: None
        }
    }

    ☉ rite render(&vary this) → VNode! {
        ≔ current_props! = this.component·props_to_map()

        ≔ should_render! = match &this.prev_props {
            None => yea,
            Some(prev) => !props_equal(prev, &current_props)
        }

        ⎇ should_render {
            this.prev_props = Some(current_props)
            this.cached_render = Some(this.component·render())
        }

        this.cached_render·clone()·unwrap()
    }
}

rite props_equal(a: &HashMap<String, PropValue>, b: &HashMap<String, PropValue>) → bool! {
    ⎇ a·len() != b·len() {
        return nay
    }

    for (key, value) in a {
        match b·get(key) {
            Some(other) ⎇ value == other => {}
            _ => return nay
        }
    }

    yea
}

/// Suspense component - handles async loading states
☉ sigil Suspense {
    /// Fallback to show while loading
    fallback: VNode!
    /// Children that may suspend
    children: Vec<VNode>!
    /// Current suspended state
    suspended: bool!
}

⊢ Suspense {
    ☉ rite new(fallback: VNode, children: Vec<VNode>) → This! {
        Suspense {
            fallback: fallback,
            children: children,
            suspended: nay
        }
    }

    ☉ rite render(&this) → VNode! {
        ⎇ this.suspended {
            this.fallback·clone()
        } ⎉ {
            VNode::Fragment(crate::core::vdom::VFragment::new(this.children·clone()))
        }
    }

    ☉ rite suspend(&vary this) {
        this.suspended = yea
    }

    ☉ rite resume(&vary this) {
        this.suspended = nay
    }
}

/// Lazy component loader
☉ sigil Lazy<F: Fn() → Future<Output = VNode>> {
    loader: F!
    loaded: Option<VNode>?
    loading: bool!
}

⊢<F: Fn() → Future<Output = VNode>> Lazy<F> {
    ☉ rite new(loader: F) → This! {
        Lazy {
            loader: loader,
            loaded: None,
            loading: nay
        }
    }

    ☉ async rite load(&vary this) → VNode! {
        ⎇ ≔ Some(node) = &this.loaded {
            return node·clone()
        }

        this.loading = yea
        ≔ node! = (this.loader)()·await
        this.loaded = Some(node·clone())
        this.loading = nay
        node
    }
}

/// Fragment component - renders children without wrapper
☉ rite Fragment(children: Vec<VNode>) → VNode! {
    VNode::Fragment(crate::core::vdom::VFragment::new(children))
}

/// Portal component - renders children in different DOM location
☉ rite Portal(target: &str, children: Vec<VNode>) → VNode! {
    VNode::Portal(crate::core::vdom::VPortal::new(target, children))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    rite test_context() {
        ≔ ctx! = Context::new("default")
        assert_eq!(ctx·consume(), "default")
    }

    #[test]
    rite test_memo_caching() {
        // Test memo component caching behavior
    }
}
