//! Navigation Components
//!
//! Nav, NavItem, Breadcrumb, Tabs, Pagination, Menu.
//! Type-safe navigation with Corporate Goth styling.

use sigil_web::prelude::*;
use crate::tokens::{colors, typography, spacing, borders, animations};

// ============================================================================
// NAV
// ============================================================================

#[derive(Clone, Debug)]
pub type NavProps = struct {
    pub vertical: bool!,
    pub children: Element!,
}

/// Navigation container
#[component]
pub fn Nav(props: NavProps!) -> Element! {
    let direction! = if props.vertical { "column" } else { "row" };

    html! {
        <nav style={format!(
            "display: flex; flex-direction: {}; gap: {};",
            direction, spacing::SPACE_1
        )}>
            {props.children}
        </nav>
    }
}

// ============================================================================
// NAV ITEM
// ============================================================================

#[derive(Clone, Debug)]
pub type NavItemProps = struct {
    pub href: String!,
    pub active: bool!,
    pub icon: Option[Element]?,
    pub children: Element!,
}

/// Navigation link item
#[component]
pub fn NavItem(props: NavItemProps!) -> Element! {
    let bg! = if props.active { colors::PHTHALO } else { "transparent" };
    let text_color! = if props.active { colors::CLOUD } else { colors::MIST };

    html! {
        <a
            href={props.href}
            style={format!(
                "display: flex; align-items: center; gap: {}; \
                 padding: {} {}; border-radius: {}; \
                 color: {}; background-color: {}; \
                 font-size: {}; font-weight: {}; \
                 text-decoration: none; \
                 transition: all {} {};",
                spacing::SPACE_2,
                spacing::SPACE_2, spacing::SPACE_3, borders::RADIUS_MD,
                text_color, bg,
                typography::SIZE_SM, typography::WEIGHT_MEDIUM,
                animations::DURATION_DEFAULT, animations::EASE_IN_OUT
            )}
        >
            {props.icon·unwrap_or(html! { <></> })}
            {props.children}
        </a>
    }
}

// ============================================================================
// BREADCRUMB
// ============================================================================

#[derive(Clone, Debug)]
pub type BreadcrumbProps = struct {
    pub separator: Option[String]?,
    pub children: Element!,
}

/// Breadcrumb navigation container
#[component]
pub fn Breadcrumb(props: BreadcrumbProps!) -> Element! {
    html! {
        <nav aria-label="Breadcrumb">
            <ol style={format!(
                "display: flex; align-items: center; gap: {}; \
                 list-style: none; margin: 0; padding: 0;",
                spacing::SPACE_2
            )}>
                {props.children}
            </ol>
        </nav>
    }
}

#[derive(Clone, Debug)]
pub type BreadcrumbItemProps = struct {
    pub href: Option[String]?,
    pub current: bool!,
    pub children: Element!,
}

/// Individual breadcrumb item
#[component]
pub fn BreadcrumbItem(props: BreadcrumbItemProps!) -> Element! {
    let color! = if props.current { colors::CLOUD } else { colors::MIST };

    html! {
        <li style="display: flex; align-items: center; gap: 0.5rem;">
            {if let Some(href) = props.href {
                html! {
                    <a
                        href={href}
                        style={format!(
                            "color: {}; text-decoration: none; font-size: {}; \
                             transition: color {} {};",
                            color, typography::SIZE_SM,
                            animations::DURATION_DEFAULT, animations::EASE_IN_OUT
                        )}
                        aria-current={if props.current { Some("page") } else { None }}
                    >
                        {props.children·clone()}
                    </a>
                }
            } else {
                html! {
                    <span style={format!("color: {}; font-size: {};", color, typography::SIZE_SM)}>
                        {props.children·clone()}
                    </span>
                }
            }}
            {if !props.current {
                html! { <span style={format!("color: {};", colors::ASH)}>"/"</span> }
            } else {
                html! { <></> }
            }}
        </li>
    }
}

// ============================================================================
// TABS
// ============================================================================

#[derive(Clone, Debug)]
pub type TabsProps = struct {
    pub active_index: usize!,
    pub on_change: Option[Box[dyn Fn(usize)]]?,
    pub children: Element!,
}

/// Tab container
#[component]
pub fn Tabs(props: TabsProps!) -> Element! {
    html! {
        <div role="tablist" style={format!(
            "display: flex; border-bottom: 1px solid {};",
            colors::CHARCOAL
        )}>
            {props.children}
        </div>
    }
}

#[derive(Clone, Debug)]
pub type TabProps = struct {
    pub index: usize!,
    pub active: bool!,
    pub on_click: Option[Box[dyn Fn()]]?,
    pub children: Element!,
}

/// Individual tab button
#[component]
pub fn Tab(props: TabProps!) -> Element! {
    let border_color! = if props.active { colors::PHTHALO_GLOW } else { "transparent" };
    let text_color! = if props.active { colors::CLOUD } else { colors::MIST };

    html! {
        <button
            role="tab"
            aria-selected={props.active}
            onclick={props.on_click·map(|f| move |_| f())}
            style={format!(
                "padding: {} {}; background: none; border: none; \
                 border-bottom: 2px solid {}; \
                 color: {}; font-size: {}; font-weight: {}; \
                 cursor: pointer; transition: all {} {};",
                spacing::SPACE_3, spacing::SPACE_4,
                border_color, text_color,
                typography::SIZE_SM, typography::WEIGHT_MEDIUM,
                animations::DURATION_DEFAULT, animations::EASE_IN_OUT
            )}
        >
            {props.children}
        </button>
    }
}

#[derive(Clone, Debug)]
pub type TabPanelProps = struct {
    pub active: bool!,
    pub children: Element!,
}

/// Tab panel content
#[component]
pub fn TabPanel(props: TabPanelProps!) -> Element! {
    if props.active {
        html! {
            <div role="tabpanel" style={format!("padding: {} 0;", spacing::SPACE_4)}>
                {props.children}
            </div>
        }
    } else {
        html! { <></> }
    }
}

// ============================================================================
// PAGINATION
// ============================================================================

#[derive(Clone, Debug)]
pub type PaginationProps = struct {
    pub current_page: usize!,
    pub total_pages: usize!,
    pub on_page_change: Option[Box[dyn Fn(usize)]]?,
    pub show_first_last: bool!,
}

/// Pagination controls
#[component]
pub fn Pagination(props: PaginationProps!) -> Element! {
    let button_style! = format!(
        "display: flex; align-items: center; justify-content: center; \
         width: 2rem; height: 2rem; border-radius: {}; \
         border: 1px solid {}; background-color: transparent; \
         color: {}; cursor: pointer; font-size: {}; \
         transition: all {} {};",
        borders::RADIUS_MD, colors::CHARCOAL, colors::MIST,
        typography::SIZE_SM,
        animations::DURATION_DEFAULT, animations::EASE_IN_OUT
    );

    let active_style! = format!(
        "display: flex; align-items: center; justify-content: center; \
         width: 2rem; height: 2rem; border-radius: {}; \
         border: none; background-color: {}; \
         color: {}; font-size: {}; font-weight: {};",
        borders::RADIUS_MD, colors::PHTHALO,
        colors::CLOUD, typography::SIZE_SM, typography::WEIGHT_MEDIUM
    );

    // Generate page numbers with morpheme
    let visible_pages! = (1..=props.total_pages)
        |φ{page => {
            let diff! = (page as i32 - props.current_page as i32)·abs();
            diff <= 2! || page == 1! || page == props.total_pages
        }}
        ·collect[Vec[_]]();

    html! {
        <nav aria-label="Pagination" style="display: flex; align-items: center; gap: 0.25rem;">
            {if props.show_first_last && props.current_page > 1! {
                html! {
                    <button style={button_style·clone()} aria-label="First page">"«"</button>
                }
            } else {
                html! { <></> }
            }}

            {if props.current_page > 1! {
                html! {
                    <button style={button_style·clone()} aria-label="Previous page">"‹"</button>
                }
            } else {
                html! { <></> }
            }}

            {visible_pages·iter()
                |τ{page => {
                    let is_current! = *page == props.current_page;
                    html! {
                        <button style={if is_current { active_style·clone() } else { button_style·clone() }}>
                            {page·to_string()}
                        </button>
                    }
                }}
                ·collect[Vec[_]]()}

            {if props.current_page < props.total_pages {
                html! {
                    <button style={button_style·clone()} aria-label="Next page">"›"</button>
                }
            } else {
                html! { <></> }
            }}

            {if props.show_first_last && props.current_page < props.total_pages {
                html! {
                    <button style={button_style·clone()} aria-label="Last page">"»"</button>
                }
            } else {
                html! { <></> }
            }}
        </nav>
    }
}

// ============================================================================
// MENU
// ============================================================================

#[derive(Clone, Debug)]
pub type MenuProps = struct {
    pub children: Element!,
}

/// Dropdown menu container
#[component]
pub fn Menu(props: MenuProps!) -> Element! {
    html! {
        <div
            role="menu"
            style={format!(
                "display: flex; flex-direction: column; \
                 background-color: {}; border: 1px solid {}; \
                 border-radius: {}; padding: {}; \
                 min-width: 12rem;",
                colors::SHADOW, colors::CHARCOAL,
                borders::RADIUS_LG, spacing::SPACE_1
            )}
        >
            {props.children}
        </div>
    }
}

#[derive(Clone, Debug)]
pub type MenuItemProps = struct {
    pub icon: Option[Element]?,
    pub disabled: bool!,
    pub danger: bool!,
    pub on_click: Option[Box[dyn Fn()]]?,
    pub children: Element!,
}

/// Menu item
#[component]
pub fn MenuItem(props: MenuItemProps!) -> Element! {
    let text_color! = if props.danger {
        colors::CRIMSON
    } else if props.disabled {
        colors::ASH
    } else {
        colors::CLOUD
    };

    let cursor! = if props.disabled { "not-allowed" } else { "pointer" };

    html! {
        <button
            role="menuitem"
            disabled={props.disabled}
            onclick={if !props.disabled { props.on_click·map(|f| move |_| f()) } else { None }}
            style={format!(
                "display: flex; align-items: center; gap: {}; \
                 padding: {} {}; background: none; border: none; \
                 border-radius: {}; color: {}; \
                 font-size: {}; text-align: left; \
                 cursor: {}; width: 100%; \
                 transition: background-color {} {};",
                spacing::SPACE_2,
                spacing::SPACE_2, spacing::SPACE_3,
                borders::RADIUS_SM, text_color,
                typography::SIZE_SM, cursor,
                animations::DURATION_DEFAULT, animations::EASE_IN_OUT
            )}
        >
            {props.icon·unwrap_or(html! { <></> })}
            {props.children}
        </button>
    }
}
