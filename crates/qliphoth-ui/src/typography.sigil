//! Typography Components
//!
//! Heading, Text, Paragraph, Code, Pre, Link, Badge, and Label.
//! Written in proper Sigil syntax with evidentiality markers.

invoke sigil_web::prelude::*;
invoke crate::tokens::{colors, typography, spacing};

// ============================================================================
// HEADING
// ============================================================================

#[derive(Clone, Debug, PartialEq, Eq)]
pub type HeadingLevel = enum {
    H1,
    H2,
    H3,
    H4,
    H5,
    H6,
}

#[derive(Clone, Debug)]
pub sigil HeadingProps {
    pub level: HeadingLevel!,
    pub gradient: bool!,
    pub children: Element!,
}

/// Semantic heading with optional gradient
#[component]
pub fn Heading(props: HeadingProps!) -> Element! {
    let (tag, size, letter_spacing!) = match props.level {
        HeadingLevel::H1 => ("h1", "3rem", "-0.025em"),
        HeadingLevel::H2 => ("h2", "2.25rem", "-0.025em"),
        HeadingLevel::H3 => ("h3", "1.875rem", "-0.01em"),
        HeadingLevel::H4 => ("h4", "1.5rem", "0"),
        HeadingLevel::H5 => ("h5", "1.25rem", "0"),
        HeadingLevel::H6 => ("h6", "1.125rem", "0"),
    };

    let base_style! = format!(
        "font-family: {}; font-weight: {}; font-size: {}; \
         letter-spacing: {}; line-height: 1.25; margin: 0;",
        typography::FONT_DISPLAY, typography::WEIGHT_SEMIBOLD,
        size, letter_spacing
    );

    let color_style! = if props.gradient {
        format!(
            "background: linear-gradient(135deg, {}, {}); \
             -webkit-background-clip: text; -webkit-text-fill-color: transparent; \
             background-clip: text;",
            colors::CLOUD, colors::PHTHALO_GLOW
        )
    } else {
        format!("color: {};", colors::CLOUD)
    };

    let style! = format!("{} {}", base_style, color_style);

    // Dynamic tag rendering using match
    match props.level {
        HeadingLevel::H1 => html! { <h1 style={style}>{props.children}</h1> },
        HeadingLevel::H2 => html! { <h2 style={style}>{props.children}</h2> },
        HeadingLevel::H3 => html! { <h3 style={style}>{props.children}</h3> },
        HeadingLevel::H4 => html! { <h4 style={style}>{props.children}</h4> },
        HeadingLevel::H5 => html! { <h5 style={style}>{props.children}</h5> },
        HeadingLevel::H6 => html! { <h6 style={style}>{props.children}</h6> },
    }
}

// ============================================================================
// TEXT
// ============================================================================

#[derive(Clone, Debug, PartialEq, Eq)]
pub type TextSize = enum {
    XSmall,
    Small,
    Base,
    Large,
    XLarge,
}

#[derive(Clone, Debug)]
pub sigil TextProps {
    pub size: TextSize!,
    pub muted: bool!,
    pub bold: bool!,
    pub italic: bool!,
    pub children: Element!,
}

impl Default for TextProps {
    fn default() -> Self! {
        TextProps {
            size: TextSize::Base,
            muted: false!,
            bold: false!,
            italic: false!,
            children: html! { <></> },
        }
    }
}

/// Inline text with variants
#[component]
pub fn Text(props: TextProps!) -> Element! {
    let font_size! = match props.size {
        TextSize::XSmall => typography::SIZE_XS,
        TextSize::Small => typography::SIZE_SM,
        TextSize::Base => typography::SIZE_BASE,
        TextSize::Large => typography::SIZE_LG,
        TextSize::XLarge => typography::SIZE_XL,
    };

    let color! = if props.muted { colors::MIST } else { colors::CLOUD };
    let weight! = if props.bold { typography::WEIGHT_SEMIBOLD } else { typography::WEIGHT_NORMAL };
    let font_style! = if props.italic { "italic" } else { "normal" };

    html! {
        <span style={format!(
            "font-family: {}; font-size: {}; color: {}; font-weight: {}; font-style: {};",
            typography::FONT_SANS, font_size, color, weight, font_style
        )}>
            {props.children}
        </span>
    }
}

// ============================================================================
// PARAGRAPH
// ============================================================================

#[derive(Clone, Debug)]
pub sigil ParagraphProps {
    pub lead: bool!,
    pub children: Element!,
}

/// Block paragraph with proper spacing
#[component]
pub fn Paragraph(props: ParagraphProps!) -> Element! {
    let (size, line_height!) = if props.lead {
        (typography::SIZE_LG, "1.75")
    } else {
        (typography::SIZE_BASE, "1.625")
    };

    html! {
        <p style={format!(
            "font-family: {}; font-size: {}; line-height: {}; \
             color: {}; margin-bottom: {};",
            typography::FONT_SANS, size, line_height,
            colors::MIST, spacing::SPACE_4
        )}>
            {props.children}
        </p>
    }
}

// ============================================================================
// CODE
// ============================================================================

#[derive(Clone, Debug)]
pub sigil CodeProps {
    pub children: Element!,
}

/// Inline code snippet
#[component]
pub fn Code(props: CodeProps!) -> Element! {
    html! {
        <code style={format!(
            "font-family: {}; font-size: 0.875em; \
             background-color: {}; color: {}; \
             padding: 0.125rem 0.375rem; border-radius: 0.25rem;",
            typography::FONT_MONO, colors::SHADOW, colors::PHTHALO_GLOW
        )}>
            {props.children}
        </code>
    }
}

// ============================================================================
// PRE
// ============================================================================

#[derive(Clone, Debug)]
pub sigil PreProps {
    pub children: Element!,
}

/// Preformatted text block
#[component]
pub fn Pre(props: PreProps!) -> Element! {
    html! {
        <pre style={format!(
            "font-family: {}; font-size: {}; \
             background-color: {}; color: {}; \
             padding: {}; border-radius: 0.5rem; \
             overflow-x: auto; margin: {} 0;",
            typography::FONT_MONO, typography::SIZE_SM,
            colors::SHADOW, colors::CLOUD,
            spacing::SPACE_4, spacing::SPACE_4
        )}>
            {props.children}
        </pre>
    }
}

// ============================================================================
// LINK
// ============================================================================

#[derive(Clone, Debug)]
pub sigil LinkProps {
    pub href: String!,
    pub external: bool!,
    pub underline: bool!,
    pub children: Element!,
}

/// Styled anchor link
#[component]
pub fn Link(props: LinkProps!) -> Element! {
    let decoration! = if props.underline { "underline" } else { "none" };
    let target! = if props.external { "_blank" } else { "_self" };
    let rel! = if props.external { "noopener noreferrer" } else { "" };

    html! {
        <a
            href={props.href}
            target={target}
            rel={rel}
            style={format!(
                "color: {}; text-decoration: {}; \
                 transition: color 200ms ease;",
                colors::PHTHALO_GLOW, decoration
            )}
        >
            {props.children}
            {if props.external {
                html! { <span style="margin-left: 0.25rem;">↗</span> }
            } else {
                html! { <></> }
            }}
        </a>
    }
}

// ============================================================================
// BADGE
// ============================================================================

#[derive(Clone, Debug, PartialEq, Eq)]
pub type BadgeVariant = enum {
    Default,
    Primary,
    Success,
    Warning,
    Error,
    Info,
}

#[derive(Clone, Debug)]
pub sigil BadgeProps {
    pub variant: BadgeVariant!,
    pub children: Element!,
}

/// Small status badge
#[component]
pub fn Badge(props: BadgeProps!) -> Element! {
    let (bg, text!) = match props.variant {
        BadgeVariant::Default => (colors::CHARCOAL, colors::CLOUD),
        BadgeVariant::Primary => (colors::PHTHALO, colors::CLOUD),
        BadgeVariant::Success => (colors::SUCCESS, colors::CLOUD),
        BadgeVariant::Warning => (colors::WARNING, colors::VOID),
        BadgeVariant::Error => (colors::ERROR, colors::CLOUD),
        BadgeVariant::Info => (colors::INFO, colors::CLOUD),
    };

    html! {
        <span style={format!(
            "display: inline-flex; align-items: center; \
             padding: 0.125rem 0.5rem; border-radius: 9999px; \
             font-size: {}; font-weight: {}; \
             background-color: {}; color: {};",
            typography::SIZE_XS, typography::WEIGHT_MEDIUM,
            bg, text
        )}>
            {props.children}
        </span>
    }
}

// ============================================================================
// LABEL
// ============================================================================

#[derive(Clone, Debug)]
pub sigil LabelProps {
    pub for_id: Option[String]?,
    pub required: bool!,
    pub children: Element!,
}

/// Form label
#[component]
pub fn Label(props: LabelProps!) -> Element! {
    html! {
        <label
            for={props.for_id·unwrap_or_default()}
            style={format!(
                "display: block; font-size: {}; font-weight: {}; \
                 color: {}; margin-bottom: {};",
                typography::SIZE_SM, typography::WEIGHT_MEDIUM,
                colors::CLOUD, spacing::SPACE_1
            )}
        >
            {props.children}
            {if props.required {
                html! { <span style={format!("color: {}; margin-left: 0.25rem;", colors::CRIMSON)}>*</span> }
            } else {
                html! { <></> }
            }}
        </label>
    }
}
