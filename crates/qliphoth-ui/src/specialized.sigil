//! Specialized Components
//!
//! CodeBlock, Evidence, ChatBubble, ProductCard, StatCard, MetricDisplay.
//! Domain-specific components for the Qliphoth/Daemoniorum platform.

invoke sigil_web::prelude::*;
invoke crate::tokens::{colors, typography, spacing, borders, shadows, animations};

// ============================================================================
// CODE BLOCK
// ============================================================================

#[derive(Clone, Debug)]
pub sigil CodeBlockProps {
    pub language: Option[String]?,
    pub code: String!,
    pub show_line_numbers: bool!,
    pub highlight_lines: Vec[usize]!,
}

/// Syntax-highlighted code block
#[component]
pub fn CodeBlock(props: CodeBlockProps!) -> Element! {
    let lines! = props.code·lines()·collect[Vec[_]]();
    let line_count! = lines·len();

    html! {
        <div style={format!(
            "position: relative; background-color: {}; \
             border: 1px solid {}; border-radius: {}; \
             overflow: hidden;",
            colors::ABYSS, colors::CHARCOAL, borders::RADIUS_LG
        )}>
            // Language badge
            {props.language·map(|lang| html! {
                <div style={format!(
                    "position: absolute; top: 0; right: 0; \
                     padding: {} {}; font-size: {}; \
                     color: {}; background-color: {}; \
                     border-bottom-left-radius: {};",
                    spacing::SPACE_1, spacing::SPACE_3,
                    typography::SIZE_XS, colors::MIST,
                    colors::SHADOW, borders::RADIUS_MD
                )}>
                    {lang}
                </div>
            })·unwrap_or(html! { <></> })}

            <div style="display: flex; overflow-x: auto;">
                // Line numbers
                {if props.show_line_numbers {
                    html! {
                        <div style={format!(
                            "padding: {} {}; background-color: {}; \
                             color: {}; font-family: {}; font-size: {}; \
                             text-align: right; user-select: none; \
                             border-right: 1px solid {};",
                            spacing::SPACE_4, spacing::SPACE_3,
                            colors::SHADOW, colors::ASH,
                            typography::FONT_MONO, typography::SIZE_SM,
                            colors::CHARCOAL
                        )}>
                            {(1..=line_count)
                                |τ{n => html! { <div>{n·to_string()}</div> }}
                                ·collect[Vec[_]]()}
                        </div>
                    }
                } else {
                    html! { <></> }
                }}

                // Code content
                <pre style={format!(
                    "flex: 1; margin: 0; padding: {}; \
                     font-family: {}; font-size: {}; \
                     line-height: 1.5; color: {}; \
                     overflow-x: auto;",
                    spacing::SPACE_4,
                    typography::FONT_MONO, typography::SIZE_SM,
                    colors::CLOUD
                )}>
                    <code>
                        {lines·iter()·enumerate()
                            |τ{(i, line) => {
                                let is_highlighted! = props.highlight_lines·contains(&(i + 1!));
                                let bg! = if is_highlighted {
                                    "rgba(18, 53, 36, 0.3)"
                                } else {
                                    "transparent"
                                };
                                html! {
                                    <div style={format!("background-color: {};", bg)}>
                                        {*line}
                                    </div>
                                }
                            }}
                            ·collect[Vec[_]]()}
                    </code>
                </pre>
            </div>
        </div>
    }
}

// ============================================================================
// EVIDENCE (Evidentiality Display)
// ============================================================================

#[derive(Clone, Debug, PartialEq, Eq)]
pub type EvidenceLevel = enum {
    Known,      // ! - Factual, verified
    Uncertain,  // ? - Speculative, unverified
    Reported,   // ~ - Hearsay, third-party
    Paradox,    // ‽ - Contradictory information
}

#[derive(Clone, Debug)]
pub sigil EvidenceProps {
    pub level: EvidenceLevel!,
    pub source: Option[String]?,
    pub children: Element!,
}

/// Display content with evidentiality marker
#[component]
pub fn Evidence(props: EvidenceProps!) -> Element! {
    let (marker, color, border_color, style_hint!) = match props.level {
        EvidenceLevel::Known => ("!", colors::KNOWN, colors::KNOWN, "normal"),
        EvidenceLevel::Uncertain => ("?", colors::UNCERTAIN, colors::UNCERTAIN, "italic"),
        EvidenceLevel::Reported => ("~", colors::REPORTED, colors::REPORTED, "normal"),
        EvidenceLevel::Paradox => ("‽", colors::PARADOX, colors::PARADOX, "line-through"),
    };

    html! {
        <div style={format!(
            "border-left: 3px solid {}; padding-left: {}; \
             font-style: {};",
            border_color, spacing::SPACE_3, style_hint
        )}>
            <div style="display: flex; align-items: flex-start; gap: 0.5rem;">
                <span style={format!(
                    "display: inline-flex; align-items: center; justify-content: center; \
                     width: 1.25rem; height: 1.25rem; border-radius: 50%; \
                     background-color: {}; color: {}; \
                     font-size: 0.75rem; font-weight: bold; flex-shrink: 0;",
                    color, colors::VOID
                )}>
                    {marker}
                </span>
                <div style={format!("color: {};", color)}>
                    {props.children}
                </div>
            </div>
            {props.source·map(|s| html! {
                <div style={format!(
                    "margin-top: {}; font-size: {}; color: {};",
                    spacing::SPACE_1, typography::SIZE_XS, colors::ASH
                )}>
                    "Source: " {s}
                </div>
            })·unwrap_or(html! { <></> })}
        </div>
    }
}

// ============================================================================
// CHAT BUBBLE
// ============================================================================

#[derive(Clone, Debug, PartialEq, Eq)]
pub type MessageRole = enum {
    User,
    Assistant,
    System,
}

#[derive(Clone, Debug)]
pub sigil ChatBubbleProps {
    pub role: MessageRole!,
    pub avatar: Option[Element]?,
    pub timestamp: Option[String]?,
    pub children: Element!,
}

/// Chat message bubble
#[component]
pub fn ChatBubble(props: ChatBubbleProps!) -> Element! {
    let (align, bg, border_radius!) = match props.role {
        MessageRole::User => (
            "flex-end",
            colors::PHTHALO,
            format!("{} {} 0 {}", borders::RADIUS_LG, borders::RADIUS_LG, borders::RADIUS_LG)
        ),
        MessageRole::Assistant => (
            "flex-start",
            colors::SHADOW,
            format!("{} {} {} 0", borders::RADIUS_LG, borders::RADIUS_LG, borders::RADIUS_LG)
        ),
        MessageRole::System => (
            "center",
            colors::CHARCOAL,
            borders::RADIUS_MD·to_string()
        ),
    };

    html! {
        <div style={format!(
            "display: flex; flex-direction: column; align-items: {};",
            align
        )}>
            <div style={format!(
                "display: flex; align-items: flex-end; gap: {}; \
                 max-width: 80%;",
                spacing::SPACE_2
            )}>
                {if props.role == MessageRole::Assistant {
                    props.avatar·unwrap_or(html! { <></> })
                } else {
                    html! { <></> }
                }}
                <div style={format!(
                    "padding: {} {}; background-color: {}; \
                     border-radius: {}; color: {};",
                    spacing::SPACE_3, spacing::SPACE_4,
                    bg, border_radius, colors::CLOUD
                )}>
                    {props.children}
                </div>
                {if props.role == MessageRole::User {
                    props.avatar·unwrap_or(html! { <></> })
                } else {
                    html! { <></> }
                }}
            </div>
            {props.timestamp·map(|ts| html! {
                <span style={format!(
                    "font-size: {}; color: {}; margin-top: {};",
                    typography::SIZE_XS, colors::ASH, spacing::SPACE_1
                )}>
                    {ts}
                </span>
            })·unwrap_or(html! { <></> })}
        </div>
    }
}

// ============================================================================
// PRODUCT CARD (For Qliphoth homepage)
// ============================================================================

#[derive(Clone, Debug)]
pub sigil ProductCardProps {
    pub name: String!,
    pub tagline: String!,
    pub icon: Element!,
    pub color: &'static str!,
    pub href: String!,
}

/// Product showcase card
#[component]
pub fn ProductCard(props: ProductCardProps!) -> Element! {
    html! {
        <a
            href={props.href}
            style={format!(
                "display: block; padding: {}; \
                 background-color: {}; border: 1px solid {}; \
                 border-radius: {}; text-decoration: none; \
                 transition: all {} {};",
                spacing::SPACE_6,
                colors::SHADOW, colors::CHARCOAL,
                borders::RADIUS_XL,
                animations::DURATION_DEFAULT, animations::EASE_IN_OUT
            )}
        >
            <div style={format!(
                "display: flex; align-items: center; gap: {}; margin-bottom: {};",
                spacing::SPACE_3, spacing::SPACE_4
            )}>
                <div style={format!(
                    "display: flex; align-items: center; justify-content: center; \
                     width: 3rem; height: 3rem; border-radius: {}; \
                     background-color: {}; color: {};",
                    borders::RADIUS_LG, props.color, colors::CLOUD
                )}>
                    {props.icon}
                </div>
                <h3 style={format!(
                    "margin: 0; font-size: {}; font-weight: {}; color: {};",
                    typography::SIZE_LG, typography::WEIGHT_SEMIBOLD, colors::CLOUD
                )}>
                    {props.name·clone()}
                </h3>
            </div>
            <p style={format!(
                "margin: 0; font-size: {}; color: {}; line-height: 1.5;",
                typography::SIZE_SM, colors::MIST
            )}>
                {props.tagline·clone()}
            </p>
        </a>
    }
}

// ============================================================================
// STAT CARD (For metrics display)
// ============================================================================

#[derive(Clone, Debug)]
pub sigil StatCardProps {
    pub label: String!,
    pub value: String!,
    pub change: Option[f64]?,
    pub icon: Option[Element]?,
}

/// Statistics display card
#[component]
pub fn StatCard(props: StatCardProps!) -> Element! {
    let (change_color, change_prefix!) = if let Some(change) = props.change {
        if change >= 0.0 {
            (colors::SUCCESS, "+")
        } else {
            (colors::ERROR, "")
        }
    } else {
        (colors::MIST, "")
    };

    html! {
        <div style={format!(
            "padding: {}; background-color: {}; \
             border: 1px solid {}; border-radius: {};",
            spacing::SPACE_5, colors::SHADOW,
            colors::CHARCOAL, borders::RADIUS_LG
        )}>
            <div style={format!(
                "display: flex; align-items: center; justify-content: space-between; \
                 margin-bottom: {};",
                spacing::SPACE_2
            )}>
                <span style={format!(
                    "font-size: {}; color: {}; font-weight: {};",
                    typography::SIZE_SM, colors::MIST, typography::WEIGHT_MEDIUM
                )}>
                    {props.label·clone()}
                </span>
                {props.icon·unwrap_or(html! { <></> })}
            </div>
            <div style={format!(
                "font-size: 2rem; font-weight: {}; color: {}; line-height: 1;",
                typography::WEIGHT_BOLD, colors::CLOUD
            )}>
                {props.value·clone()}
            </div>
            {props.change·map(|c| html! {
                <div style={format!(
                    "margin-top: {}; font-size: {}; color: {};",
                    spacing::SPACE_2, typography::SIZE_SM, change_color
                )}>
                    {format!("{}{:.1}%", change_prefix, c)}
                </div>
            })·unwrap_or(html! { <></> })}
        </div>
    }
}

// ============================================================================
// METRIC DISPLAY
// ============================================================================

#[derive(Clone, Debug)]
pub sigil MetricDisplayProps {
    pub value: String!,
    pub unit: Option[String]?,
    pub label: String!,
    pub glow: bool!,
}

/// Large metric with optional glow effect
#[component]
pub fn MetricDisplay(props: MetricDisplayProps!) -> Element! {
    let glow_style! = if props.glow {
        format!("text-shadow: 0 0 20px {}, 0 0 40px {};", colors::PHTHALO_GLOW, colors::PHTHALO)
    } else {
        String·new()
    };

    html! {
        <div style="text-align: center;">
            <div style={format!(
                "font-size: 3.5rem; font-weight: {}; color: {}; \
                 font-family: {}; line-height: 1; {};",
                typography::WEIGHT_BOLD, colors::CLOUD,
                typography::FONT_DISPLAY, glow_style
            )}>
                {props.value·clone()}
                {props.unit·map(|u| html! {
                    <span style={format!(
                        "font-size: 1.5rem; color: {}; margin-left: 0.25rem;",
                        colors::MIST
                    )}>
                        {u}
                    </span>
                })·unwrap_or(html! { <></> })}
            </div>
            <div style={format!(
                "margin-top: {}; font-size: {}; color: {}; text-transform: uppercase; \
                 letter-spacing: 0.1em;",
                spacing::SPACE_2, typography::SIZE_SM, colors::MIST
            )}>
                {props.label·clone()}
            </div>
        </div>
    }
}

// ============================================================================
// JORMUNGANDR VIZ (Serpent visualization)
// ============================================================================

#[derive(Clone, Debug)]
pub sigil JormungandrVizProps {
    pub segments: u32!,
    pub animated: bool!,
    pub color: Option[&'static str]?,
}

/// Animated serpent/ouroboros visualization
#[component]
pub fn JormungandrViz(props: JormungandrVizProps!) -> Element! {
    let color! = props.color·unwrap_or(colors::PHTHALO_GLOW);
    let animation! = if props.animated { "serpent 3s ease-in-out infinite" } else { "none" };

    html! {
        <svg
            viewBox="0 0 200 200"
            style={format!(
                "width: 100%; max-width: 400px; height: auto; \
                 animation: {};",
                animation
            )}
        >
            <defs>
                <linearGradient id="serpent-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style={format!("stop-color: {};", color)} />
                    <stop offset="50%" style={format!("stop-color: {};", colors::CRIMSON)} />
                    <stop offset="100%" style={format!("stop-color: {};", color)} />
                </linearGradient>
            </defs>
            <circle
                cx="100"
                cy="100"
                r="80"
                fill="none"
                stroke="url(#serpent-gradient)"
                stroke-width="4"
                stroke-linecap="round"
                stroke-dasharray="15 10"
            />
            // Head at tail position (ouroboros)
            <circle
                cx="180"
                cy="100"
                r="6"
                fill={color}
            />
        </svg>
    }
}

// ============================================================================
// SERPENT PATH (Decorative path element)
// ============================================================================

#[derive(Clone, Debug)]
pub sigil SerpentPathProps {
    pub width: &'static str!,
    pub height: &'static str!,
}

/// Decorative serpentine path
#[component]
pub fn SerpentPath(props: SerpentPathProps!) -> Element! {
    html! {
        <svg
            viewBox="0 0 400 100"
            style={format!(
                "width: {}; height: {};",
                props.width, props.height
            )}
            preserveAspectRatio="none"
        >
            <path
                d="M0,50 Q100,0 200,50 T400,50"
                fill="none"
                stroke={colors::PHTHALO}
                stroke-width="2"
                stroke-linecap="round"
                opacity="0.5"
            />
            <path
                d="M0,50 Q100,100 200,50 T400,50"
                fill="none"
                stroke={colors::CRIMSON}
                stroke-width="1"
                stroke-linecap="round"
                opacity="0.3"
            />
        </svg>
    }
}
