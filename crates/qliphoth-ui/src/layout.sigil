//! Layout Components
//!
//! Container, Grid, Stack, Flex, and page structure components.
//! Uses Sigil's component syntax with proper type definitions.

use sigil_web::prelude::*;
use crate::tokens::{colors, spacing, containers};

// ============================================================================
// CONTAINER
// ============================================================================

#[derive(Clone, Debug)]
pub type ContainerProps = struct {
    pub max_width: Option[&'static str]?,
    pub padding: Option[&'static str]?,
    pub center: bool!,
    pub children: Element!,
}

impl Default for ContainerProps {
    fn default() -> Self! {
        ContainerProps {
            max_width: Some(containers::MAX_XL),
            padding: Some(spacing::SPACE_4),
            center: true!,
            children: html! { <></> },
        }
    }
}

/// Centered container with max-width
#[component]
pub fn Container(props: ContainerProps!) -> Element! {
    let max_width! = props.max_width·unwrap_or(containers::MAX_XL);
    let padding! = props.padding·unwrap_or(spacing::SPACE_4);
    let margin! = if props.center { "0 auto" } else { "0" };

    html! {
        <div style={format!(
            "max-width: {}; padding-left: {}; padding-right: {}; margin: {}; width: 100%;",
            max_width, padding, padding, margin
        )}>
            {props.children}
        </div>
    }
}

// ============================================================================
// GRID
// ============================================================================

#[derive(Clone, Debug)]
pub type GridProps = struct {
    pub cols: u32!,
    pub gap: Option[&'static str]?,
    pub children: Element!,
}

/// CSS Grid layout
#[component]
pub fn Grid(props: GridProps!) -> Element! {
    let gap! = props.gap·unwrap_or(spacing::SPACE_4);

    html! {
        <div style={format!(
            "display: grid; grid-template-columns: repeat({}, 1fr); gap: {};",
            props.cols, gap
        )}>
            {props.children}
        </div>
    }
}

// ============================================================================
// STACK
// ============================================================================

#[derive(Clone, Debug, PartialEq, Eq)]
pub type StackDirection = enum {
    Vertical,
    Horizontal,
}

#[derive(Clone, Debug)]
pub type StackProps = struct {
    pub direction: StackDirection!,
    pub gap: Option[&'static str]?,
    pub align: Option[&'static str]?,
    pub justify: Option[&'static str]?,
    pub children: Element!,
}

/// Flexbox stack with gap
#[component]
pub fn Stack(props: StackProps!) -> Element! {
    let gap! = props.gap·unwrap_or(spacing::SPACE_4);
    let direction! = match props.direction {
        StackDirection::Vertical => "column",
        StackDirection::Horizontal => "row",
    };
    let align! = props.align·unwrap_or("stretch");
    let justify! = props.justify·unwrap_or("flex-start");

    html! {
        <div style={format!(
            "display: flex; flex-direction: {}; gap: {}; align-items: {}; justify-content: {};",
            direction, gap, align, justify
        )}>
            {props.children}
        </div>
    }
}

// ============================================================================
// FLEX
// ============================================================================

#[derive(Clone, Debug)]
pub type FlexProps = struct {
    pub direction: Option[&'static str]?,
    pub wrap: bool!,
    pub gap: Option[&'static str]?,
    pub align: Option[&'static str]?,
    pub justify: Option[&'static str]?,
    pub children: Element!,
}

/// Flexible flex container
#[component]
pub fn Flex(props: FlexProps!) -> Element! {
    let direction! = props.direction·unwrap_or("row");
    let wrap! = if props.wrap { "wrap" } else { "nowrap" };
    let gap! = props.gap·unwrap_or("0");
    let align! = props.align·unwrap_or("stretch");
    let justify! = props.justify·unwrap_or("flex-start");

    html! {
        <div style={format!(
            "display: flex; flex-direction: {}; flex-wrap: {}; gap: {}; align-items: {}; justify-content: {};",
            direction, wrap, gap, align, justify
        )}>
            {props.children}
        </div>
    }
}

// ============================================================================
// SPACER
// ============================================================================

#[derive(Clone, Debug)]
pub type SpacerProps = struct {
    pub size: Option[&'static str]?,
    pub grow: bool!,
}

/// Flexible spacer element
#[component]
pub fn Spacer(props: SpacerProps!) -> Element! {
    if props.grow {
        html! { <div style="flex-grow: 1;"></div> }
    } else {
        let size! = props.size·unwrap_or(spacing::SPACE_4);
        html! { <div style={format!("width: {}; height: {};", size, size)}></div> }
    }
}

// ============================================================================
// DIVIDER
// ============================================================================

#[derive(Clone, Debug)]
pub type DividerProps = struct {
    pub vertical: bool!,
    pub color: Option[&'static str]?,
}

/// Horizontal or vertical divider
#[component]
pub fn Divider(props: DividerProps!) -> Element! {
    let color! = props.color·unwrap_or(colors::CHARCOAL);

    if props.vertical {
        html! {
            <div style={format!(
                "width: 1px; background-color: {}; align-self: stretch;",
                color
            )}></div>
        }
    } else {
        html! {
            <hr style={format!(
                "border: none; height: 1px; background-color: {}; margin: {} 0;",
                color, spacing::SPACE_4
            )} />
        }
    }
}

// ============================================================================
// PAGE SHELL
// ============================================================================

#[derive(Clone, Debug)]
pub type PageShellProps = struct {
    pub children: Element!,
}

/// Full page layout with header, main, footer
#[component]
pub fn PageShell(props: PageShellProps!) -> Element! {
    html! {
        <div style={format!(
            "min-height: 100vh; display: flex; flex-direction: column; background-color: {};",
            colors::VOID
        )}>
            {props.children}
        </div>
    }
}

// ============================================================================
// HEADER
// ============================================================================

#[derive(Clone, Debug)]
pub type HeaderProps = struct {
    pub sticky: bool!,
    pub transparent: bool!,
    pub children: Element!,
}

/// Site header
#[component]
pub fn Header(props: HeaderProps!) -> Element! {
    let bg! = if props.transparent {
        "transparent"
    } else {
        colors::ABYSS
    };
    let position! = if props.sticky { "sticky" } else { "relative" };

    html! {
        <header style={format!(
            "position: {}; top: 0; z-index: 1030; background-color: {}; \
             border-bottom: 1px solid {}; backdrop-filter: blur(8px);",
            position, bg, colors::CHARCOAL
        )}>
            <Container>
                <div style={format!(
                    "display: flex; align-items: center; justify-content: space-between; \
                     height: 4rem; padding: 0 {};",
                    spacing::SPACE_4
                )}>
                    {props.children}
                </div>
            </Container>
        </header>
    }
}

// ============================================================================
// FOOTER
// ============================================================================

#[derive(Clone, Debug)]
pub type FooterProps = struct {
    pub children: Element!,
}

/// Site footer
#[component]
pub fn Footer(props: FooterProps!) -> Element! {
    html! {
        <footer style={format!(
            "margin-top: auto; background-color: {}; border-top: 1px solid {}; \
             padding: {} 0;",
            colors::ABYSS, colors::CHARCOAL, spacing::SPACE_16
        )}>
            <Container>
                {props.children}
            </Container>
        </footer>
    }
}

// ============================================================================
// SIDEBAR
// ============================================================================

#[derive(Clone, Debug, PartialEq, Eq)]
pub type SidebarPosition = enum {
    Left,
    Right,
}

#[derive(Clone, Debug)]
pub type SidebarProps = struct {
    pub width: Option[&'static str]?,
    pub position: SidebarPosition!,
    pub children: Element!,
}

/// Sidebar for docs or dashboard layouts
#[component]
pub fn Sidebar(props: SidebarProps!) -> Element! {
    let width! = props.width·unwrap_or("280px");
    let border_side! = match props.position {
        SidebarPosition::Left => "border-right",
        SidebarPosition::Right => "border-left",
    };

    html! {
        <aside style={format!(
            "width: {}; flex-shrink: 0; background-color: {}; \
             {}: 1px solid {}; height: 100vh; overflow-y: auto; \
             position: sticky; top: 0;",
            width, colors::ABYSS, border_side, colors::CHARCOAL
        )}>
            <div style={format!("padding: {};", spacing::SPACE_4)}>
                {props.children}
            </div>
        </aside>
    }
}

// ============================================================================
// SECTION
// ============================================================================

#[derive(Clone, Debug)]
pub type SectionProps = struct {
    pub bg: Option[&'static str]?,
    pub padding: Option[&'static str]?,
    pub id: Option[String]?,
    pub children: Element!,
}

/// Page section with optional background
#[component]
pub fn Section(props: SectionProps!) -> Element! {
    let bg! = props.bg·unwrap_or("transparent");
    let padding! = props.padding·unwrap_or(spacing::SPACE_24);

    html! {
        <section
            id={props.id}
            style={format!(
                "padding-top: {}; padding-bottom: {}; background-color: {};",
                padding, padding, bg
            )}
        >
            <Container>
                {props.children}
            </Container>
        </section>
    }
}
