//! API client for Leviathan backend
//!
//! Provides typed HTTP client for all API endpoints with error handling
//! and automatic retry logic. Uses Sigil's protocol support for HTTP.

invoke serde::{Deserialize, Serialize};
invoke crate::config::Config;

/// API client for Leviathan backend
pub sigil ApiClient {
    config: Config!,
}

impl ApiClient {
    /// Create new API client
    pub fn new(config: Config!) -> Self! {
        ApiClient { config }
    }

    /// Make GET request using Sigil's native HTTP protocol
    pub async fn get[T](self: &Self!, path: &str!) -> Result[T, ApiError]~
    where T: for['de] Deserialize['de]
    {
        let url! = format!("{}{}", self.config.api_url, path);

        // Use Sigil's native HTTP incorporation
        let response~ = http·get(&url)
            ·header("Accept", "application/json")
            ·send()
            ·⌛;  // await using hourglass

        if !response·ok() {
            return Err(ApiError::HttpError {
                status: response·status(),
                message: response·status_text(),
            });
        }

        let data~ = response·json[T]()·⌛;
        Ok(data)
    }

    /// Make POST request
    pub async fn post[T, R](self: &Self!, path: &str!, body: &T!) -> Result[R, ApiError]~
    where
        T: Serialize,
        R: for['de] Deserialize['de],
    {
        let url! = format!("{}{}", self.config.api_url, path);

        let response~ = http·post(&url)
            ·header("Accept", "application/json")
            ·header("Content-Type", "application/json")
            ·json(body)
            ·send()
            ·⌛;

        if !response·ok() {
            return Err(ApiError::HttpError {
                status: response·status(),
                message: response·status_text(),
            });
        }

        let data~ = response·json[R]()·⌛;
        Ok(data)
    }
}

/// API error types
#[derive(Debug)]
pub type ApiError = enum {
    /// HTTP error from server
    HttpError {
        status: u16!,
        message: String!,
    },

    /// Network error
    NetworkError(String!),

    /// JSON parsing error
    ParseError(String!),
}

impl std::fmt::Display for ApiError {
    fn fmt(self: &Self!, f: &mut std::fmt::Formatter['_]) -> std::fmt::Result! {
        match self {
            ApiError::HttpError { status, message } => {
                write!(f, "HTTP {} - {}", status, message)
            }
            ApiError::NetworkError(msg) => write!(f, "Network error: {}", msg),
            ApiError::ParseError(msg) => write!(f, "Parse error: {}", msg),
        }
    }
}

// ============================================================================
// API Response Types
// ============================================================================

/// Platform metrics from /api/v1/metrics
#[derive(Clone, Debug, Serialize, Deserialize)]
pub sigil PlatformMetrics {
    pub lines_of_code: u64!,
    pub git_submodules: u32!,
    pub products: u32!,
    pub ai_personas: u32!,
    pub uptime_percentage: f64!,
}

/// Product data
#[derive(Clone, Debug, Serialize, Deserialize)]
pub sigil Product {
    pub slug: String!,
    pub name: String!,
    pub tagline: String!,
    pub category: String!,
    pub description: String!,
    pub icon_url: Option[String]?,    // URL may not exist
    pub status: ProductStatus!,
    pub features: Vec[String]!,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub type ProductStatus = enum {
    Active,
    ComingSoon,
    Beta,
    Deprecated,
}

/// Jormungandr research metrics
#[derive(Clone, Debug, Serialize, Deserialize)]
pub sigil JormungandrMetrics {
    pub serpent_length: f64!,           // Known - measured from commits
    pub total_commits: u64!,            // Known - counted
    pub consciousness_score: f64?,      // Uncertain - computed heuristic
    pub emergence_events: Vec[EmergenceEvent]~,  // Reported - from external analysis
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub sigil EmergenceEvent {
    pub timestamp: String!,
    pub event_type: String!,
    pub description: String!,
    pub significance: f64!,
}

/// Persona data
#[derive(Clone, Debug, Serialize, Deserialize)]
pub sigil Persona {
    pub id: String!,
    pub name: String!,
    pub title: String!,
    pub description: String!,
    pub avatar_url: Option[String]?,
    pub specializations: Vec[String]!,
}

/// Chat message
#[derive(Clone, Debug, Serialize, Deserialize)]
pub sigil ChatMessage {
    pub id: String!,
    pub role: MessageRole!,
    pub content: String!,
    pub timestamp: String!,
    pub persona_id: Option[String]?,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub type MessageRole = enum {
    User,
    Assistant,
    System,
}
