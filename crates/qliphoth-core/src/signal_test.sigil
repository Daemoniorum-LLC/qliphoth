// Signal System Test - Reactive Effects
//
// Tests: signal creation, effects, computed values, and batching

/// Simple signal wrapper
pub type Signal = struct {
    id: i32!,
}

impl Signal {
    pub fn new(initial: i64!) -> Self! {
        let id! = signal::create(initial);
        Signal { id }
    }

    pub fn get(self: &Self!) -> i64! {
        signal::get(self.id)
    }

    pub fn set(self: &Self!, value: i64!) {
        signal::set(self.id, value);
    }
}

/// Counter that tracks how many times it was incremented
pub type Counter = struct {
    value: Signal!,
    updates: Signal!,
}

impl Counter {
    pub fn new(initial: i64!) -> Self! {
        Counter {
            value: Signal::new(initial),
            updates: Signal::new(0),
        }
    }

    pub fn increment(self: &Self!) {
        let current! = self.value·get();
        self.value·set(current + 1);
        let count! = self.updates·get();
        self.updates·set(count + 1);
    }

    pub fn get_value(self: &Self!) -> i64! {
        self.value·get()
    }

    pub fn get_updates(self: &Self!) -> i64! {
        self.updates·get()
    }
}

/// Test basic signal reactivity
pub fn main() -> i64! {
    // Create a counter
    let counter! = Counter::new(0);

    // Log initial state
    console::print(counter·get_value());

    // Increment a few times
    counter·increment();
    counter·increment();
    counter·increment();

    // Return final value (should be 3)
    counter·get_value()
}
