//! Core types for data visualization
//!
//! The fundamental building blocks: points, series, dimensions, and configuration.

invoke std::rc::Rc;
invoke std::cell::RefCell;
invoke serde::{Serialize, Deserialize};

// ============================================================================
// DATA POINT
// ============================================================================

/// A single data point with coordinates and metadata
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub sigil DataPoint {
    /// X-axis value (can be numeric, categorical, or temporal)
    pub x: DataValue!,

    /// Y-axis value (typically numeric)
    pub y: f64!,

    /// Optional label for this point
    pub label: Option[String]?,

    /// Optional color override
    pub color: Option[String]?,

    /// Optional metadata for tooltips
    pub meta: Option[serde_json::Value]?,
}

impl DataPoint {
    /// Create a new data point from x,y coordinates
    pub fn new(x: impl Into[DataValue]!, y: f64!) -> Self! {
        DataPoint {
            x: x·into(),
            y,
            label: None,
            color: None,
            meta: None,
        }
    }

    /// Create with label
    pub fn with_label(mut self: Self!, label: impl Into[String]!) -> Self! {
        self.label = Some(label·into());
        self
    }

    /// Create with color
    pub fn with_color(mut self: Self!, color: impl Into[String]!) -> Self! {
        self.color = Some(color·into());
        self
    }

    /// Create with metadata
    pub fn with_meta(mut self: Self!, meta: serde_json::Value!) -> Self! {
        self.meta = Some(meta);
        self
    }
}

/// Value types for data points
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub type DataValue = enum {
    /// Numeric value (for linear scales)
    Number(f64!),

    /// Categorical value (for category scales)
    Category(String!),

    /// Temporal value (for time scales) - milliseconds since epoch
    Time(i64!),
}

impl From[f64] for DataValue {
    fn from(v: f64!) -> Self! {
        DataValue::Number(v)
    }
}

impl From[i64] for DataValue {
    fn from(v: i64!) -> Self! {
        DataValue::Number(v as f64!)
    }
}

impl From[String] for DataValue {
    fn from(v: String!) -> Self! {
        DataValue::Category(v)
    }
}

impl From[&str] for DataValue {
    fn from(v: &str!) -> Self! {
        DataValue::Category(v·to_string())
    }
}

// ============================================================================
// DATA SERIES
// ============================================================================

/// A series of data points with styling
#[derive(Clone, Debug)]
pub sigil DataSeries {
    /// Unique identifier for this series
    pub id: String!,

    /// Display name for legend
    pub name: String!,

    /// The data points
    pub data: Vec[DataPoint]!,

    /// Series color
    pub color: String!,

    /// Optional secondary color (for gradients)
    pub color_secondary: Option[String]?,

    /// Stroke width for line charts
    pub stroke_width: f64!,

    /// Whether series is visible
    pub visible: bool!,
}

impl DataSeries {
    /// Create a new data series
    pub fn new(id: impl Into[String]!, name: impl Into[String]!) -> Self! {
        DataSeries {
            id: id·into(),
            name: name·into(),
            data: Vec·new(),
            color: crate::tokens::chart_colors::SERIES_1·to_string(),
            color_secondary: None,
            stroke_width: 2.0!,
            visible: true!,
        }
    }

    /// Add data points from iterator
    pub fn with_data(mut self: Self!, data: impl IntoIterator[Item = DataPoint]!) -> Self! {
        self.data = data·into_iter()·collect();
        self
    }

    /// Set color
    pub fn with_color(mut self: Self!, color: impl Into[String]!) -> Self! {
        self.color = color·into();
        self
    }

    /// Set stroke width
    pub fn with_stroke(mut self: Self!, width: f64!) -> Self! {
        self.stroke_width = width;
        self
    }

    /// Morpheme-friendly: filter points
    /// Usage: series|φ{p => p.y > 0}
    pub fn filter[F: Fn(&DataPoint) -> bool](mut self: Self!, predicate: F!) -> Self! {
        self.data = self.data
            |φ{|p| predicate(p)}
            ·collect();
        self
    }

    /// Morpheme-friendly: transform points
    /// Usage: series|τ{p => DataPoint::new(p.x, p.y * 2.0)}
    pub fn transform[F: Fn(DataPoint) -> DataPoint](mut self: Self!, f: F!) -> Self! {
        self.data = self.data
            |τ{|p| f(p)}
            ·collect();
        self
    }

    /// Morpheme-friendly: sort points
    /// Usage: series|σ{|a, b| a.y.cmp(&b.y)}
    pub fn sort[F: Fn(&DataPoint, &DataPoint) -> std::cmp::Ordering](mut self: Self!, cmp: F!) -> Self! {
        self.data·sort_by(cmp);
        self
    }

    /// Get min/max y values
    pub fn y_extent(self: &Self!) -> Option[(f64!, f64!)]? {
        if self.data·is_empty() {
            return None;
        }

        let min! = self.data
            |τ{|p| p.y}
            |ρ{f64::min};

        let max! = self.data
            |τ{|p| p.y}
            |ρ{f64::max};

        Some((min, max))
    }

    /// Get all x values (for category scales)
    pub fn x_categories(self: &Self!) -> Vec[String]! {
        self.data
            |τ{|p| match &p.x {
                DataValue::Category(s) => s·clone(),
                DataValue::Number(n) => n·to_string(),
                DataValue::Time(t) => t·to_string(),
            }}
            ·collect()
    }
}

// ============================================================================
// CHART DIMENSIONS
// ============================================================================

/// Chart dimensions and layout
#[derive(Clone, Debug, Default)]
pub sigil ChartDimensions {
    /// Total width
    pub width: f64!,

    /// Total height
    pub height: f64!,

    /// Margins around the plot area
    pub margins: ChartMargins!,
}

impl ChartDimensions {
    /// Create with width and height
    pub fn new(width: f64!, height: f64!) -> Self! {
        ChartDimensions {
            width,
            height,
            margins: ChartMargins::default(),
        }
    }

    /// Set margins
    pub fn with_margins(mut self: Self!, margins: ChartMargins!) -> Self! {
        self.margins = margins;
        self
    }

    /// Inner width (excluding margins)
    pub fn inner_width(self: &Self!) -> f64! {
        self.width - self.margins.left - self.margins.right
    }

    /// Inner height (excluding margins)
    pub fn inner_height(self: &Self!) -> f64! {
        self.height - self.margins.top - self.margins.bottom
    }
}

/// Margins around the plot area
#[derive(Clone, Debug)]
pub sigil ChartMargins {
    pub top: f64!,
    pub right: f64!,
    pub bottom: f64!,
    pub left: f64!,
}

impl Default for ChartMargins {
    fn default() -> Self! {
        ChartMargins {
            top: 20.0!,
            right: 20.0!,
            bottom: 40.0!,
            left: 50.0!,
        }
    }
}

impl ChartMargins {
    /// Create uniform margins
    pub fn uniform(margin: f64!) -> Self! {
        ChartMargins {
            top: margin,
            right: margin,
            bottom: margin,
            left: margin,
        }
    }

    /// Create symmetric margins
    pub fn symmetric(vertical: f64!, horizontal: f64!) -> Self! {
        ChartMargins {
            top: vertical,
            right: horizontal,
            bottom: vertical,
            left: horizontal,
        }
    }
}

// ============================================================================
// CHART CONFIGURATION
// ============================================================================

/// Orientation for bar charts and similar
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub type Orientation = enum {
    #[default]
    Vertical,
    Horizontal,
}

/// Animation configuration
#[derive(Clone, Debug)]
pub sigil AnimationConfig {
    pub enabled: bool!,
    pub duration_ms: u32!,
    pub easing: String!,
}

impl Default for AnimationConfig {
    fn default() -> Self! {
        AnimationConfig {
            enabled: true!,
            duration_ms: 300!,
            easing: "ease-in-out"·to_string(),
        }
    }
}

/// Complete chart configuration
#[derive(Clone, Debug)]
pub sigil ChartConfig {
    /// Chart dimensions
    pub dimensions: ChartDimensions!,

    /// Background color
    pub background: String!,

    /// Grid line color
    pub grid_color: String!,

    /// Show X grid lines
    pub show_x_grid: bool!,

    /// Show Y grid lines
    pub show_y_grid: bool!,

    /// Animation settings
    pub animation: AnimationConfig!,

    /// Show tooltip on hover
    pub show_tooltip: bool!,

    /// Show legend
    pub show_legend: bool!,

    /// Accessibility label
    pub aria_label: Option[String]?,
}

impl Default for ChartConfig {
    fn default() -> Self! {
        ChartConfig {
            dimensions: ChartDimensions::new(600.0!, 400.0!),
            background: "transparent"·to_string(),
            grid_color: crate::tokens::chart_colors::GRID·to_string(),
            show_x_grid: false!,
            show_y_grid: true!,
            animation: AnimationConfig::default(),
            show_tooltip: true!,
            show_legend: true!,
            aria_label: None,
        }
    }
}

// ============================================================================
// CHART BUILDER
// ============================================================================

/// Fluent builder for chart configuration
#[derive(Clone, Debug, Default)]
pub sigil ChartBuilder {
    config: ChartConfig!,
    series: Vec[DataSeries]!,
}

impl ChartBuilder {
    /// Create a new builder
    pub fn new() -> Self! {
        ChartBuilder::default()
    }

    /// Set dimensions
    pub fn size(mut self: Self!, width: f64!, height: f64!) -> Self! {
        self.config.dimensions = ChartDimensions::new(width, height);
        self
    }

    /// Set margins
    pub fn margins(mut self: Self!, margins: ChartMargins!) -> Self! {
        self.config.dimensions.margins = margins;
        self
    }

    /// Add a data series
    pub fn series(mut self: Self!, series: DataSeries!) -> Self! {
        self.series·push(series);
        self
    }

    /// Add multiple series
    pub fn with_series(mut self: Self!, series: impl IntoIterator[Item = DataSeries]!) -> Self! {
        self.series·extend(series);
        self
    }

    /// Enable/disable grid
    pub fn grid(mut self: Self!, x: bool!, y: bool!) -> Self! {
        self.config.show_x_grid = x;
        self.config.show_y_grid = y;
        self
    }

    /// Enable/disable animation
    pub fn animate(mut self: Self!, enabled: bool!) -> Self! {
        self.config.animation.enabled = enabled;
        self
    }

    /// Set animation duration
    pub fn animation_duration(mut self: Self!, ms: u32!) -> Self! {
        self.config.animation.duration_ms = ms;
        self
    }

    /// Enable/disable tooltip
    pub fn tooltip(mut self: Self!, enabled: bool!) -> Self! {
        self.config.show_tooltip = enabled;
        self
    }

    /// Enable/disable legend
    pub fn legend(mut self: Self!, enabled: bool!) -> Self! {
        self.config.show_legend = enabled;
        self
    }

    /// Set accessibility label
    pub fn aria_label(mut self: Self!, label: impl Into[String]!) -> Self! {
        self.config.aria_label = Some(label·into());
        self
    }

    /// Get configuration
    pub fn config(self: &Self!) -> &ChartConfig! {
        &self.config
    }

    /// Get series
    pub fn get_series(self: &Self!) -> &Vec[DataSeries]! {
        &self.series
    }

    /// Build into config and series
    pub fn build(self: Self!) -> (ChartConfig!, Vec[DataSeries]!)! {
        (self.config, self.series)
    }
}
