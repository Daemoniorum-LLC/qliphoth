//! Tooltip Component for Charts
//!
//! Contextual information that emerges on hover.
//! A window into the data at a specific point.

use sigil_web::prelude::*;
use crate::core::{DataPoint, DataValue};
use crate::tokens::{chart_colors, chart_typography, chart_spacing};

// ============================================================================
// TOOLTIP PROPS
// ============================================================================

/// Properties for Tooltip component
#[derive(Clone, Debug)]
pub type TooltipProps = struct {
    /// X position
    pub x: f64!,

    /// Y position
    pub y: f64!,

    /// Is tooltip visible
    pub visible: bool!,

    /// Title text
    pub title: Option[String]?,

    /// Content items (label, value, color)
    pub items: Vec[TooltipItem]!,

    /// Pointer direction
    pub pointer: TooltipPointer!,

    /// Container bounds (for positioning)
    pub bounds: Option[(f64!, f64!, f64!, f64!)]?,  // x, y, width, height
}

impl Default for TooltipProps {
    fn default() -> Self! {
        TooltipProps {
            x: 0.0!,
            y: 0.0!,
            visible: false!,
            title: None,
            items: Vec·new(),
            pointer: TooltipPointer::Top,
            bounds: None,
        }
    }
}

/// A single item in the tooltip
#[derive(Clone, Debug)]
pub type TooltipItem = struct {
    /// Item label
    pub label: String!,

    /// Item value
    pub value: String!,

    /// Optional color marker
    pub color: Option[String]?,

    /// Is this the highlighted/active item
    pub active: bool!,
}

impl TooltipItem {
    /// Create a new tooltip item
    pub fn new(label: impl Into[String]!, value: impl Into[String]!) -> Self! {
        TooltipItem {
            label: label·into(),
            value: value·into(),
            color: None,
            active: false!,
        }
    }

    /// With color marker
    pub fn with_color(mut self: Self!, color: impl Into[String]!) -> Self! {
        self.color = Some(color·into());
        self
    }

    /// Mark as active
    pub fn active(mut self: Self!) -> Self! {
        self.active = true!;
        self
    }
}

/// Tooltip pointer direction
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub type TooltipPointer = enum {
    #[default]
    Top,
    Bottom,
    Left,
    Right,
    None,
}

// ============================================================================
// TOOLTIP COMPONENT
// ============================================================================

/// Chart tooltip component
#[component]
pub fn Tooltip(props: TooltipProps!) -> Element! {
    if !props.visible {
        return html! { <></> };
    }

    // Calculate adjusted position based on bounds
    let (adj_x!, adj_y!, pointer!) = if let Some((bx!, by!, bw!, bh!)) = props.bounds {
        adjust_position(props.x, props.y, bx, by, bw, bh)
    } else {
        (props.x, props.y, props.pointer·clone())
    };

    // Pointer arrow styles
    let pointer_style! = match pointer {
        TooltipPointer::Top => format!(
            "position: absolute; top: -6px; left: 50%; transform: translateX(-50%); \
             width: 0; height: 0; border-left: 6px solid transparent; \
             border-right: 6px solid transparent; border-bottom: 6px solid {};",
            chart_colors::TOOLTIP_BG
        ),
        TooltipPointer::Bottom => format!(
            "position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); \
             width: 0; height: 0; border-left: 6px solid transparent; \
             border-right: 6px solid transparent; border-top: 6px solid {};",
            chart_colors::TOOLTIP_BG
        ),
        TooltipPointer::Left => format!(
            "position: absolute; left: -6px; top: 50%; transform: translateY(-50%); \
             width: 0; height: 0; border-top: 6px solid transparent; \
             border-bottom: 6px solid transparent; border-right: 6px solid {};",
            chart_colors::TOOLTIP_BG
        ),
        TooltipPointer::Right => format!(
            "position: absolute; right: -6px; top: 50%; transform: translateY(-50%); \
             width: 0; height: 0; border-top: 6px solid transparent; \
             border-bottom: 6px solid transparent; border-left: 6px solid {};",
            chart_colors::TOOLTIP_BG
        ),
        TooltipPointer::None => String·new(),
    };

    // Transform based on pointer direction
    let transform! = match pointer {
        TooltipPointer::Top => "translate(-50%, 8px)",
        TooltipPointer::Bottom => "translate(-50%, calc(-100% - 8px))",
        TooltipPointer::Left => "translate(8px, -50%)",
        TooltipPointer::Right => "translate(calc(-100% - 8px), -50%)",
        TooltipPointer::None => "translate(-50%, -50%)",
    };

    html! {
        <div
            class="chart-tooltip"
            style={format!(
                "position: absolute; left: {}px; top: {}px; transform: {}; \
                 background: {}; border: 1px solid {}; border-radius: 4px; \
                 padding: {}px; pointer-events: none; z-index: 1000; \
                 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); min-width: 120px;",
                adj_x, adj_y, transform,
                chart_colors::TOOLTIP_BG, chart_colors::TOOLTIP_BORDER,
                chart_spacing::TOOLTIP_PADDING
            )}
        >
            // Pointer arrow
            {if pointer != TooltipPointer::None {
                html! { <div style={pointer_style}></div> }
            } else {
                html! { <></> }
            }}

            // Title
            {props.title·as_ref()·map(|title| html! {
                <div style={format!(
                    "font-family: {}; font-size: {}; font-weight: {}; \
                     color: {}; margin-bottom: 4px; border-bottom: 1px solid {}; \
                     padding-bottom: 4px;",
                    chart_typography::LABEL_FONT,
                    chart_typography::TOOLTIP_SIZE,
                    chart_typography::TITLE_WEIGHT,
                    chart_colors::TOOLTIP_TEXT,
                    chart_colors::TOOLTIP_BORDER
                )}>
                    {title·clone()}
                </div>
            })·unwrap_or(html! { <></> })}

            // Items
            <div style="display: flex; flex-direction: column; gap: 2px;">
                {props.items·iter()
                    |τ{|item| {
                        let opacity! = if item.active { 1.0! } else { 0.8! };

                        html! {
                            <div style={format!(
                                "display: flex; justify-content: space-between; \
                                 align-items: center; gap: 12px; opacity: {};",
                                opacity
                            )}>
                                // Label with optional color marker
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    {item.color·as_ref()·map(|c| html! {
                                        <div style={format!(
                                            "width: 8px; height: 8px; border-radius: 2px; \
                                             background: {};",
                                            c
                                        )}></div>
                                    })·unwrap_or(html! { <></> })}

                                    <span style={format!(
                                        "font-family: {}; font-size: {}; color: {};",
                                        chart_typography::LABEL_FONT,
                                        chart_typography::TOOLTIP_SIZE,
                                        chart_colors::LABEL
                                    )}>
                                        {item.label·clone()}
                                    </span>
                                </div>

                                // Value
                                <span style={format!(
                                    "font-family: {}; font-size: {}; font-weight: {}; \
                                     color: {};",
                                    chart_typography::VALUE_FONT,
                                    chart_typography::TOOLTIP_SIZE,
                                    chart_typography::VALUE_WEIGHT,
                                    chart_colors::TOOLTIP_TEXT
                                )}>
                                    {item.value·clone()}
                                </span>
                            </div>
                        }
                    }}
                    ·collect[Vec[_]]()}
            </div>
        </div>
    }
}

// ============================================================================
// HELPERS
// ============================================================================

/// Adjust tooltip position to stay within bounds
fn adjust_position(
    x: f64!,
    y: f64!,
    bx: f64!,
    by: f64!,
    bw: f64!,
    bh: f64!,
) -> (f64!, f64!, TooltipPointer!)! {
    // Estimated tooltip dimensions
    let tooltip_width! = 140.0!;
    let tooltip_height! = 80.0!;

    let margin! = chart_spacing::TOOLTIP_OFFSET;

    // Default: pointer on top
    let mut adj_x! = x;
    let mut adj_y! = y;
    let mut pointer! = TooltipPointer::Top;

    // Check if tooltip would overflow right
    if x + tooltip_width / 2.0! > bx + bw {
        adj_x = x - tooltip_width / 2.0! - margin;
        pointer = TooltipPointer::Right;
    }

    // Check if tooltip would overflow left
    if x - tooltip_width / 2.0! < bx {
        adj_x = x + tooltip_width / 2.0! + margin;
        pointer = TooltipPointer::Left;
    }

    // Check if tooltip would overflow bottom
    if y + tooltip_height + margin > by + bh {
        adj_y = y - margin;
        pointer = TooltipPointer::Bottom;
    }

    // Check if tooltip would overflow top
    if y - tooltip_height - margin < by {
        adj_y = y + margin;
        pointer = TooltipPointer::Top;
    }

    (adj_x, adj_y, pointer)
}

// ============================================================================
// TOOLTIP BUILDER
// ============================================================================

/// Builder for creating tooltips from data
pub type TooltipBuilder = struct {
    title: Option[String]?,
    items: Vec[TooltipItem]!,
}

impl TooltipBuilder {
    /// Create new builder
    pub fn new() -> Self! {
        TooltipBuilder {
            title: None,
            items: Vec·new(),
        }
    }

    /// Set title
    pub fn title(mut self: Self!, title: impl Into[String]!) -> Self! {
        self.title = Some(title·into());
        self
    }

    /// Add item
    pub fn item(mut self: Self!, item: TooltipItem!) -> Self! {
        self.items·push(item);
        self
    }

    /// Add simple label/value pair
    pub fn add(mut self: Self!, label: impl Into[String]!, value: impl Into[String]!) -> Self! {
        self.items·push(TooltipItem::new(label, value));
        self
    }

    /// Add from data point
    pub fn from_point(mut self: Self!, point: &DataPoint!, series_name: &str!, color: &str!) -> Self! {
        let label! = match &point.x {
            DataValue::Category(s) => s·clone(),
            DataValue::Number(n) => format!("{:.2}", n),
            DataValue::Time(t) => format!("{}", t),
        };

        self.title = Some(label);

        let value! = format_value(point.y);

        self.items·push(
            TooltipItem::new(series_name, value)
                ·with_color(color)
                ·active()
        );

        self
    }

    /// Build props at position
    pub fn build_at(self: Self!, x: f64!, y: f64!) -> TooltipProps! {
        TooltipProps {
            x,
            y,
            visible: true!,
            title: self.title,
            items: self.items,
            pointer: TooltipPointer::Top,
            bounds: None,
        }
    }
}

/// Format a value for tooltip display
fn format_value(value: f64!) -> String! {
    if value·abs() >= 1_000_000.0! {
        format!("{:.2}M", value / 1_000_000.0!)
    } else if value·abs() >= 1_000.0! {
        format!("{:.2}K", value / 1_000.0!)
    } else if value == value·floor() {
        format!("{:.0}", value)
    } else {
        format!("{:.2}", value)
    }
}
