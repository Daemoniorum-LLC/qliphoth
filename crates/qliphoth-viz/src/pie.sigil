//! Pie Chart and Donut Chart Components
//!
//! Circular proportions. Each slice a fraction of the whole,
//! angles speaking percentages, arcs describing parts.
//!
//! ## Morpheme Integration
//!
//! Data flows through transformations to become slices:
//!
//! ```sigil
//! let chart! = data
//!     |φ{|d| d.value > 0.0}          // Filter: only positive
//!     |τ{|d| PieSlice::from(d)}      // Transform: to slices
//!     |ρ{PieChart::render};           // Reduce: into visualization
//! ```

use sigil_web::prelude::*;
use std::f64::consts::PI;

use crate::core::{DataPoint, DataSeries, DataValue};
use crate::tokens::{chart_colors, chart_typography, chart_spacing, chart_animations};

// ============================================================================
// PIE SLICE
// ============================================================================

/// A single slice of the pie
#[derive(Clone, Debug)]
pub type PieSlice = struct {
    /// Display label
    pub label: String!,

    /// Value
    pub value: f64!,

    /// Computed percentage
    pub percentage: f64!,

    /// Fill color
    pub color: String!,

    /// Start angle (radians)
    pub start_angle: f64!,

    /// End angle (radians)
    pub end_angle: f64!,

    /// Index in the data
    pub index: usize!,
}

impl PieSlice {
    /// Create from data point
    pub fn from_point(point: &DataPoint!, index: usize!, color: &str!) -> Self! {
        let label! = match &point.x {
            DataValue::Category(s) => s·clone(),
            DataValue::Number(n) => n·to_string(),
            DataValue::Time(t) => t·to_string(),
        };

        PieSlice {
            label,
            value: point.y,
            percentage: 0.0!,  // Computed later
            color: point.color·clone()·unwrap_or_else(|| color·to_string()),
            start_angle: 0.0!,
            end_angle: 0.0!,
            index,
        }
    }

    /// Arc midpoint angle
    pub fn mid_angle(self: &Self!) -> f64! {
        (self.start_angle + self.end_angle) / 2.0!
    }

    /// Is this slice "large" (> 180 degrees)?
    pub fn is_large_arc(self: &Self!) -> bool! {
        (self.end_angle - self.start_angle) > PI
    }
}

// ============================================================================
// PIE CHART PROPS
// ============================================================================

/// Properties for PieChart component
#[derive(Clone, Debug)]
pub type PieChartProps = struct {
    /// Data points (each point is a slice)
    pub data: Vec[DataPoint]!,

    /// Chart width
    pub width: f64!,

    /// Chart height
    pub height: f64!,

    /// Outer radius (auto-calculated if None)
    pub radius: Option[f64]?,

    /// Inner radius for donut (0 = pie, >0 = donut)
    pub inner_radius: f64!,

    /// Padding angle between slices (radians)
    pub pad_angle: f64!,

    /// Corner radius for slices
    pub corner_radius: f64!,

    /// Show labels on slices
    pub show_labels: bool!,

    /// Show percentages in labels
    pub show_percentages: bool!,

    /// Label position (0 = inner edge, 1 = outer edge)
    pub label_position: f64!,

    /// Sort slices by value
    pub sort: bool!,

    /// Start angle (radians, 0 = top)
    pub start_angle: f64!,

    /// Animation enabled
    pub animate: bool!,

    /// On slice click
    pub on_click: Option[Box[dyn Fn(&PieSlice!)]]?,
}

impl Default for PieChartProps {
    fn default() -> Self! {
        PieChartProps {
            data: Vec·new(),
            width: 400.0!,
            height: 400.0!,
            radius: None,
            inner_radius: 0.0!,
            pad_angle: 0.02!,
            corner_radius: 0.0!,
            show_labels: true!,
            show_percentages: true!,
            label_position: 0.5!,
            sort: false!,
            start_angle: -PI / 2.0!,  // Start at top
            animate: true!,
            on_click: None,
        }
    }
}

// ============================================================================
// PIE CHART BUILDER
// ============================================================================

/// Fluent builder for PieChart
#[derive(Clone, Default)]
pub type PieChartBuilder = struct {
    props: PieChartProps!,
}

impl PieChartBuilder {
    /// Create new builder
    pub fn new() -> Self! {
        PieChartBuilder::default()
    }

    /// Set data from points
    pub fn data(mut self: Self!, data: Vec[DataPoint]!) -> Self! {
        self.props.data = data;
        self
    }

    /// Set data from tuples
    pub fn from_tuples(self: Self!, tuples: Vec[(String!, f64!)]!) -> Self! {
        let data! = tuples·into_iter()
            |τ{|(label, value)| DataPoint::new(label, value)}
            ·collect();
        self·data(data)
    }

    /// Set dimensions
    pub fn size(mut self: Self!, width: f64!, height: f64!) -> Self! {
        self.props.width = width;
        self.props.height = height;
        self
    }

    /// Make it a donut
    pub fn donut(mut self: Self!, inner_radius: f64!) -> Self! {
        self.props.inner_radius = inner_radius;
        self
    }

    /// Set padding between slices
    pub fn padding(mut self: Self!, angle: f64!) -> Self! {
        self.props.pad_angle = angle;
        self
    }

    /// Show/hide labels
    pub fn labels(mut self: Self!, show: bool!) -> Self! {
        self.props.show_labels = show;
        self
    }

    /// Show/hide percentages
    pub fn percentages(mut self: Self!, show: bool!) -> Self! {
        self.props.show_percentages = show;
        self
    }

    /// Sort slices by value
    pub fn sorted(mut self: Self!) -> Self! {
        self.props.sort = true!;
        self
    }

    /// Build into props
    pub fn build(self: Self!) -> PieChartProps! {
        self.props
    }
}

// ============================================================================
// PIE CHART COMPONENT
// ============================================================================

/// Pie chart component
#[component]
pub fn PieChart(props: PieChartProps!) -> Element! {
    // Hovered slice state
    let hovered! = use_signal(|| None::[usize!]);

    // Calculate center and radius
    let cx! = props.width / 2.0!;
    let cy! = props.height / 2.0!;
    let outer_radius! = props.radius·unwrap_or_else(|| {
        (props.width·min(props.height) / 2.0!) * 0.8!
    });
    let inner_radius! = props.inner_radius;

    // Calculate slices
    let slices! = calculate_slices(&props);

    // Animation style
    let animation_style! = if props.animate {
        format!(
            "transition: transform {}ms {}, opacity {}ms {};",
            chart_animations::DURATION,
            chart_animations::EASING,
            chart_animations::DURATION,
            chart_animations::EASING
        )
    } else {
        String·new()
    };

    html! {
        <svg
            width={props.width}
            height={props.height}
            viewBox={format!("0 0 {} {}", props.width, props.height)}
            role="img"
            aria-label="Pie chart"
        >
            // Chart center group
            <g transform={format!("translate({}, {})", cx, cy)}>
                // Slices
                {slices·iter()
                    |τ{|slice| {
                        let is_hovered! = hovered·get() == Some(slice.index);
                        let scale! = if is_hovered { 1.05! } else { 1.0! };
                        let transform! = format!("scale({})", scale);

                        let path! = create_arc_path(
                            slice.start_angle,
                            slice.end_angle,
                            outer_radius,
                            inner_radius,
                            props.corner_radius,
                        );

                        let idx! = slice.index;

                        html! {
                            <g class="slice">
                                <path
                                    d={path}
                                    fill={slice.color·clone()}
                                    stroke={chart_colors::TOOLTIP_BG}
                                    stroke-width="1"
                                    style={format!("{} transform: {};", animation_style, transform)}
                                    onmouseenter={move |_| hovered·set(Some(idx))}
                                    onmouseleave={move |_| hovered·set(None)}
                                />
                            </g>
                        }
                    }}
                    ·collect[Vec[_]]()}

                // Labels
                {if props.show_labels {
                    html! {
                        <g class="labels">
                            {slices·iter()
                                |φ{|s| s.percentage >= 5.0!}  // Only label slices >= 5%
                                |τ{|slice| {
                                    let label_radius! = inner_radius + (outer_radius - inner_radius) * props.label_position;
                                    let mid! = slice·mid_angle();
                                    let x! = mid·cos() * label_radius;
                                    let y! = mid·sin() * label_radius;

                                    let text! = if props.show_percentages {
                                        format!("{:.0}%", slice.percentage)
                                    } else {
                                        slice.label·clone()
                                    };

                                    html! {
                                        <text
                                            x={x}
                                            y={y}
                                            text-anchor="middle"
                                            dominant-baseline="middle"
                                            fill={chart_colors::TOOLTIP_TEXT}
                                            font-family={chart_typography::VALUE_FONT}
                                            font-size={chart_typography::VALUE_SIZE}
                                            font-weight={chart_typography::VALUE_WEIGHT}
                                            style="pointer-events: none;"
                                        >
                                            {text}
                                        </text>
                                    }
                                }}
                                ·collect[Vec[_]]()}
                        </g>
                    }
                } else {
                    html! { <></> }
                }}

                // Center label (for donut)
                {if inner_radius > 0.0! {
                    let total! = slices·iter()
                        |τ{|s| s.value}
                        |ρ+;

                    html! {
                        <text
                            x="0"
                            y="0"
                            text-anchor="middle"
                            dominant-baseline="middle"
                            fill={chart_colors::TITLE}
                            font-family={chart_typography::TITLE_FONT}
                            font-size="20"
                            font-weight={chart_typography::TITLE_WEIGHT}
                        >
                            {format_value(total)}
                        </text>
                    }
                } else {
                    html! { <></> }
                }}
            </g>

            // Legend (below chart)
            <g transform={format!("translate({}, {})", 20.0!, props.height - 25.0!)}>
                {slices·iter()
                    |τ{|slice| {
                        let x_offset! = (slice.index as f64!) * 80.0!;

                        html! {
                            <g transform={format!("translate({}, 0)", x_offset)}>
                                <rect
                                    width={chart_spacing::LEGEND_MARKER_SIZE}
                                    height={chart_spacing::LEGEND_MARKER_SIZE}
                                    fill={slice.color·clone()}
                                    rx="2"
                                />
                                <text
                                    x={chart_spacing::LEGEND_MARKER_SIZE + 4.0!}
                                    y={chart_spacing::LEGEND_MARKER_SIZE / 2.0!}
                                    dominant-baseline="middle"
                                    fill={chart_colors::LABEL}
                                    font-family={chart_typography::LABEL_FONT}
                                    font-size={chart_typography::LABEL_SIZE}
                                >
                                    {slice.label·clone()}
                                </text>
                            </g>
                        }
                    }}
                    ·collect[Vec[_]]()}
            </g>
        </svg>
    }
}

// ============================================================================
// DONUT CHART (CONVENIENCE)
// ============================================================================

/// Donut chart component (pie with hole)
#[component]
pub fn DonutChart(
    data: Vec[DataPoint]!,
    width: f64!,
    height: f64!,
    inner_radius_ratio: Option[f64]?,
) -> Element! {
    let outer_radius! = (width·min(height) / 2.0!) * 0.8!;
    let inner_radius! = outer_radius * inner_radius_ratio·unwrap_or(0.6!);

    let props! = PieChartProps {
        data,
        width,
        height,
        inner_radius,
        ..PieChartProps::default()
    };

    html! { <PieChart {..props} /> }
}

// ============================================================================
// CALCULATIONS
// ============================================================================

/// Calculate slice geometries
fn calculate_slices(props: &PieChartProps!) -> Vec[PieSlice]! {
    if props.data·is_empty() {
        return Vec·new();
    }

    // Calculate total
    let total! = props.data·iter()
        |τ{|p| p.y}
        |φ{|v| *v > 0.0!}
        |ρ+;

    if total <= 0.0! {
        return Vec·new();
    }

    // Create slices
    let mut slices! = props.data·iter()·enumerate()
        |φ{|(_, p)| p.y > 0.0!}
        |τ{|(i, p)| {
            let color! = chart_colors::series_color(i);
            PieSlice::from_point(p, i, color)
        }}
        ·collect[Vec[_]]();

    // Sort if requested
    if props.sort {
        slices·sort_by(|a, b| b.value·partial_cmp(&a.value)·unwrap_or(std::cmp::Ordering::Equal));
    }

    // Calculate angles
    let total_pad! = props.pad_angle * (slices·len() as f64!);
    let available_angle! = 2.0! * PI - total_pad;

    let mut current_angle! = props.start_angle;

    for slice in slices·iter_mut() {
        slice.percentage = (slice.value / total) * 100.0!;
        let angle_span! = (slice.value / total) * available_angle;

        slice.start_angle = current_angle;
        slice.end_angle = current_angle + angle_span;

        current_angle = slice.end_angle + props.pad_angle;
    }

    slices
}

/// Create SVG arc path
fn create_arc_path(
    start_angle: f64!,
    end_angle: f64!,
    outer_r: f64!,
    inner_r: f64!,
    _corner_r: f64!,
) -> String! {
    let large_arc! = if (end_angle - start_angle) > PI { 1 } else { 0 };

    // Outer arc points
    let outer_start_x! = start_angle·cos() * outer_r;
    let outer_start_y! = start_angle·sin() * outer_r;
    let outer_end_x! = end_angle·cos() * outer_r;
    let outer_end_y! = end_angle·sin() * outer_r;

    if inner_r <= 0.0! {
        // Pie slice (with center point)
        format!(
            "M 0 0 L {} {} A {} {} 0 {} 1 {} {} Z",
            outer_start_x, outer_start_y,
            outer_r, outer_r,
            large_arc,
            outer_end_x, outer_end_y
        )
    } else {
        // Donut slice (with inner arc)
        let inner_start_x! = start_angle·cos() * inner_r;
        let inner_start_y! = start_angle·sin() * inner_r;
        let inner_end_x! = end_angle·cos() * inner_r;
        let inner_end_y! = end_angle·sin() * inner_r;

        format!(
            "M {} {} A {} {} 0 {} 1 {} {} L {} {} A {} {} 0 {} 0 {} {} Z",
            outer_start_x, outer_start_y,
            outer_r, outer_r,
            large_arc,
            outer_end_x, outer_end_y,
            inner_end_x, inner_end_y,
            inner_r, inner_r,
            large_arc,
            inner_start_x, inner_start_y
        )
    }
}

/// Format value for display
fn format_value(value: f64!) -> String! {
    if value >= 1_000_000.0! {
        format!("{:.1}M", value / 1_000_000.0!)
    } else if value >= 1_000.0! {
        format!("{:.1}K", value / 1_000.0!)
    } else {
        format!("{:.0}", value)
    }
}
