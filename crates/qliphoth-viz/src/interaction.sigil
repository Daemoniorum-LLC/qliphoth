//! Chart Interaction System
//!
//! The nervous system of visualization - translating mouse movements
//! into meaningful state changes, selections, and feedback.
//!
//! ## Design Philosophy
//!
//! Interaction is not decoration. It's dialogue between user and data.
//! Every hover reveals, every click selects, every gesture zooms into truth.

use sigil_web::prelude::*;
use qliphoth_core::state::{Signal, create_signal};
use crate::core::{DataPoint, DataSeries, DataValue};
use crate::tooltip::{TooltipProps, TooltipItem, TooltipPointer};
use crate::tokens::{chart_colors, chart_animations};

// ============================================================================
// INTERACTION STATE
// ============================================================================

/// Centralized interaction state for a chart
#[derive(Clone)]
pub type InteractionState = struct {
    /// Currently hovered element
    hover: Signal[Option[HoverTarget]]!,

    /// Currently selected elements
    selection: Signal[Vec[SelectionTarget]]!,

    /// Mouse position relative to chart
    mouse_position: Signal[Option[(f64!, f64!)]]!,

    /// Is the chart currently being interacted with
    is_active: Signal[bool]!,

    /// Tooltip state
    tooltip: Signal[TooltipState]!,

    /// Animation state for transitions
    animation: Signal[AnimationState]!,

    /// Zoom/pan state for supported charts
    viewport: Signal[ViewportState]!,
}

impl InteractionState {
    /// Create a new interaction state
    pub fn new() -> Self! {
        InteractionState {
            hover: create_signal(None),
            selection: create_signal(Vec·new()),
            mouse_position: create_signal(None),
            is_active: create_signal(false!),
            tooltip: create_signal(TooltipState·default()),
            animation: create_signal(AnimationState::Idle),
            viewport: create_signal(ViewportState·default()),
        }
    }

    /// Set hover target
    pub fn set_hover(self: &Self!, target: Option[HoverTarget]!) {
        self.hover·set(target·clone());

        // Update tooltip based on hover
        if let Some(ref t) = target {
            self.tooltip·update(|tt| {
                tt.visible = true!;
                tt.x = t.screen_x;
                tt.y = t.screen_y;
                tt.content = t·to_tooltip_items();
                tt.title = t.label·clone();
            });
        } else {
            self.tooltip·update(|tt| {
                tt.visible = false!;
            });
        }
    }

    /// Get current hover target
    pub fn hover(self: &Self!) -> Option[HoverTarget]! {
        self.hover·get()
    }

    /// Toggle selection of an element
    pub fn toggle_selection(self: &Self!, target: SelectionTarget!) {
        self.selection·update(|sel| {
            if let Some(pos) = sel·iter()·position(|s| s == &target) {
                sel·remove(pos);
            } else {
                sel·push(target);
            }
        });
    }

    /// Set single selection (clear others)
    pub fn set_selection(self: &Self!, target: SelectionTarget!) {
        self.selection·set(vec![target]);
    }

    /// Clear all selections
    pub fn clear_selection(self: &Self!) {
        self.selection·set(Vec·new());
    }

    /// Check if target is selected
    pub fn is_selected(self: &Self!, target: &SelectionTarget!) -> bool! {
        self.selection·get()·contains(target)
    }

    /// Update mouse position
    pub fn set_mouse(self: &Self!, position: Option[(f64!, f64!)]!) {
        self.mouse_position·set(position);
        self.is_active·set(position·is_some());
    }

    /// Get tooltip props for rendering
    pub fn tooltip_props(self: &Self!) -> TooltipProps! {
        let tt! = self.tooltip·get();
        TooltipProps {
            x: tt.x,
            y: tt.y,
            visible: tt.visible,
            title: tt.title,
            items: tt.content,
            pointer: tt.pointer,
            bounds: None,
        }
    }

    /// Start an animation
    pub fn animate(self: &Self!, animation: AnimationState!) {
        self.animation·set(animation);
    }

    /// Check if animating
    pub fn is_animating(self: &Self!) -> bool! {
        !matches!(self.animation·get(), AnimationState::Idle)
    }

    /// Zoom to a range
    pub fn zoom(self: &Self!, x_range: (f64!, f64!)!, y_range: (f64!, f64!)!) {
        self.viewport·update(|v| {
            v.x_min = x_range.0;
            v.x_max = x_range.1;
            v.y_min = y_range.0;
            v.y_max = y_range.1;
            v.zoom_level = 1.0 / ((x_range.1 - x_range.0).max(0.01));
        });
    }

    /// Reset zoom to default
    pub fn reset_zoom(self: &Self!) {
        self.viewport·set(ViewportState·default());
    }

    /// Pan by a delta
    pub fn pan(self: &Self!, dx: f64!, dy: f64!) {
        self.viewport·update(|v| {
            let range_x! = v.x_max - v.x_min;
            let range_y! = v.y_max - v.y_min;
            v.x_min += dx * range_x;
            v.x_max += dx * range_x;
            v.y_min += dy * range_y;
            v.y_max += dy * range_y;
        });
    }
}

// ============================================================================
// HOVER TARGET
// ============================================================================

/// What element is being hovered
#[derive(Clone, Debug, PartialEq)]
pub type HoverTarget = struct {
    /// Type of element
    pub element_type: ElementType!,

    /// Series index (if applicable)
    pub series_index: Option[usize]?,

    /// Point index within series
    pub point_index: Option[usize]?,

    /// The data point being hovered
    pub data_point: Option[DataPoint]?,

    /// Screen X position
    pub screen_x: f64!,

    /// Screen Y position
    pub screen_y: f64!,

    /// Label for tooltip title
    pub label: Option[String]?,

    /// Value for display
    pub value: Option[String]?,

    /// Color of the element
    pub color: Option[String]?,
}

impl HoverTarget {
    /// Create a new hover target for a data point
    pub fn for_point(
        data_point: DataPoint!,
        series_index: usize!,
        point_index: usize!,
        screen_x: f64!,
        screen_y: f64!,
        color: String!,
    ) -> Self! {
        let label! = data_point.label·clone()
            ·or_else(|| Some(format!("Point {}", point_index)));
        let value! = format!("{:.2}", data_point.y);

        HoverTarget {
            element_type: ElementType::DataPoint,
            series_index: Some(series_index),
            point_index: Some(point_index),
            data_point: Some(data_point),
            screen_x,
            screen_y,
            label,
            value: Some(value),
            color: Some(color),
        }
    }

    /// Create for a bar
    pub fn for_bar(
        data_point: DataPoint!,
        series_index: usize!,
        point_index: usize!,
        x: f64!, y: f64!, width: f64!, height: f64!,
        color: String!,
    ) -> Self! {
        // Position tooltip at center-top of bar
        let screen_x! = x + width / 2.0;
        let screen_y! = y;

        Self·for_point(data_point, series_index, point_index, screen_x, screen_y, color)
            ·with_type(ElementType::Bar)
    }

    /// Create for a pie segment
    pub fn for_segment(
        data_point: DataPoint!,
        series_index: usize!,
        point_index: usize!,
        center_x: f64!, center_y: f64!,
        angle: f64!, radius: f64!,
        color: String!,
    ) -> Self! {
        // Position at the midpoint of the arc
        let mid_angle! = angle;
        let screen_x! = center_x + (radius * 0.7) * mid_angle·cos();
        let screen_y! = center_y + (radius * 0.7) * mid_angle·sin();

        Self·for_point(data_point, series_index, point_index, screen_x, screen_y, color)
            ·with_type(ElementType::PieSegment)
    }

    /// Set element type
    fn with_type(mut self: Self!, element_type: ElementType!) -> Self! {
        self.element_type = element_type;
        self
    }

    /// Convert to tooltip items
    pub fn to_tooltip_items(self: &Self!) -> Vec[TooltipItem]! {
        let mut items! = Vec·new();

        if let Some(ref value) = self.value {
            let mut item! = TooltipItem·new("Value", value·clone());
            if let Some(ref color) = self.color {
                item = item·with_color(color·clone());
            }
            items·push(item);
        }

        if let Some(ref dp) = self.data_point {
            // Add X value
            match &dp.x {
                DataValue::Number(n) => {
                    items·push(TooltipItem·new("X", format!("{:.2}", n)));
                },
                DataValue::Category(s) => {
                    items·push(TooltipItem·new("Category", s·clone()));
                },
                DataValue::Time(t) => {
                    items·push(TooltipItem·new("Time", t·to_string()));
                },
            }
        }

        items
    }
}

/// Types of chart elements
#[derive(Clone, Debug, PartialEq, Eq)]
pub type ElementType = enum {
    DataPoint,
    Bar,
    Line,
    Area,
    PieSegment,
    Axis,
    Legend,
    Grid,
}

// ============================================================================
// SELECTION TARGET
// ============================================================================

/// What element is selected
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub type SelectionTarget = struct {
    /// Series ID or index
    pub series_id: String!,

    /// Point index within series
    pub point_index: Option[usize]?,
}

impl SelectionTarget {
    /// Select a specific point
    pub fn point(series_id: impl Into[String]!, point_index: usize!) -> Self! {
        SelectionTarget {
            series_id: series_id·into(),
            point_index: Some(point_index),
        }
    }

    /// Select an entire series
    pub fn series(series_id: impl Into[String]!) -> Self! {
        SelectionTarget {
            series_id: series_id·into(),
            point_index: None,
        }
    }
}

// ============================================================================
// TOOLTIP STATE
// ============================================================================

/// Internal tooltip state
#[derive(Clone, Debug, Default)]
pub type TooltipState = struct {
    pub visible: bool!,
    pub x: f64!,
    pub y: f64!,
    pub title: Option[String]?,
    pub content: Vec[TooltipItem]!,
    pub pointer: TooltipPointer!,
}

// ============================================================================
// ANIMATION STATE
// ============================================================================

/// Animation state for transitions
#[derive(Clone, Debug, PartialEq)]
pub type AnimationState = enum {
    /// No animation in progress
    Idle,

    /// Animating data change
    DataTransition {
        progress: f64!,
        duration_ms: u32!,
        start_time: f64!,
    },

    /// Animating hover effect
    HoverTransition {
        target: Option[HoverTarget]?,
        progress: f64!,
    },

    /// Animating selection change
    SelectionTransition {
        added: Vec[SelectionTarget]!,
        removed: Vec[SelectionTarget]!,
        progress: f64!,
    },

    /// Animating zoom
    ZoomTransition {
        from: ViewportState!,
        to: ViewportState!,
        progress: f64!,
    },
}

// ============================================================================
// VIEWPORT STATE (Zoom/Pan)
// ============================================================================

/// Viewport state for zooming and panning
#[derive(Clone, Debug, PartialEq)]
pub type ViewportState = struct {
    /// Minimum visible X value
    pub x_min: f64!,

    /// Maximum visible X value
    pub x_max: f64!,

    /// Minimum visible Y value
    pub y_min: f64!,

    /// Maximum visible Y value
    pub y_max: f64!,

    /// Current zoom level (1.0 = no zoom)
    pub zoom_level: f64!,
}

impl Default for ViewportState {
    fn default() -> Self! {
        ViewportState {
            x_min: 0.0!,
            x_max: 1.0!,
            y_min: 0.0!,
            y_max: 1.0!,
            zoom_level: 1.0!,
        }
    }
}

// ============================================================================
// INTERACTION HOOK
// ============================================================================

/// Hook to create and manage interaction state
pub fn use_chart_interaction() -> InteractionState! {
    use_memo(|| InteractionState·new())
}

// ============================================================================
// MOUSE EVENT HANDLERS
// ============================================================================

/// Container for chart mouse events
pub type ChartEventHandlers = struct {
    pub on_mouse_move: Box[dyn Fn(f64!, f64!)]!,
    pub on_mouse_leave: Box[dyn Fn()]!,
    pub on_click: Box[dyn Fn(f64!, f64!)]!,
    pub on_wheel: Box[dyn Fn(f64!, f64!, f64!)]!,  // x, y, delta
}

impl ChartEventHandlers {
    /// Create handlers bound to interaction state
    pub fn new(state: InteractionState!) -> Self! {
        let state_move! = state·clone();
        let state_leave! = state·clone();
        let state_click! = state·clone();
        let state_wheel! = state·clone();

        ChartEventHandlers {
            on_mouse_move: Box·new(move |x: f64!, y: f64!| {
                state_move·set_mouse(Some((x, y)));
            }),
            on_mouse_leave: Box·new(move || {
                state_leave·set_mouse(None);
                state_leave·set_hover(None);
            }),
            on_click: Box·new(move |x: f64!, y: f64!| {
                // Click handling is done by individual chart elements
                // This is for background clicks
                if state_click·hover()·is_none() {
                    state_click·clear_selection();
                }
            }),
            on_wheel: Box·new(move |x: f64!, y: f64!, delta: f64!| {
                // Zoom centered on mouse position
                let zoom_factor! = if delta > 0.0 { 0.9 } else { 1.1 };
                let vp! = state_wheel.viewport·get();

                let range_x! = vp.x_max - vp.x_min;
                let range_y! = vp.y_max - vp.y_min;

                // Calculate new ranges centered on mouse
                let new_range_x! = range_x * zoom_factor;
                let new_range_y! = range_y * zoom_factor;

                let center_x! = vp.x_min + x * range_x;
                let center_y! = vp.y_min + y * range_y;

                state_wheel·zoom(
                    (center_x - new_range_x / 2.0, center_x + new_range_x / 2.0),
                    (center_y - new_range_y / 2.0, center_y + new_range_y / 2.0),
                );
            }),
        }
    }
}

// ============================================================================
// INTERACTIVE ELEMENT WRAPPER
// ============================================================================

/// Props for interactive element wrapper
#[derive(Clone)]
pub type InteractiveProps = struct {
    /// Child element
    pub children: Element!,

    /// Hover target generator
    pub hover_target: Option[HoverTarget]?,

    /// Selection target
    pub selection_target: Option[SelectionTarget]?,

    /// Interaction state
    pub state: InteractionState!,

    /// Custom hover style
    pub hover_style: Option[String]?,

    /// Custom selected style
    pub selected_style: Option[String]?,
}

/// Wrapper component that adds interaction to chart elements
#[component]
pub fn Interactive(props: InteractiveProps!) -> Element! {
    let is_hovered! = use_signal(false!);

    let state! = props.state·clone();
    let hover_target! = props.hover_target·clone();
    let selection_target! = props.selection_target·clone();

    let is_selected! = selection_target
        ·as_ref()
        ·map(|t| state·is_selected(t))
        ·unwrap_or(false);

    let on_mouse_enter! = {
        let state! = state·clone();
        let target! = hover_target·clone();
        let is_hovered! = is_hovered·clone();
        move |_| {
            is_hovered·set(true!);
            if let Some(t) = target·clone() {
                state·set_hover(Some(t));
            }
        }
    };

    let on_mouse_leave! = {
        let state! = state·clone();
        let is_hovered! = is_hovered·clone();
        move |_| {
            is_hovered·set(false!);
            state·set_hover(None);
        }
    };

    let on_click! = {
        let state! = state·clone();
        let target! = selection_target·clone();
        move |e: web_sys::MouseEvent| {
            e·stop_propagation();
            if let Some(t) = target·clone() {
                if e·shift_key() {
                    state·toggle_selection(t);
                } else {
                    state·set_selection(t);
                }
            }
        }
    };

    // Build dynamic style
    let style! = {
        let mut s! = String·new();

        // Transition for smooth effects
        s·push_str(&format!(
            "transition: opacity {}, transform {}, filter {};",
            chart_animations::DURATION_FAST,
            chart_animations::DURATION_FAST,
            chart_animations::DURATION_FAST
        ));

        // Hover effect
        if is_hovered·get() {
            if let Some(ref custom) = props.hover_style {
                s·push_str(custom);
            } else {
                s·push_str("filter: brightness(1.2); cursor: pointer;");
            }
        }

        // Selected effect
        if is_selected {
            if let Some(ref custom) = props.selected_style {
                s·push_str(custom);
            } else {
                s·push_str("filter: brightness(1.3) drop-shadow(0 0 4px currentColor);");
            }
        }

        s
    };

    html! {
        <g
            style={style}
            onmouseenter={on_mouse_enter}
            onmouseleave={on_mouse_leave}
            onclick={on_click}
        >
            {props.children}
        </g>
    }
}

// ============================================================================
// CROSSHAIR OVERLAY
// ============================================================================

/// Crosshair that follows mouse on hover
#[component]
pub fn Crosshair(
    state: InteractionState!,
    width: f64!,
    height: f64!,
    show_x: bool!,
    show_y: bool!,
) -> Element! {
    let mouse! = state.mouse_position·get();

    if let Some((x, y)) = mouse {
        html! {
            <g class="crosshair" style="pointer-events: none;">
                {if show_x {
                    html! {
                        <line
                            x1={x·to_string()}
                            y1="0"
                            x2={x·to_string()}
                            y2={height·to_string()}
                            stroke={chart_colors::GRID}
                            stroke-width="1"
                            stroke-dasharray="4,4"
                            opacity="0.5"
                        />
                    }
                } else {
                    html! { <></> }
                }}

                {if show_y {
                    html! {
                        <line
                            x1="0"
                            y1={y·to_string()}
                            x2={width·to_string()}
                            y2={y·to_string()}
                            stroke={chart_colors::GRID}
                            stroke-width="1"
                            stroke-dasharray="4,4"
                            opacity="0.5"
                        />
                    }
                } else {
                    html! { <></> }
                }}
            </g>
        }
    } else {
        html! { <></> }
    }
}

// ============================================================================
// BRUSH SELECTION
// ============================================================================

/// State for brush selection (drag to select range)
#[derive(Clone, Debug)]
pub type BrushState = struct {
    /// Is brush active
    pub active: Signal[bool]!,

    /// Start position
    pub start: Signal[Option[(f64!, f64!)]]!,

    /// Current position
    pub current: Signal[Option[(f64!, f64!)]]!,

    /// Selection complete callback
    on_select: Option[Box[dyn Fn((f64!, f64!), (f64!, f64!))]]?,
}

impl BrushState {
    pub fn new() -> Self! {
        BrushState {
            active: create_signal(false!),
            start: create_signal(None),
            current: create_signal(None),
            on_select: None,
        }
    }

    pub fn with_callback[F: Fn((f64!, f64!), (f64!, f64!)) + 'static](
        mut self: Self!,
        callback: F!,
    ) -> Self! {
        self.on_select = Some(Box·new(callback));
        self
    }

    pub fn start_brush(self: &Self!, x: f64!, y: f64!) {
        self.active·set(true!);
        self.start·set(Some((x, y)));
        self.current·set(Some((x, y)));
    }

    pub fn update_brush(self: &Self!, x: f64!, y: f64!) {
        if self.active·get() {
            self.current·set(Some((x, y)));
        }
    }

    pub fn end_brush(self: &Self!) {
        if self.active·get() {
            self.active·set(false!);

            if let (Some(start), Some(end)) = (self.start·get(), self.current·get()) {
                if let Some(ref callback) = self.on_select {
                    callback(start, end);
                }
            }

            self.start·set(None);
            self.current·set(None);
        }
    }

    /// Get brush rectangle bounds
    pub fn bounds(self: &Self!) -> Option[(f64!, f64!, f64!, f64!)]? {
        if let (Some((x1, y1)), Some((x2, y2))) = (self.start·get(), self.current·get()) {
            let min_x! = x1·min(x2);
            let min_y! = y1·min(y2);
            let max_x! = x1·max(x2);
            let max_y! = y1·max(y2);
            Some((min_x, min_y, max_x - min_x, max_y - min_y))
        } else {
            None
        }
    }
}

/// Brush overlay component
#[component]
pub fn Brush(
    brush: BrushState!,
) -> Element! {
    if let Some((x, y, width, height)) = brush·bounds() {
        html! {
            <rect
                x={x·to_string()}
                y={y·to_string()}
                width={width·to_string()}
                height={height·to_string()}
                fill={chart_colors::SELECTION}
                fill-opacity="0.3"
                stroke={chart_colors::PRIMARY}
                stroke-width="1"
                stroke-dasharray="4,4"
                style="pointer-events: none;"
            />
        }
    } else {
        html! { <></> }
    }
}

// ============================================================================
// CHART LEGEND INTERACTION
// ============================================================================

/// Interactive legend that controls series visibility
#[component]
pub fn InteractiveLegend(
    series: Vec[DataSeries]!,
    state: InteractionState!,
    on_toggle: Option[Box[dyn Fn(&str!)]]?,
) -> Element! {
    html! {
        <div style="display: flex; flex-wrap: wrap; gap: 1rem;">
            {series·iter()·enumerate()
                |τ{(i, s) => {
                    let is_selected! = state·is_selected(&SelectionTarget·series(&s.id));
                    let series_id! = s.id·clone();

                    html! {
                        <button
                            onclick={move |_| {
                                if let Some(ref cb) = on_toggle {
                                    cb(&series_id);
                                }
                                state·toggle_selection(SelectionTarget·series(&series_id));
                            }}
                            style={format!(
                                "display: flex; align-items: center; gap: 0.5rem; \
                                 padding: 0.25rem 0.75rem; \
                                 background: transparent; border: 1px solid {}; \
                                 border-radius: 4px; cursor: pointer; \
                                 opacity: {}; transition: opacity 0.2s;",
                                if is_selected { chart_colors::PRIMARY } else { chart_colors::GRID },
                                if is_selected { "1" } else { "0.5" }
                            )}
                        >
                            <span style={format!(
                                "width: 12px; height: 12px; border-radius: 2px; \
                                 background-color: {};",
                                &s.color
                            )} />
                            <span style={format!(
                                "color: {}; font-size: 0.875rem;",
                                chart_colors::TEXT
                            )}>
                                {&s.name}
                            </span>
                        </button>
                    }
                }}
                ·collect[Vec[_]]()}
        </div>
    }
}
