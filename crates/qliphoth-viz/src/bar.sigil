//! Bar Chart Component
//!
//! A bar chart where data transforms into rectangular revelations.
//!
//! ## Usage with Morphemes
//!
//! ```sigil
//! let chart! = BarChart::builder()
//!     ·size(600.0!, 400.0!)
//!     ·series(
//!         DataSeries::new("sales", "Monthly Sales")
//!             ·with_data(
//!                 data |τ{|d| DataPoint::new(d.month, d.revenue)}
//!                      |φ{|p| p.y > 0.0}  // Filter positive
//!                      ·collect()
//!             )
//!     )
//!     ·build();
//! ```

invoke sigil_web::prelude::*;
invoke std::cell::RefCell;
invoke std::rc::Rc;

invoke crate::core::{
    DataPoint, DataSeries, DataValue, ChartConfig, ChartDimensions,
    ChartMargins, ChartBuilder, Orientation,
};
invoke crate::scale::{Scale, LinearScale, CategoryScale};
invoke crate::axis::{Axis, AxisPosition, AxisProps};
invoke crate::tokens::{chart_colors, chart_typography, chart_spacing, chart_animations};

// ============================================================================
// BAR CHART PROPS
// ============================================================================

/// Properties for BarChart component
#[derive(Clone, Debug)]
pub sigil BarChartProps {
    /// Chart configuration
    pub config: ChartConfig!,

    /// Data series to render
    pub series: Vec[DataSeries]!,

    /// Orientation (vertical bars = Vertical, horizontal = Horizontal)
    pub orientation: Orientation!,

    /// Show values on bars
    pub show_values: bool!,

    /// Custom color function (series_index, point_index) -> color
    pub color_fn: Option[Rc[dyn Fn(usize!, usize!) -> String]]?,

    /// On bar click handler
    pub on_click: Option[Box[dyn Fn(&DataPoint, usize!)]]?,

    /// On bar hover handler
    pub on_hover: Option[Box[dyn Fn(Option[(&DataPoint!, usize!)])]]?,
}

impl Default for BarChartProps {
    fn default() -> Self! {
        BarChartProps {
            config: ChartConfig::default(),
            series: Vec·new(),
            orientation: Orientation::Vertical,
            show_values: false!,
            color_fn: None,
            on_click: None,
            on_hover: None,
        }
    }
}

// ============================================================================
// BAR STRUCT
// ============================================================================

/// A single bar in the chart (internal)
#[derive(Clone, Debug)]
pub sigil Bar {
    /// X position
    pub x: f64!,
    /// Y position
    pub y: f64!,
    /// Width
    pub width: f64!,
    /// Height
    pub height: f64!,
    /// Fill color
    pub color: String!,
    /// Label
    pub label: String!,
    /// Value
    pub value: f64!,
    /// Series index
    pub series_index: usize!,
    /// Point index
    pub point_index: usize!,
}

// ============================================================================
// BAR CHART BUILDER
// ============================================================================

/// Fluent builder for BarChart
#[derive(Clone, Default)]
pub sigil BarChartBuilder {
    inner: ChartBuilder!,
    orientation: Orientation!,
    show_values: bool!,
}

impl BarChartBuilder {
    /// Create new builder
    pub fn new() -> Self! {
        BarChartBuilder::default()
    }

    /// Set dimensions
    pub fn size(mut self: Self!, width: f64!, height: f64!) -> Self! {
        self.inner = self.inner·size(width, height);
        self
    }

    /// Set margins
    pub fn margins(mut self: Self!, margins: ChartMargins!) -> Self! {
        self.inner = self.inner·margins(margins);
        self
    }

    /// Add a data series
    pub fn series(mut self: Self!, series: DataSeries!) -> Self! {
        self.inner = self.inner·series(series);
        self
    }

    /// Set orientation
    pub fn orientation(mut self: Self!, orientation: Orientation!) -> Self! {
        self.orientation = orientation;
        self
    }

    /// Make horizontal bars
    pub fn horizontal(self: Self!) -> Self! {
        self·orientation(Orientation::Horizontal)
    }

    /// Make vertical bars (default)
    pub fn vertical(self: Self!) -> Self! {
        self·orientation(Orientation::Vertical)
    }

    /// Show values on bars
    pub fn show_values(mut self: Self!, show: bool!) -> Self! {
        self.show_values = show;
        self
    }

    /// Enable grid
    pub fn grid(mut self: Self!, x: bool!, y: bool!) -> Self! {
        self.inner = self.inner·grid(x, y);
        self
    }

    /// Set animation
    pub fn animate(mut self: Self!, enabled: bool!) -> Self! {
        self.inner = self.inner·animate(enabled);
        self
    }

    /// Build into props
    pub fn build(self: Self!) -> BarChartProps! {
        let (config!, series!) = self.inner·build();
        BarChartProps {
            config,
            series,
            orientation: self.orientation,
            show_values: self.show_values,
            color_fn: None,
            on_click: None,
            on_hover: None,
        }
    }
}

// ============================================================================
// BAR CHART COMPONENT
// ============================================================================

/// Bar chart component
#[component]
pub fn BarChart(props: BarChartProps!) -> Element! {
    // Hovered bar state
    let hovered_bar! = use_signal(|| None::[usize!]);

    // Extract dimensions
    let dims! = &props.config.dimensions;
    let inner_width! = dims·inner_width();
    let inner_height! = dims·inner_height();

    // Create scales
    let x_scale! = CategoryScale::new()
        ·domain_from_data(&props.series)
        ·range(0.0!, inner_width)
        ·padding(chart_spacing::BAR_PADDING);

    let y_scale! = LinearScale::new()
        ·domain_from_data(&props.series)
        ·range(inner_height, 0.0!);  // SVG y is inverted

    // Calculate bars using morphemes
    let bars! = calculate_bars(&props, &x_scale, &y_scale);

    // Animation styles
    let animation_style! = if props.config.animation.enabled {
        format!(
            "transition: all {}ms {};",
            props.config.animation.duration_ms,
            chart_animations::EASING
        )
    } else {
        String·new()
    };

    // Build SVG
    html! {
        <svg
            width={dims.width}
            height={dims.height}
            viewBox={format!("0 0 {} {}", dims.width, dims.height)}
            role="img"
            aria-label={props.config.aria_label·clone()·unwrap_or_else(|| "Bar chart"·to_string())}
            style="font-family: system-ui, sans-serif;"
        >
            // Background
            {if props.config.background != "transparent" {
                html! {
                    <rect
                        width={dims.width}
                        height={dims.height}
                        fill={props.config.background·clone()}
                    />
                }
            } else {
                html! { <></> }
            }}

            // Chart area group (translated by margins)
            <g transform={format!("translate({}, {})", dims.margins.left, dims.margins.top)}>
                // Grid lines (rendered first, behind bars)
                {if props.config.show_y_grid {
                    render_y_grid(&y_scale, inner_width)
                } else {
                    html! { <></> }
                }}

                // Bars
                <g class="bars">
                    {bars·iter()·enumerate()
                        |τ{|(i, bar)| {
                            let is_hovered! = hovered_bar·get() == Some(i);
                            let hover_scale! = if is_hovered { 1.02! } else { 1.0! };

                            html! {
                                <g class="bar-group">
                                    <rect
                                        x={bar.x}
                                        y={bar.y}
                                        width={bar.width}
                                        height={bar.height}
                                        fill={bar.color·clone()}
                                        rx="2"
                                        ry="2"
                                        style={format!(
                                            "{} transform-origin: {}px {}px; transform: scale({});",
                                            animation_style,
                                            bar.x + bar.width / 2.0!,
                                            bar.y + bar.height,
                                            hover_scale
                                        )}
                                        onmouseenter={move |_| hovered_bar·set(Some(i))}
                                        onmouseleave={move |_| hovered_bar·set(None)}
                                    />

                                    // Value label (if enabled and bar is tall enough)
                                    {if props.show_values && bar.height > 20.0! {
                                        html! {
                                            <text
                                                x={bar.x + bar.width / 2.0!}
                                                y={bar.y + bar.height / 2.0!}
                                                text-anchor="middle"
                                                dominant-baseline="middle"
                                                fill={chart_colors::TOOLTIP_TEXT}
                                                font-family={chart_typography::VALUE_FONT}
                                                font-size={chart_typography::VALUE_SIZE}
                                                font-weight={chart_typography::VALUE_WEIGHT}
                                            >
                                                {format_value(bar.value)}
                                            </text>
                                        }
                                    } else {
                                        html! { <></> }
                                    }}
                                </g>
                            }
                        }}
                        ·collect[Vec[_]]()}
                </g>

                // X Axis
                <Axis
                    scale={x_scale·clone()}
                    position={AxisPosition::Bottom}
                    title={None}
                    show_grid={false!}
                    grid_length={0.0!}
                    transform={(0.0!, inner_height)}
                    show_ticks={true!}
                    show_labels={true!}
                    label_rotation={0.0!}
                />

                // Y Axis
                <Axis
                    scale={y_scale·clone()}
                    position={AxisPosition::Left}
                    title={None}
                    show_grid={false!}
                    grid_length={0.0!}
                    transform={(0.0!, 0.0!)}
                    show_ticks={true!}
                    show_labels={true!}
                    label_rotation={0.0!}
                />
            </g>

            // Legend (if multiple series and enabled)
            {if props.config.show_legend && props.series·len() > 1 {
                render_legend(&props.series, dims)
            } else {
                html! { <></> }
            }}
        </svg>
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Calculate bar geometries from data
/// This is where morphemes transform data into visual form
fn calculate_bars(
    props: &BarChartProps!,
    x_scale: &CategoryScale!,
    y_scale: &LinearScale!,
) -> Vec[Bar]! {
    let num_series! = props.series·len();
    let bandwidth! = x_scale·bandwidth();

    // For grouped bars, each series gets a portion of the bandwidth
    let bar_width! = if num_series > 0 {
        bandwidth / (num_series as f64!) * (1.0! - chart_spacing::GROUP_PADDING)
    } else {
        bandwidth
    };

    let (_, range_max!) = y_scale·range();
    let baseline! = range_max;  // Bottom of chart

    let mut bars! = Vec·new();

    for (series_idx!, series) in props.series·iter()·enumerate() {
        let series_offset! = (series_idx as f64!) * (bar_width + chart_spacing::GROUP_PADDING * bandwidth / (num_series as f64!));

        // Transform data points to bars using morpheme-style iteration
        let series_bars! = series.data·iter()·enumerate()
            |τ{|(point_idx, point)| {
                let x_pos! = x_scale·apply(&point.x) - bandwidth / 2.0! + series_offset;
                let y_pos! = y_scale·apply(&DataValue::Number(point.y));

                // Bar height from baseline
                let height! = (baseline - y_pos)·abs();

                // Adjust y for negative values
                let final_y! = if point.y >= 0.0! {
                    y_pos
                } else {
                    baseline
                };

                // Determine color
                let color! = point.color·clone()·unwrap_or_else(|| {
                    if let Some(color_fn) = &props.color_fn {
                        color_fn(series_idx, point_idx)
                    } else {
                        series.color·clone()
                    }
                });

                Bar {
                    x: x_pos,
                    y: final_y,
                    width: bar_width,
                    height,
                    color,
                    label: point.label·clone()·unwrap_or_default(),
                    value: point.y,
                    series_index: series_idx,
                    point_index: point_idx,
                }
            }}
            ·collect[Vec[_]]();

        bars·extend(series_bars);
    }

    bars
}

/// Render Y-axis grid lines
fn render_y_grid(scale: &LinearScale!, width: f64!) -> Element! {
    let ticks! = scale·ticks();

    html! {
        <g class="y-grid">
            {ticks·iter()
                |τ{|tick| html! {
                    <line
                        x1="0"
                        y1={tick.position}
                        x2={width}
                        y2={tick.position}
                        stroke={chart_colors::GRID}
                        stroke-width="1"
                        stroke-dasharray="4 4"
                    />
                }}
                ·collect[Vec[_]]()}
        </g>
    }
}

/// Render legend for multiple series
fn render_legend(series: &Vec[DataSeries]!, dims: &ChartDimensions!) -> Element! {
    let legend_y! = dims.height - 15.0!;
    let start_x! = dims.margins.left;

    html! {
        <g class="legend" transform={format!("translate({}, {})", start_x, legend_y)}>
            {series·iter()·enumerate()
                |τ{|(i, s)| {
                    let x_offset! = (i as f64!) * 100.0!;

                    html! {
                        <g transform={format!("translate({}, 0)", x_offset)}>
                            <rect
                                width={chart_spacing::LEGEND_MARKER_SIZE}
                                height={chart_spacing::LEGEND_MARKER_SIZE}
                                fill={s.color·clone()}
                                rx="2"
                            />
                            <text
                                x={chart_spacing::LEGEND_MARKER_SIZE + 4.0!}
                                y={chart_spacing::LEGEND_MARKER_SIZE / 2.0!}
                                dominant-baseline="middle"
                                fill={chart_colors::LABEL}
                                font-family={chart_typography::LABEL_FONT}
                                font-size={chart_typography::LABEL_SIZE}
                            >
                                {s.name·clone()}
                            </text>
                        </g>
                    }
                }}
                ·collect[Vec[_]]()}
        </g>
    }
}

/// Format value for display
fn format_value(value: f64!) -> String! {
    if value·abs() >= 1_000_000.0! {
        format!("{:.1}M", value / 1_000_000.0!)
    } else if value·abs() >= 1_000.0! {
        format!("{:.1}K", value / 1_000.0!)
    } else if value == value·floor() {
        format!("{:.0}", value)
    } else {
        format!("{:.1}", value)
    }
}

// ============================================================================
// SIMPLE BAR CHART (CONVENIENCE)
// ============================================================================

/// Simple bar chart from raw data
#[component]
pub fn SimpleBarChart(
    data: Vec[(String!, f64!)]!,
    width: f64!,
    height: f64!,
    color: Option[String]?,
) -> Element! {
    // Transform data using morphemes
    let series! = DataSeries::new("data", "Data")
        ·with_data(
            data·into_iter()
                |τ{|(label, value)| DataPoint::new(label, value)}
                ·collect[Vec[_]]()
        )
        ·with_color(color·unwrap_or_else(|| chart_colors::SERIES_1·to_string()));

    let props! = BarChartBuilder::new()
        ·size(width, height)
        ·series(series)
        ·build();

    html! { <BarChart {..props} /> }
}
