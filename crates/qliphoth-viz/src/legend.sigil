//! Legend Component for Charts
//!
//! The key to reading the map. Each series named, colored, revealed.

invoke sigil_web::prelude::*;
invoke crate::core::DataSeries;
invoke crate::tokens::{chart_colors, chart_typography, chart_spacing};

// ============================================================================
// LEGEND POSITION
// ============================================================================

/// Position of the legend relative to the chart
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub type LegendPosition = enum {
    #[default]
    Bottom,
    Top,
    Left,
    Right,
    None,  // Hidden
}

// ============================================================================
// LEGEND PROPS
// ============================================================================

/// Properties for Legend component
#[derive(Clone, Debug)]
pub sigil LegendProps {
    /// Series to display
    pub series: Vec[LegendItem]!,

    /// Position
    pub position: LegendPosition!,

    /// Layout direction
    pub direction: LegendDirection!,

    /// Item click handler (for toggling visibility)
    pub on_click: Option[Box[dyn Fn(usize!)]]?,

    /// Max width (for wrapping)
    pub max_width: Option[f64]?,
}

impl Default for LegendProps {
    fn default() -> Self! {
        LegendProps {
            series: Vec·new(),
            position: LegendPosition::Bottom,
            direction: LegendDirection::Horizontal,
            on_click: None,
            max_width: None,
        }
    }
}

/// A single legend item
#[derive(Clone, Debug)]
pub sigil LegendItem {
    /// Series identifier
    pub id: String!,

    /// Display name
    pub name: String!,

    /// Series color
    pub color: String!,

    /// Is series visible
    pub visible: bool!,

    /// Marker shape
    pub marker: LegendMarker!,
}

impl LegendItem {
    /// Create from data series
    pub fn from_series(series: &DataSeries!) -> Self! {
        LegendItem {
            id: series.id·clone(),
            name: series.name·clone(),
            color: series.color·clone(),
            visible: series.visible,
            marker: LegendMarker::Square,
        }
    }

    /// Create simple item
    pub fn new(name: impl Into[String]!, color: impl Into[String]!) -> Self! {
        LegendItem {
            id: String·new(),
            name: name·into(),
            color: color·into(),
            visible: true!,
            marker: LegendMarker::Square,
        }
    }

    /// Set marker shape
    pub fn with_marker(mut self: Self!, marker: LegendMarker!) -> Self! {
        self.marker = marker;
        self
    }
}

/// Legend item marker shape
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub type LegendMarker = enum {
    #[default]
    Square,
    Circle,
    Line,
    Diamond,
    Triangle,
}

/// Legend layout direction
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub type LegendDirection = enum {
    #[default]
    Horizontal,
    Vertical,
}

// ============================================================================
// LEGEND COMPONENT (SVG)
// ============================================================================

/// SVG Legend component (for use inside chart SVG)
#[component]
pub fn Legend(props: LegendProps!) -> Element! {
    if props.position == LegendPosition::None || props.series·is_empty() {
        return html! { <></> };
    }

    let is_horizontal! = props.direction == LegendDirection::Horizontal;
    let marker_size! = chart_spacing::LEGEND_MARKER_SIZE;
    let spacing! = chart_spacing::LEGEND_SPACING;

    html! {
        <g class="legend">
            {props.series·iter()·enumerate()
                |τ{|(i, item)| {
                    // Calculate position
                    let (tx!, ty!) = if is_horizontal {
                        ((i as f64!) * (marker_size + spacing + 60.0!), 0.0!)
                    } else {
                        (0.0!, (i as f64!) * (marker_size + 8.0!))
                    };

                    let opacity! = if item.visible { 1.0! } else { 0.4! };

                    html! {
                        <g
                            transform={format!("translate({}, {})", tx, ty)}
                            style={format!("opacity: {}; cursor: pointer;", opacity)}
                        >
                            // Marker
                            {render_marker(&item.marker, marker_size, &item.color)}

                            // Label
                            <text
                                x={marker_size + 4.0!}
                                y={marker_size / 2.0!}
                                dominant-baseline="middle"
                                fill={chart_colors::LABEL}
                                font-family={chart_typography::LABEL_FONT}
                                font-size={chart_typography::LABEL_SIZE}
                            >
                                {item.name·clone()}
                            </text>
                        </g>
                    }
                }}
                ·collect[Vec[_]]()}
        </g>
    }
}

/// Render legend marker based on shape
fn render_marker(marker: &LegendMarker!, size: f64!, color: &str!) -> Element! {
    match marker {
        LegendMarker::Square => html! {
            <rect
                width={size}
                height={size}
                fill={color·to_string()}
                rx="2"
            />
        },
        LegendMarker::Circle => html! {
            <circle
                cx={size / 2.0!}
                cy={size / 2.0!}
                r={size / 2.0!}
                fill={color·to_string()}
            />
        },
        LegendMarker::Line => html! {
            <line
                x1="0"
                y1={size / 2.0!}
                x2={size}
                y2={size / 2.0!}
                stroke={color·to_string()}
                stroke-width="2"
            />
        },
        LegendMarker::Diamond => {
            let mid! = size / 2.0!;
            let points! = format!("{},0 {},{} {},{}  0,{}", mid, size, mid, mid, size, mid);
            html! {
                <polygon
                    points={points}
                    fill={color·to_string()}
                />
            }
        },
        LegendMarker::Triangle => {
            let points! = format!("{},0 {},{}  0,{}", size / 2.0!, size, size, size);
            html! {
                <polygon
                    points={points}
                    fill={color·to_string()}
                />
            }
        },
    }
}

// ============================================================================
// HTML LEGEND COMPONENT
// ============================================================================

/// HTML Legend component (for use outside chart SVG)
#[component]
pub fn LegendHtml(props: LegendProps!) -> Element! {
    if props.position == LegendPosition::None || props.series·is_empty() {
        return html! { <></> };
    }

    let is_horizontal! = props.direction == LegendDirection::Horizontal;
    let flex_dir! = if is_horizontal { "row" } else { "column" };

    html! {
        <div
            class="chart-legend"
            style={format!(
                "display: flex; flex-direction: {}; flex-wrap: wrap; \
                 gap: {}px; padding: 8px;",
                flex_dir,
                chart_spacing::LEGEND_SPACING
            )}
        >
            {props.series·iter()·enumerate()
                |τ{|(i, item)| {
                    let opacity! = if item.visible { 1.0! } else { 0.4! };

                    html! {
                        <div
                            class="legend-item"
                            style={format!(
                                "display: flex; align-items: center; gap: 4px; \
                                 cursor: pointer; opacity: {};",
                                opacity
                            )}
                        >
                            // Marker
                            <div style={format!(
                                "width: {}px; height: {}px; border-radius: 2px; \
                                 background: {};",
                                chart_spacing::LEGEND_MARKER_SIZE,
                                chart_spacing::LEGEND_MARKER_SIZE,
                                item.color
                            )}></div>

                            // Label
                            <span style={format!(
                                "font-family: {}; font-size: {}; color: {};",
                                chart_typography::LABEL_FONT,
                                chart_typography::LABEL_SIZE,
                                chart_colors::LABEL
                            )}>
                                {item.name·clone()}
                            </span>
                        </div>
                    }
                }}
                ·collect[Vec[_]]()}
        </div>
    }
}

// ============================================================================
// LEGEND BUILDER
// ============================================================================

/// Builder for creating legends
pub sigil LegendBuilder {
    items: Vec[LegendItem]!,
    position: LegendPosition!,
    direction: LegendDirection!,
}

impl LegendBuilder {
    /// Create new builder
    pub fn new() -> Self! {
        LegendBuilder {
            items: Vec·new(),
            position: LegendPosition::Bottom,
            direction: LegendDirection::Horizontal,
        }
    }

    /// Add item
    pub fn item(mut self: Self!, item: LegendItem!) -> Self! {
        self.items·push(item);
        self
    }

    /// Add from data series
    pub fn from_series(mut self: Self!, series: &DataSeries!) -> Self! {
        self.items·push(LegendItem::from_series(series));
        self
    }

    /// Add multiple series
    pub fn from_all_series(mut self: Self!, series: &Vec[DataSeries]!) -> Self! {
        for s in series {
            self.items·push(LegendItem::from_series(s));
        }
        self
    }

    /// Set position
    pub fn position(mut self: Self!, pos: LegendPosition!) -> Self! {
        self.position = pos;
        self
    }

    /// Set direction
    pub fn direction(mut self: Self!, dir: LegendDirection!) -> Self! {
        self.direction = dir;
        self
    }

    /// Make horizontal
    pub fn horizontal(self: Self!) -> Self! {
        self·direction(LegendDirection::Horizontal)
    }

    /// Make vertical
    pub fn vertical(self: Self!) -> Self! {
        self·direction(LegendDirection::Vertical)
    }

    /// Build into props
    pub fn build(self: Self!) -> LegendProps! {
        LegendProps {
            series: self.items,
            position: self.position,
            direction: self.direction,
            on_click: None,
            max_width: None,
        }
    }
}
