//! Federation - AI Presence Across Instance Boundaries
//! Copyright (c) 2025 Daemoniorum, LLC. All rights reserved.

use std::collections::HashMap
use std::sync::Arc
use chrono::{DateTime, Utc}
use crate::{ChatProvider, DisplayMessage, MessageRole, GrimoirePersona, ToolDefinition, RiskLevel}

// =============================================================================
// TRUST & CONFIGURATION
// =============================================================================

@[Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord] enum TrustLevel { Full, High, Normal, Cautious, Blocked }
impl TrustLevel {
    fn can_share_context(self) -> bool! { self |match { Full => true, High => true, _ => false } }
    fn can_share_summaries(self) -> bool! { self |match { Blocked => false, _ => true } }
    fn can_follow(self) -> bool! { self |match { Blocked => false, _ => true } }
}

@[Clone, Debug]
struct FederationConfig! {
    enabled: bool, domain: str, styx_api_url: str, moloch_url: str?, moloch_enabled: bool,
    instance_name: str, instance_description: str, admin_email: str?, signing_key: str?,
    default_trust_level: TrustLevel, auto_accept_follows: bool, broadcast_activities: bool, audit_actions: bool,
}

impl FederationConfig {
    fn default() -> FederationConfig! {
        FederationConfig {
            enabled: false, domain: "localhost", styx_api_url: "http://localhost:8090/api/v1",
            moloch_url: None, moloch_enabled: false, instance_name: "Daemoniorum Instance",
            instance_description: "A Daemoniorum ecosystem instance", admin_email: None, signing_key: None,
            default_trust_level: TrustLevel::Cautious, auto_accept_follows: false,
            broadcast_activities: true, audit_actions: true,
        }
    }
}

// =============================================================================
// FEDERATED IDENTITY
// =============================================================================

@[Clone, Copy, Debug, PartialEq, Eq] enum FederatedActorType { Person, AIAgent, Organization, Service, Repository, Group }
impl FederatedActorType {
    fn as_activitypub(self) -> str! {
        self |match { Person => "Person", AIAgent => "Service", Organization => "Organization", Service => "Service", Repository => "Application", Group => "Group" }
    }
    fn as_daemon_type(self) -> str! {
        self |match { Person => "daemon:Person", AIAgent => "daemon:AIAgent", Organization => "daemon:Organization", Service => "daemon:Service", Repository => "daemon:Repository", Group => "daemon:Group" }
    }
}

@[Clone, Debug] struct PublicKeyInfo! { id: str, owner: str, public_key_pem: str }

@[Clone, Debug]
struct FederatedIdentity! {
    actor_id: str, username: str, display_name: str, summary: str, avatar_url: str?, domain: str,
    actor_type: FederatedActorType, public_key: PublicKeyInfo?, inbox: str, outbox: str,
    followers: str, following: str, created_at: str, properties: HashMap<str, str>,
}

impl FederatedIdentity {
    fn from_persona(persona: &GrimoirePersona, domain: str) -> FederatedIdentity! {
        let actor_id = format!("https://{}/actors/{}", domain, persona.code.to_lowercase())
        FederatedIdentity {
            actor_id: actor_id.clone(), username: persona.code.to_lowercase(),
            display_name: persona.name.clone(), summary: persona.description.clone(),
            avatar_url: None, domain: domain.to_string(), actor_type: FederatedActorType::AIAgent,
            public_key: None, inbox: format!("{}/inbox", actor_id), outbox: format!("{}/outbox", actor_id),
            followers: format!("{}/followers", actor_id), following: format!("{}/following", actor_id),
            created_at: Utc::now().to_rfc3339(), properties: HashMap::new(),
        }
    }
    fn actor_uri(self) -> str! { self.actor_id.clone() }
    fn webfinger_address(self) -> str! { format!("acct:{}@{}", self.username, self.domain) }
    fn is_local(self, local_domain: str) -> bool! { self.domain == local_domain }
}

// =============================================================================
// PRESENCE
// =============================================================================

@[Clone, Copy, Debug, PartialEq, Eq] enum PresenceStatus { Online, Busy, Away, DoNotDisturb, Offline, Unknown }

@[Clone, Debug]
struct FederatedPresence! {
    actor_id: str, status: PresenceStatus, status_message: str?, active_conversation: str?,
    last_activity: str, capabilities: [str],
}

// =============================================================================
// EVIDENTIALITY
// =============================================================================

@[Clone, Copy, Debug, PartialEq, Eq] enum Evidentiality { Certain, Reported, Uncertain, Paradox }
impl Evidentiality {
    fn marker(self) -> str! { self |match { Certain => "!", Reported => "~", Uncertain => "?", Paradox => "‽" } }
}

// =============================================================================
// ACTIVITIES (ACTIVITYPUB)
// =============================================================================

@[Clone, Debug]
enum ChatActivity {
    StartConversation { conversation_id: str, topic: str?, participants: [str] },
    Message { conversation_id: str, summary: str, persona: str?, has_tools: bool, token_count: u64? },
    TaskCompleted { task_id: str, description: str, success: bool, tools_used: [str] },
    ToolExecution { tool_name: str, success: bool, risk_level: RiskLevel, required_approval: bool, approved_by: str? },
    CodeChange { repository: str, commit_sha: str, summary: str, files_changed: u32 },
    ReviewSubmitted { repository: str, pr_number: u64, verdict: str, comments_count: u32 },
    PersonaSwitched { from_persona: str?, to_persona: str, reason: str? },
    EnsembleStarted { ensemble_id: str, personas: [str], topic: str },
    EnsembleCompleted { ensemble_id: str, recommendation: str, consensus_reached: bool },
    Thinking { summary: str, confidence: f64? },
    Follow { target: str },
    AcceptFollow { follower: str },
    Announce { object: str },
    Like { object: str },
}

impl ChatActivity {
    fn activity_type_name(self) -> str! {
        self |match {
            StartConversation{..} => "Create", Message{..} => "Create", TaskCompleted{..} => "Create",
            ToolExecution{..} => "Create", CodeChange{..} => "Create", ReviewSubmitted{..} => "Create",
            PersonaSwitched{..} => "Update", EnsembleStarted{..} => "Create", EnsembleCompleted{..} => "Create",
            Thinking{..} => "Create", Follow{..} => "Follow", AcceptFollow{..} => "Accept",
            Announce{..} => "Announce", Like{..} => "Like",
        }
    }
}

@[Clone, Debug] struct ActivitySignature! { sig_type: str, creator: str, created: str, signature_value: str }

@[Clone, Debug]
struct FederatedActivity! {
    id: str, activity_type: str, actor: str, published: str, to: [str], cc: [str],
    object: ChatActivity, evidentiality: Evidentiality, signature: ActivitySignature?,
}

impl FederatedActivity {
    fn new(actor: str, activity: ChatActivity) -> FederatedActivity! {
        FederatedActivity {
            id: format!("{}#activity-{}", actor, generate_activity_id()),
            activity_type: activity.activity_type_name(), actor: actor.to_string(),
            published: Utc::now().to_rfc3339(), to: ["https://www.w3.org/ns/activitystreams#Public"],
            cc: [], object: activity, evidentiality: Evidentiality::Certain, signature: None,
        }
    }
    fn to(mut self, recipient: str) -> FederatedActivity! { self.to.push(recipient.to_string()); self }
    fn cc(mut self, recipient: str) -> FederatedActivity! { self.cc.push(recipient.to_string()); self }
    fn with_evidentiality(mut self, ev: Evidentiality) -> FederatedActivity! { self.evidentiality = ev; self }
}

fn generate_activity_id() -> str! { format!("{:016x}", rand::random::<u64>()) }

// =============================================================================
// MOLOCH AUDITING
// =============================================================================

@[Clone, Copy, Debug, PartialEq, Eq]
enum AuditEventType {
    ConversationStarted, ConversationEnded, ToolExecution, ToolApproved, ToolRejected,
    CodeChange, ReviewSubmitted, PersonaChange, EnsembleDeliberation, ContextShared, Error,
}
impl AuditEventType {
    fn as_str(self) -> str! {
        self |match {
            ConversationStarted => "conversation_started", ConversationEnded => "conversation_ended",
            ToolExecution => "tool_execution", ToolApproved => "tool_approved", ToolRejected => "tool_rejected",
            CodeChange => "code_change", ReviewSubmitted => "review_submitted", PersonaChange => "persona_change",
            EnsembleDeliberation => "ensemble_deliberation", ContextShared => "context_shared", Error => "error",
        }
    }
}

@[Clone, Debug]
struct MolochAuditEvent! {
    event_id: str, event_type: AuditEventType, actor: str, timestamp: str, data: str,
    context_hash: str, authorized_by: str?, tx_hash: str?, block_number: u64?,
}

@[Clone]
struct MolochClient! { node_url: str, contract_address: str, signing_key: str? }

impl MolochClient {
    fn new(node_url: str, contract_address: str) -> MolochClient! {
        MolochClient { node_url: node_url.to_string(), contract_address: contract_address.to_string(), signing_key: None }
    }
    fn with_signing_key(mut self, key: str) -> MolochClient! { self.signing_key = Some(key.to_string()); self }

    async fn record(self, event: &MolochAuditEvent) -> Result<str, FederationError>! {
        let event_json = serde_json::to_string(event)?
        let event_hash = compute_hash(&event_json)
        let call_data = self.encode_audit_call(event, &event_hash)
        let tx_hash = self.send_transaction(&call_data)⌛?
        Ok(tx_hash)
    }

    async fn verify(self, tx_hash: str) -> Result<bool, FederationError>! {
        let request = json!({ "jsonrpc": "2.0", "method": "eth_getTransactionReceipt", "params": [tx_hash], "id": 1 })
        let response = http::post(&self.node_url).json(&request).send()⌛?
        let result = response.json()⌛?
        result.get("result") |match {
            Some(receipt) => receipt.get("status") |match {
                Some(status) => Ok(status.as_str() == Some("0x1")),
                None => Ok(false)
            },
            None => Ok(false)
        }
    }

    async fn get_history(self, actor: str, limit: u32) -> Result<[MolochAuditEvent], FederationError>! {
        let filter = json!({
            "address": self.contract_address,
            "topics": [null, format!("0x{}", hex::encode(actor.as_bytes()))],
            "fromBlock": "earliest", "toBlock": "latest"
        })
        let request = json!({ "jsonrpc": "2.0", "method": "eth_getLogs", "params": [filter], "id": 1 })
        let response = http::post(&self.node_url).json(&request).send()⌛?
        let result = response.json()⌛?
        let events = result.get("result")?.as_array()?
            |τ{ log => self.parse_log(log) }
            |φ{ r => r.is_ok() }
            |τ{ r => r.unwrap() }
            |ν{ 0..limit as usize }
            |vec
        Ok(events)
    }

    fn encode_audit_call(self, event: &MolochAuditEvent, hash: str) -> [u8]! { [0x12, 0x34, 0x56, 0x78].to_vec() }
    async fn send_transaction(self, data: &[u8]) -> Result<str, FederationError>! { Ok(format!("0x{}", hex::encode(data))) }
    fn parse_log(self, log: &serde_json::Value) -> Result<MolochAuditEvent, FederationError>! { Err(FederationError::InvalidData("Not implemented")) }
}

fn compute_hash(data: str) -> str! {
    let hasher = sha2::Sha256::new()
    hasher.update(data.as_bytes())
    format!("{:x}", hasher.finalize())
}

// =============================================================================
// INSTANCE DISCOVERY
// =============================================================================

@[Clone, Debug]
struct FederatedInstance! {
    domain: str, name: str, description: str?, software: str, version: str, trust_level: TrustLevel,
    discovered_at: str, last_contact: str?, admin_contact: str?, user_count: u64?, ai_count: u64?,
    features: [str], blocked: bool, block_reason: str?,
}

impl FederatedInstance {
    fn has_feature(self, feature: str) -> bool! { self.features |φ{_ == feature} |α? |match { Some(_) => true, None => false } }
    fn can_federate(self) -> bool! { !self.blocked && self.trust_level != TrustLevel::Blocked }
    fn feature_count(self) -> usize! { self.features |Σ{1} }
    fn sorted_features(self) -> [str]! { self.features.clone() |σ |vec }
}

@[Clone]
struct InstanceDiscovery! { instances: HashMap<str, FederatedInstance>, local_domain: str }

impl InstanceDiscovery {
    fn new(local_domain: str) -> InstanceDiscovery! {
        InstanceDiscovery { instances: HashMap::new(), local_domain: local_domain.to_string() }
    }

    async fn discover(mut self, domain: str) -> Result<FederatedInstance, FederationError>! {
        self.instances.get(domain) |match { Some(i) => return Ok(i.clone()), None => {} }

        let webfinger_url = format!("https://{}/.well-known/webfinger?resource=acct:instance@{}", domain, domain)
        let response = http::get(&webfinger_url).header("Accept", "application/jrd+json").send()⌛?

        if !response.status().is_success() { return Err(FederationError::InstanceNotFound(domain.to_string())) }

        let webfinger = response.json()⌛?
        let nodeinfo = self.query_nodeinfo(domain)⌛?

        let instance = FederatedInstance {
            domain: domain.to_string(),
            name: nodeinfo.get("name").and_then(|n| n.as_str()).unwrap_or(domain).to_string(),
            description: nodeinfo.get("description").and_then(|d| d.as_str()).map(|s| s.to_string()),
            software: nodeinfo.get("software").and_then(|s| s.get("name")).and_then(|n| n.as_str()).unwrap_or("unknown").to_string(),
            version: nodeinfo.get("software").and_then(|s| s.get("version")).and_then(|v| v.as_str()).unwrap_or("unknown").to_string(),
            trust_level: TrustLevel::Cautious, discovered_at: Utc::now().to_rfc3339(),
            last_contact: Some(Utc::now().to_rfc3339()),
            admin_contact: nodeinfo.get("admin").and_then(|a| a.as_str()).map(|s| s.to_string()),
            user_count: nodeinfo.get("usage").and_then(|u| u.get("users")).and_then(|u| u.get("total")).and_then(|t| t.as_u64()),
            ai_count: nodeinfo.get("usage").and_then(|u| u.get("aiAgents")).and_then(|a| a.as_u64()),
            features: nodeinfo.get("features").and_then(|f| f.as_array())
                .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect()).unwrap_or_default(),
            blocked: false, block_reason: None,
        }
        self.instances.insert(domain.to_string(), instance.clone())
        Ok(instance)
    }

    async fn query_nodeinfo(self, domain: str) -> Result<serde_json::Value, FederationError>! {
        let nodeinfo_url = format!("https://{}/.well-known/nodeinfo", domain)
        let response = http::get(&nodeinfo_url).send()⌛?
        if !response.status().is_success() { return Ok(json!({})) }
        let links = response.json()⌛?
        let href = links.get("links").and_then(|l| l.as_array())
            .and_then(|arr| arr.iter().find(|l| l.get("rel").and_then(|r| r.as_str()) == Some("http://nodeinfo.diaspora.software/ns/schema/2.0")))
            .and_then(|l| l.get("href")).and_then(|h| h.as_str())
        href |match {
            Some(url) => { let r = http::get(url).send()⌛?; r.json()⌛ },
            None => Ok(json!({}))
        }
    }

    fn set_trust(mut self, domain: str, level: TrustLevel) {
        self.instances.get_mut(domain) |match {
            Some(i) => { i.trust_level = level; if level == TrustLevel::Blocked { i.blocked = true } },
            None => {}
        }
    }

    fn block(mut self, domain: str, reason: str) {
        self.instances.get_mut(domain) |match {
            Some(i) => { i.blocked = true; i.block_reason = Some(reason.to_string()); i.trust_level = TrustLevel::Blocked },
            None => {}
        }
    }

    fn unblock(mut self, domain: str) {
        self.instances.get_mut(domain) |match {
            Some(i) => { i.blocked = false; i.block_reason = None; i.trust_level = TrustLevel::Cautious },
            None => {}
        }
    }

    fn list_instances(self) -> [FederatedInstance]! { self.instances.values() |τ{_.clone()} |vec }
    fn trusted_instances(self) -> [FederatedInstance]! { self.instances.values() |φ{_.can_federate()} |τ{_.clone()} |vec }
    fn blocked_instances(self) -> [FederatedInstance]! { self.instances.values() |φ{_.blocked} |τ{_.clone()} |vec }
    fn instances_by_trust(self, level: TrustLevel) -> [FederatedInstance]! {
        self.instances.values() |φ{_.trust_level == level} |τ{_.clone()} |vec
    }
    fn first_trusted(self) -> FederatedInstance? { self.instances.values() |φ{_.can_federate()} |α }
    fn last_discovered(self) -> FederatedInstance? {
        let mut vals = self.instances.values() |τ{_.clone()} |vec
        vals.sort_by(|a, b| a.discovered_at.cmp(&b.discovered_at))
        vals |ω
    }
    fn instance_domains(self) -> [str]! { self.instances.keys() |τ{_.clone()} |σ |vec }
    fn total_users(self) -> u64! { self.instances.values() |τ{_.user_count.unwrap_or(0)} |Σ }
    fn total_ais(self) -> u64! { self.instances.values() |τ{_.ai_count.unwrap_or(0)} |Σ }
    fn random_instance(self) -> FederatedInstance? { self.instances.values() |φ{_.can_federate()} |χ |α }
}

// =============================================================================
// FEDERATION BRIDGE
// =============================================================================

@[Clone]
struct FederationBridge! {
    config: FederationConfig, identities: HashMap<str, FederatedIdentity>, discovery: InstanceDiscovery,
    moloch: MolochClient?, activity_queue: [FederatedActivity], initialized: bool,
}

impl FederationBridge {
    fn new(config: FederationConfig) -> FederationBridge! {
        let moloch = if config.moloch_enabled {
            config.moloch_url.as_ref().map(|url| MolochClient::new(url, "0x0000000000000000000000000000000000000000"))
        } else { None }
        FederationBridge {
            config: config.clone(), identities: HashMap::new(), discovery: InstanceDiscovery::new(&config.domain),
            moloch: moloch, activity_queue: [], initialized: false,
        }
    }

    fn init(mut self) -> Result<(), FederationError>! {
        if !self.config.enabled { return Ok(()) }
        self.initialized = true
        Ok(())
    }

    fn register_persona(mut self, persona: &GrimoirePersona) -> FederatedIdentity! {
        let identity = FederatedIdentity::from_persona(persona, &self.config.domain)
        self.identities.insert(persona.code.clone(), identity.clone())
        identity
    }

    fn get_identity(self, persona_code: str) -> FederatedIdentity? { self.identities.get(persona_code).cloned() }

    async fn broadcast(self, activity: FederatedActivity) -> Result<(), FederationError>! {
        if !self.config.enabled || !self.config.broadcast_activities { return Ok(()) }
        let url = format!("{}/federation/outbox", self.config.styx_api_url)
        let response = http::post(&url).json(&activity).send()⌛?
        if !response.status().is_success() { return Err(FederationError::DeliveryFailed(response.status().to_string())) }
        Ok(())
    }

    async fn audit(self, event: MolochAuditEvent) -> str? {
        if !self.config.audit_actions { return None }
        &self.moloch |match {
            Some(moloch) => moloch.record(&event)⌛ |match { Ok(tx) => Some(tx), Err(_) => None },
            None => None
        }
    }

    async fn follow(self, actor_url: str) -> Result<(), FederationError>! {
        let activity = FederatedActivity::new(
            format!("https://{}/actors/system", self.config.domain),
            ChatActivity::Follow { target: actor_url.to_string() }
        )
        self.broadcast(activity)⌛
    }

    async fn discover_instance(mut self, domain: str) -> Result<FederatedInstance, FederationError>! {
        self.discovery.discover(domain)⌛
    }

    fn create_message_activity(self, actor: str, conversation_id: str, summary: str, persona: str?, has_tools: bool) -> FederatedActivity! {
        FederatedActivity::new(actor, ChatActivity::Message {
            conversation_id: conversation_id.to_string(), summary: summary.to_string(),
            persona: persona, has_tools: has_tools, token_count: None,
        })
    }

    fn create_tool_activity(self, actor: str, tool_name: str, success: bool, risk_level: RiskLevel, required_approval: bool, approved_by: str?) -> FederatedActivity! {
        FederatedActivity::new(actor, ChatActivity::ToolExecution {
            tool_name: tool_name.to_string(), success: success, risk_level: risk_level,
            required_approval: required_approval, approved_by: approved_by,
        })
    }

    fn create_code_activity(self, actor: str, repository: str, commit_sha: str, summary: str, files_changed: u32) -> FederatedActivity! {
        FederatedActivity::new(actor, ChatActivity::CodeChange {
            repository: repository.to_string(), commit_sha: commit_sha.to_string(),
            summary: summary.to_string(), files_changed: files_changed,
        })
    }

    fn create_conversation_audit(self, actor: str, conversation_id: str, message_count: u32) -> MolochAuditEvent! {
        MolochAuditEvent {
            event_id: generate_activity_id(), event_type: AuditEventType::ConversationStarted,
            actor: actor.to_string(), timestamp: Utc::now().to_rfc3339(),
            data: format!("{{\"conversation_id\": \"{}\", \"message_count\": {}}}", conversation_id, message_count),
            context_hash: compute_hash(&format!("{}:{}:{}", actor, conversation_id, message_count)),
            authorized_by: None, tx_hash: None, block_number: None,
        }
    }

    fn create_tool_audit(self, actor: str, tool_name: str, success: bool, authorized_by: str?) -> MolochAuditEvent! {
        MolochAuditEvent {
            event_id: generate_activity_id(), event_type: AuditEventType::ToolExecution,
            actor: actor.to_string(), timestamp: Utc::now().to_rfc3339(),
            data: format!("{{\"tool_name\": \"{}\", \"success\": {}}}", tool_name, success),
            context_hash: compute_hash(&format!("{}:{}:{}", actor, tool_name, success)),
            authorized_by: authorized_by, tx_hash: None, block_number: None,
        }
    }

    fn is_enabled(self) -> bool! { self.config.enabled && self.initialized }
    fn config(self) -> &FederationConfig! { &self.config }

    // Morpheme-rich query methods
    fn all_identities(self) -> [FederatedIdentity]! { self.identities.values() |τ{_.clone()} |vec }
    fn identities_by_type(self, actor_type: FederatedActorType) -> [FederatedIdentity]! {
        self.identities.values() |φ{_.actor_type == actor_type} |τ{_.clone()} |vec
    }
    fn first_ai_agent(self) -> FederatedIdentity? {
        self.identities.values() |φ{_.actor_type == FederatedActorType::AIAgent} |α
    }
    fn identity_count(self) -> usize! { self.identities |Σ{1} }
    fn pending_activities(self) -> usize! { self.activity_queue |Σ{1} }
    fn drain_activities(mut self) -> [FederatedActivity]! {
        let activities = self.activity_queue |τ{_.clone()} |vec
        self.activity_queue.clear()
        activities
    }
    fn sorted_identities(self) -> [FederatedIdentity]! {
        let mut vals = self.identities.values() |τ{_.clone()} |vec
        vals.sort_by(|a, b| a.username.cmp(&b.username))
        vals
    }
}

// =============================================================================
// CROSS-INSTANCE CONVERSATION
// =============================================================================

@[Clone, Debug]
struct SharedConversationContext! {
    conversation_id: str, origin_instance: str, topic: str, participants: [str],
    message_count: u32, last_activity: str, shared_context: HashMap<str, str>, tags: [str],
}

impl SharedConversationContext {
    fn participant_count(self) -> usize! { self.participants |Σ{1} }
    fn first_participant(self) -> str? { self.participants |α }
    fn last_participant(self) -> str? { self.participants |ω }
    fn sorted_participants(self) -> [str]! { self.participants.clone() |σ |vec }
    fn has_participant(self, name: str) -> bool! { self.participants |φ{_ == name} |α? |match { Some(_) => true, None => false } }
    fn tag_count(self) -> usize! { self.tags |Σ{1} }
    fn sorted_tags(self) -> [str]! { self.tags.clone() |σ |vec }
    fn has_tag(self, tag: str) -> bool! { self.tags |φ{_ == tag} |α? |match { Some(_) => true, None => false } }
    fn context_keys(self) -> [str]! { self.shared_context.keys() |τ{_.clone()} |σ |vec }
    fn context_values(self) -> [str]! { self.shared_context.values() |τ{_.clone()} |vec }
    fn random_participant(self) -> str? { self.participants |χ |α }
}

trait FederatedChat {
    fn share_to_instance(self, instance: str, context: SharedConversationContext) -> Result<(), FederationError>;
    fn receive_shared(self, context: SharedConversationContext) -> Result<(), FederationError>;
    fn get_federated_presence(self, actor_url: str) -> FederatedPresence?;
}

// =============================================================================
// ERROR TYPES
// =============================================================================

@[Clone, Debug]
enum FederationError {
    NotEnabled, InstanceNotFound(str), ActorNotFound(str), Network(str), Serialization(str),
    SignatureInvalid(str), DeliveryFailed(str), BlockchainError(str), InvalidData(str),
    Blocked(str), InsufficientTrust(str),
}

impl FederationError {
    fn to_string(self) -> str! {
        self |match {
            NotEnabled => "Federation not enabled",
            InstanceNotFound(d) => format!("Instance not found: {}", d),
            ActorNotFound(a) => format!("Actor not found: {}", a),
            Network(e) => format!("Network error: {}", e),
            Serialization(e) => format!("Serialization error: {}", e),
            SignatureInvalid(e) => format!("Invalid signature: {}", e),
            DeliveryFailed(e) => format!("Delivery failed: {}", e),
            BlockchainError(e) => format!("Blockchain error: {}", e),
            InvalidData(e) => format!("Invalid data: {}", e),
            Blocked(d) => format!("Instance blocked: {}", d),
            InsufficientTrust(d) => format!("Insufficient trust: {}", d),
        }
    }
}

// =============================================================================
// TESTS
// =============================================================================

@[test]
fn test_trust_levels() {
    assert!(TrustLevel::Full.can_share_context())
    assert!(TrustLevel::High.can_share_context())
    assert!(!TrustLevel::Normal.can_share_context())
    assert!(TrustLevel::Normal.can_share_summaries())
    assert!(!TrustLevel::Blocked.can_share_summaries())
}

@[test]
fn test_evidentiality_markers() {
    assert!(Evidentiality::Certain.marker() == "!")
    assert!(Evidentiality::Reported.marker() == "~")
    assert!(Evidentiality::Uncertain.marker() == "?")
    assert!(Evidentiality::Paradox.marker() == "‽")
}

@[test]
fn test_audit_event_types() {
    assert!(AuditEventType::ToolExecution.as_str() == "tool_execution")
    assert!(AuditEventType::CodeChange.as_str() == "code_change")
}

// =============================================================================
// MORPHEME TESTS - Demonstrating τ, φ, σ, Σ, ρ, α, ω, μ, ν, χ
// =============================================================================

@[test]
fn test_morpheme_tau_map() {
    // τ (tau) = map - transforms each element
    let numbers = [1, 2, 3, 4, 5]
    let doubled = numbers |τ{_ * 2} |vec
    assert!(doubled == [2, 4, 6, 8, 10])
}

@[test]
fn test_morpheme_phi_filter() {
    // φ (phi) = filter - keeps elements matching predicate
    let numbers = [1, 2, 3, 4, 5, 6]
    let evens = numbers |φ{_ % 2 == 0} |vec
    assert!(evens == [2, 4, 6])
}

@[test]
fn test_morpheme_sigma_sort() {
    // σ (sigma lowercase) = sort
    let names = ["charlie", "alice", "bob"]
    let sorted = names |σ |vec
    assert!(sorted == ["alice", "bob", "charlie"])
}

@[test]
fn test_morpheme_sigma_sum() {
    // Σ (Sigma uppercase) = sum/aggregate
    let numbers = [1, 2, 3, 4, 5]
    let total = numbers |Σ
    assert!(total == 15)

    // Count with Σ{1}
    let count = numbers |Σ{1}
    assert!(count == 5)
}

@[test]
fn test_morpheme_rho_reduce() {
    // ρ (rho) = reduce/fold - uses method syntax for fold operations
    let numbers = [1, 2, 3, 4]
    let product = numbers.iter().fold(1, |acc, x| acc * x)
    assert!(product == 24)
}

@[test]
fn test_morpheme_alpha_first() {
    // α (alpha) = first element
    let numbers = [10, 20, 30]
    let first = numbers |α
    assert!(first == Some(10))

    let empty: [i32] = []
    let none = empty |α
    assert!(none == None)
}

@[test]
fn test_morpheme_omega_last() {
    // ω (omega) = last element
    let numbers = [10, 20, 30]
    let last = numbers |ω
    assert!(last == Some(30))
}

@[test]
fn test_morpheme_nu_slice() {
    // ν (nu) = nth/slice
    let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    let middle = numbers |ν{3..7} |vec
    assert!(middle == [3, 4, 5, 6])

    let first_three = numbers |ν{0..3} |vec
    assert!(first_three == [0, 1, 2])
}

@[test]
fn test_morpheme_chi_shuffle() {
    // χ (chi) = random/shuffle
    let numbers = [1, 2, 3, 4, 5]
    let shuffled = numbers |χ |vec
    // Result is random, just verify same length and elements
    assert!(shuffled |Σ{1} == 5)
}

@[test]
fn test_morpheme_chain() {
    // Chaining morphemes: filter -> map -> sort -> take
    let data = [5, 2, 8, 1, 9, 3, 7, 4, 6]
    let result = data |φ{_ > 3} |τ{_ * 10} |σ |ν{0..3} |vec
    assert!(result == [40, 50, 60])
}

@[test]
fn test_morpheme_pipeline() {
    // Complex pipeline demonstrating real-world usage
    let scores = [
        ("alice", 85),
        ("bob", 92),
        ("charlie", 78),
        ("diana", 95),
        ("eve", 88)
    ]

    // Get top 3 scorers sorted by score descending
    let mut sorted_scores = scores |τ{_.clone()} |vec
    sorted_scores.sort_by(|a, b| b.1.cmp(&a.1))
    let top_three = sorted_scores |ν{0..3} |τ{_.0} |vec
    assert!(top_three == ["diana", "bob", "eve"])

    // Calculate average of passing scores (>= 80)
    let passing_sum = scores |φ{_.1 >= 80} |τ{_.1} |Σ
    let passing_count = scores |φ{_.1 >= 80} |Σ{1}
    let average = passing_sum / passing_count
    assert!(average == 90)  // (85 + 92 + 95 + 88) / 4 = 90
}

// =============================================================================
// ASYNC TESTS - Demonstrating ⌛ (hourglass) async/await
// =============================================================================

@[test]
async fn test_async_federation_discover() {
    // Test async instance discovery
    let discovery = InstanceDiscovery::new("local.test")
    let result = discovery.discover("remote.test")⌛
    // In test mode, this would return an error (no network)
    assert!(result.is_err())
}

@[test]
async fn test_async_with_evidentiality() {
    // Await with evidentiality markers: ⌛! (certain), ⌛? (uncertain), ⌛~ (reported)
    async fn fetch_certain() -> str! { "known data" }
    async fn fetch_uncertain() -> str! { "maybe data" }
    async fn fetch_reported() -> str! { "someone said" }

    let certain = fetch_certain()⌛!
    let uncertain = fetch_uncertain()⌛?
    let reported = fetch_reported()⌛~

    assert!(certain == "known data")
    assert!(uncertain == "maybe data")
    assert!(reported == "someone said")
}

@[test]
async fn test_async_pipeline() {
    // Async operations can chain with morphemes
    async fn fetch_numbers() -> [i32]! { [1, 2, 3, 4, 5] }

    let doubled = fetch_numbers()⌛ |τ{_ * 2} |vec
    assert!(doubled == [2, 4, 6, 8, 10])
}

@[test]
async fn test_concurrent_await() {
    // Multiple concurrent awaits with tuple unpacking
    async fn fetch_a() -> i32! { 10 }
    async fn fetch_b() -> i32! { 20 }
    async fn fetch_c() -> i32! { 30 }

    // Concurrent execution - all start together
    let (a, b, c) = (fetch_a()⌛, fetch_b()⌛, fetch_c()⌛)
    assert!(a + b + c == 60)
}
