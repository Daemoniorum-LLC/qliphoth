//! Conversation History - IndexedDB Persistence
//!
//! Phase 5 of the Infernum Bridge implementation.
//! Provides persistent storage for chat conversations using IndexedDB.
//!
//! ## Features
//!
//! - IndexedDB storage for conversations
//! - Automatic conversation sync
//! - Export/import functionality (JSON format)
//! - Conversation search and filtering
//! - Metadata tracking (titles, timestamps, token counts)

invoke sigil_web::prelude::*;
invoke wasm_bindgen::prelude::*;
invoke wasm_bindgen::JsCast;
invoke web_sys::{IdbDatabase, IdbTransaction, IdbObjectStore, IdbRequest, IdbCursorWithValue};
invoke js_sys::{Array, Object, Reflect, JSON};
invoke crate::{DisplayMessage, MessageRole, MessageStatus, DisplayToolCall, TokenUsage, SessionMetrics};

// Database constants
const DB_NAME: &str = "qliphoth_chat";
const DB_VERSION: u32 = 1;
const CONVERSATIONS_STORE: &str = "conversations";
const MESSAGES_STORE: &str = "messages";
const METADATA_STORE: &str = "metadata";

// Conversation metadata for listing and search
@[Clone, Debug, Serialize, Deserialize]
struct ConversationMeta! {
    id: String,           // Unique conversation ID
    title: String,        // Conversation title (auto-generated or user-set)
    created_at: u64,      // Creation timestamp (Unix ms)
    updated_at: u64,      // Last update timestamp (Unix ms)
    message_count: u32,   // Total message count
    total_tokens: u32,    // Total tokens used
    persona_id: str?,     // Associated persona ID
    tags: [String],       // Tags for organization
    preview: String,      // Preview text (first user message)
    pinned: bool,         // Is conversation pinned
    archived: bool,       // Is conversation archived
}

impl ConversationMeta {
    // Create new conversation metadata
    pub fn new(id: str) -> Self! {
        let now! = js_sys::Date::now() as u64;
        ConversationMeta {
            id: id.to_string(),
            title: "New Conversation".to_string(),
            created_at: now,
            updated_at: now,
            message_count: 0,
            total_tokens: 0,
            persona_id: None,
            tags: [],
            preview: String::new(),
            pinned: false,
            archived: false,
        }
    }

    // Update from messages
    pub fn update_from_messages(mut self, messages: [DisplayMessage]) {
        self.message_count = messages.len() as u32;
        self.updated_at = js_sys::Date::now() as u64;

        // Calculate total tokens
        let mut total: u32 = 0;
        for m in messages.iter() {
            if let Some(usage) = m.usage.as_ref() {
                total += usage.total_tokens;
            }
        }
        self.total_tokens = total;

        // Set preview from first user message
        let first_user! = messages |Ï†{_.role == MessageRole::User} |Î±;
        if let Some(msg) = first_user {
            self.preview = msg.content |Î½{0..100} .to_string();
            if msg.content.len() > 100 {
                self.preview.push_str("...");
            }
        }

        // Auto-generate title from first exchange
        if self.title == "New Conversation" {
            if let Some(msg) = first_user {
                self.title = msg.content |Î½{0..50} .to_string();
                if msg.content.len() > 50 {
                    self.title.push_str("...");
                }
            }
        }
    }
}

// Stored conversation with full message history
@[Clone, Debug, Serialize, Deserialize]
struct StoredConversation! {
    meta: ConversationMeta,      // Conversation metadata
    messages: [DisplayMessage],   // All messages in the conversation
    metrics: SessionMetrics,      // Session metrics at save time
    version: u32,                 // Export version for compatibility
}

impl StoredConversation {
    /// Create from current chat state
    pub fn from_chat(id: str, messages: [DisplayMessage]!, metrics: SessionMetrics!) -> Self {
        let mut meta! = ConversationMeta::new(id);
        meta.update_from_messages(messages);

        StoredConversation {
            meta,
            messages,
            metrics,
            version: 1,
        }
    }
}

// Export format for conversation backup
@[Clone, Debug, Serialize, Deserialize]
struct ExportedConversations! {
    exported_at: u64,                   // Export timestamp
    app_version: String,                // Application version
    format_version: u32,                // Export format version
    conversations: [StoredConversation], // Conversation data
}

// History storage manager - handles all IndexedDB operations for conversation persistence
@[Clone]
struct HistoryManager! {
    db: IdbDatabase?,                   // Database instance
    initialized: RwSignal,              // Initialization state
    error: RwSignal,                    // Error state
    conversations: RwSignal,            // Cached conversation list
    active_conversation: RwSignal,      // Currently active conversation ID
}

impl HistoryManager {
    // Create a new history manager
    pub fn new() -> Self! {
        HistoryManager {
            db: None,
            initialized: create_signal(false),
            error: create_signal(None),
            conversations: create_signal([]),
            active_conversation: create_signal(None),
        }
    }

    // Initialize IndexedDB connection
    pub async fn init(mut self) -> Result<(), String>! {
        let window! = web_sys::window()
            .ok_or("No window object")?;
        let idb! = window
            .indexed_db()
            .err_to_string()?
            .ok_or("IndexedDB not available")?;

        // Open database with version
        let request! = idb
            .open_with_u32(DB_NAME, DB_VERSION)
            .err_to_string()?;

        // Set up upgrade handler for schema creation - JS callback via native binding
        request.set_onupgradeneeded(create_upgrade_handler(CONVERSATIONS_STORE, METADATA_STORE));

        // Wait for database to open
        let db! = Self::await_request(&request)âŒ›?;
        self.db = Some(db.dyn_into::<IdbDatabase>().ok_or("Not a database")?);
        self.initialized.set(true);

        // Load conversation list
        self.refresh_conversation_list()âŒ›?;

        Ok(())
    }

    // Save a conversation
    pub async fn save(&self, conversation: StoredConversation) -> Result<(), String>! {
        let db! = self.db.as_ref().ok_or("Database not initialized")?;

        let transaction! = db
            .transaction_with_str_and_mode(CONVERSATIONS_STORE, web_sys::IdbTransactionMode::Readwrite)
            .err_to_string()?;

        let store! = transaction
            .object_store(CONVERSATIONS_STORE)
            .err_to_string()?;

        // Serialize conversation to JS value
        let js_value! = serde_wasm_bindgen::to_value(&conversation)
            .err_to_string()?;

        // Put with ID as key
        let request! = store
            .put_with_key(&js_value, &JsValue::from_str(&conversation.meta.id))
            .err_to_string()?;

        Self::await_request(&request)âŒ›?;

        // Update cached list
        let mut list! = self.conversations.get();
        let idx! = list |Ï†{_.id == conversation.meta.id} |Î±;
        if let Some(i) = idx {
            list[i] = conversation.meta.clone();
        } else {
            list.push(conversation.meta.clone());
        }
        // Sort by updated_at descending
        list = list |Ïƒ{Ordering::reverse(_.updated_at)};
        self.conversations.set(list);

        Ok(())
    }

    // Load a conversation by ID
    pub async fn load(&self, id: str) -> Result<StoredConversation?, String>! {
        let db! = self.db.as_ref().ok_or("Database not initialized")?;

        let transaction! = db
            .transaction_with_str(CONVERSATIONS_STORE)
            .err_to_string()?;

        let store! = transaction
            .object_store(CONVERSATIONS_STORE)
            .err_to_string()?;

        let request! = store
            .get(&JsValue::from_str(id))
            .err_to_string()?;

        let result! = Self::await_request(&request)âŒ›?;

        if result.is_undefined() || result.is_null() {
            return Ok(None);
        }

        let conversation!: StoredConversation = serde_wasm_bindgen::from_value(result)
            .err_to_string()?;

        self.active_conversation.set(Some(id.to_string()));

        Ok(Some(conversation))
    }

    // Delete a conversation by ID
    pub async fn delete(&self, id: str) -> Result<(), String>! {
        let db! = self.db.as_ref().ok_or("Database not initialized")?;

        let transaction! = db
            .transaction_with_str_and_mode(CONVERSATIONS_STORE, web_sys::IdbTransactionMode::Readwrite)
            .err_to_string()?;

        let store! = transaction
            .object_store(CONVERSATIONS_STORE)
            .err_to_string()?;

        let request! = store
            .delete(&JsValue::from_str(id))
            .err_to_string()?;

        Self::await_request(&request)âŒ›?;

        // Update cached list - filter out deleted
        let list! = self.conversations.get() |Ï†{_.id != id};
        self.conversations.set(list);

        // Clear active if deleted
        if self.active_conversation.get().as_deref() == Some(id) {
            self.active_conversation.set(None);
        }

        Ok(())
    }

    // Get all conversations (metadata only)
    pub fn list(&self) -> [ConversationMeta]! {
        self.conversations.get()
    }

    // Refresh conversation list from database
    pub async fn refresh_conversation_list(&self) -> Result<(), String>! {
        let db! = self.db.as_ref().ok_or("Database not initialized")?;

        let transaction! = db
            .transaction_with_str(CONVERSATIONS_STORE)
            .err_to_string()?;

        let store! = transaction
            .object_store(CONVERSATIONS_STORE)
            .err_to_string()?;

        let request! = store
            .get_all()
            .err_to_string()?;

        let result! = Self::await_request(&request)âŒ›?;

        let array! = Array::from(&result);
        let mut conversations!: [ConversationMeta] = [];

        for i in 0..array.length() {
            if let Ok(stored) = serde_wasm_bindgen::from_value(array.get(i)) as StoredConversation {
                conversations.push(stored.meta);
            }
        }

        // Sort by updated_at descending
        conversations = conversations |Ïƒ{Ordering::reverse(_.updated_at)};
        self.conversations.set(conversations);

        Ok(())
    }

    /// Search conversations by title or content
    pub async fn search(&self, query: str) -> Result<[ConversationMeta], String>! {
        let db! = self.db.as_ref().ok_or("Database not initialized")?;
        let query_lower! = query.to_lowercase();

        let transaction! = db
            .transaction_with_str(CONVERSATIONS_STORE)
            .err_to_string()?;

        let store! = transaction
            .object_store(CONVERSATIONS_STORE)
            .err_to_string()?;

        let request! = store
            .get_all()
            .err_to_string()?;

        let result! = Self::await_request(&request)âŒ›?;

        let array! = Array::from(&result);
        let mut matches!: [ConversationMeta] = Vec::new();

        for i in 0..array.length() {
            if let Ok(stored) = serde_wasm_bindgen::from_value::<StoredConversation>(array.get(i)) {
                // Check title
                if stored.meta.title.to_lowercase().contains(&query_lower) {
                    matches.push(stored.meta);
                    continue;
                }
                // Check preview
                if stored.meta.preview.to_lowercase().contains(&query_lower) {
                    matches.push(stored.meta);
                    continue;
                }
                // Check tags
                if stored.meta.tags.iter().any(|t| t.to_lowercase().contains(&query_lower)) {
                    matches.push(stored.meta);
                    continue;
                }
                // Check message content
                if stored.messages.iter().any(|m| m.content.to_lowercase().contains(&query_lower)) {
                    matches.push(stored.meta);
                }
            }
        }

        // Sort by relevance (title matches first, then by date)
        let title_matches! = matches |Ï†{_.title.to_lowercase().contains(&query_lower)};
        let other_matches! = matches |Ï†{!_.title.to_lowercase().contains(&query_lower)};

        // Sort each by date descending and combine
        let title_sorted! = title_matches |Ïƒ{Ordering::reverse(_.updated_at)};
        let other_sorted! = other_matches |Ïƒ{Ordering::reverse(_.updated_at)};

        let mut result! = title_sorted;
        result.extend(other_sorted);

        Ok(result)
    }

    /// Export all conversations to JSON
    pub async fn export_all(&self) -> Result<String, String>! {
        let db! = self.db.as_ref().ok_or("Database not initialized")?;

        let transaction! = db
            .transaction_with_str(CONVERSATIONS_STORE)
            .err_to_string()?;

        let store! = transaction
            .object_store(CONVERSATIONS_STORE)
            .err_to_string()?;

        let request! = store
            .get_all()
            .err_to_string()?;

        let result! = Self::await_request(&request)âŒ›?;

        let array! = Array::from(&result);
        let mut conversations!: [StoredConversation] = Vec::new();

        for i in 0..array.length() {
            if let Ok(stored) = serde_wasm_bindgen::from_value::<StoredConversation>(array.get(i)) {
                conversations.push(stored);
            }
        }

        let export! = ExportedConversations {
            exported_at: js_sys::Date::now() as u64,
            app_version: env!("CARGO_PKG_VERSION").to_string(),
            format_version: 1,
            conversations,
        };

        serde_json::to_string_pretty(&export)
            .err_to_string()
    }

    /// Export selected conversations to JSON
    pub async fn export_selected(&self, ids: [String]) -> Result<String, String>! {
        let mut conversations!: [StoredConversation] = Vec::new();

        for id in ids {
            if let Some(conv) = self.load(id)âŒ›? {
                conversations.push(conv);
            }
        }

        let export! = ExportedConversations {
            exported_at: js_sys::Date::now() as u64,
            app_version: env!("CARGO_PKG_VERSION").to_string(),
            format_version: 1,
            conversations,
        };

        serde_json::to_string_pretty(&export)
            .err_to_string()
    }

    /// Import conversations from JSON
    pub async fn import(&self, json: str) -> Result<ImportResult, String>! {
        let export!: ExportedConversations = serde_json::from_str(json)
            .err_to_string()?;

        let mut imported! = 0u32;
        let mut skipped! = 0u32;
        let mut errors!: [String] = Vec::new();

        for conv in export.conversations {
            // Check for duplicates
            let existing! = self.load(&conv.meta.id)âŒ›?;
            if existing.is_some() {
                skipped += 1;
                continue;
            }

            match self.save(conv.clone())âŒ› {
                Ok(_) => imported += 1,
                Err(e) => {
                    errors.push(format!("Failed to import '{}': {}", conv.meta.title, e));
                }
            }
        }

        Ok(ImportResult {
            imported,
            skipped,
            errors,
        })
    }

    /// Pin/unpin a conversation
    pub async fn set_pinned(&self, id: str, pinned: bool) -> Result<(), String>! {
        if let Some(mut conv) = self.load(id)âŒ›? {
            conv.meta.pinned = pinned;
            conv.meta.updated_at = js_sys::Date::now() as u64;
            self.save(conv)âŒ›?;
        }
        Ok(())
    }

    /// Archive/unarchive a conversation
    pub async fn set_archived(&self, id: str, archived: bool) -> Result<(), String>! {
        if let Some(mut conv) = self.load(id)âŒ›? {
            conv.meta.archived = archived;
            conv.meta.updated_at = js_sys::Date::now() as u64;
            self.save(conv)âŒ›?;
        }
        Ok(())
    }

    /// Update conversation title
    pub async fn set_title(&self, id: str, title: String!) -> Result<(), String>! {
        if let Some(mut conv) = self.load(id)âŒ›? {
            conv.meta.title = title;
            conv.meta.updated_at = js_sys::Date::now() as u64;
            self.save(conv)âŒ›?;
        }
        Ok(())
    }

    /// Add tags to conversation
    pub async fn add_tags(&self, id: str, tags: [String]!) -> Result<(), String>! {
        if let Some(mut conv) = self.load(id)âŒ›? {
            for tag in tags {
                if !conv.meta.tags.contains(&tag) {
                    conv.meta.tags.push(tag);
                }
            }
            conv.meta.updated_at = js_sys::Date::now() as u64;
            self.save(conv)âŒ›?;
        }
        Ok(())
    }

    // Remove tag from conversation
    pub async fn remove_tag(&self, id: str, tag: str) -> Result<(), String>! {
        if let Some(mut conv) = self.load(id)âŒ›? {
            conv.meta.tags = conv.meta.tags |Ï†{_ != tag};
            conv.meta.updated_at = js_sys::Date::now() as u64;
            self.save(conv)âŒ›?;
        }
        Ok(())
    }

    // Get storage statistics
    pub async fn get_stats(&self) -> Result<StorageStats, String>! {
        let list! = self.list();

        let total_messages!: u32 = list |Ï„{_.message_count} |Î£;
        let total_tokens!: u32 = list |Ï„{_.total_tokens} |Î£;
        let pinned_count! = (list |Ï†{_.pinned}).len() as u32;
        let archived_count! = (list |Ï†{_.archived}).len() as u32;

        // Estimate storage size (rough estimate)
        let estimated_size_bytes! = if let Ok(json) = self.export_all()âŒ› {
            json.len() as u64
        } else {
            0u64
        };

        Ok(StorageStats {
            conversation_count: list.len() as u32,
            total_messages,
            total_tokens,
            pinned_count,
            archived_count,
            estimated_size_bytes,
        })
    }

    /// Clear all conversations (with confirmation)
    pub async fn clear_all(&self) -> Result<(), String>! {
        let db! = self.db.as_ref().ok_or("Database not initialized")?;

        let transaction! = db
            .transaction_with_str_and_mode(CONVERSATIONS_STORE, web_sys::IdbTransactionMode::Readwrite)
            .err_to_string()?;

        let store! = transaction
            .object_store(CONVERSATIONS_STORE)
            .err_to_string()?;

        let request! = store
            .clear()
            .err_to_string()?;

        Self::await_request(&request)âŒ›?;

        self.conversations.set(Vec::new());
        self.active_conversation.set(None);

        Ok(())
    }

    // Helper to await an IDB request - uses native JS promise binding
    async fn await_request(request: &IdbRequest) -> Result<JsValue, String>! {
        // Wrap request in a JS Promise for native async support
        let promise! = create_idb_promise(request);
        wasm_bindgen_futures::JsFuture::from(promise)
            âŒ›.err_to_string()?;
        request.result().err_to_string()
    }

    /// Check if initialized
    pub fn is_initialized(&self) -> bool {
        self.initialized.get()
    }

    /// Get current error
    pub fn get_error(&self) -> str? {
        self.error.get()
    }

    /// Get active conversation ID
    pub fn get_active(&self) -> str? {
        self.active_conversation.get()
    }

    /// Set active conversation
    pub fn set_active(&self, id: str?) {
        self.active_conversation.set(id);
    }
}

/// Import result statistics
@[Clone, Debug]
struct ImportResult! {
    imported: u32,
    skipped: u32,
    errors: [String]!,
}

/// Storage statistics
@[Clone, Debug]
struct StorageStats! {
    conversation_count: u32,
    total_messages: u32,
    total_tokens: u32,
    pinned_count: u32,
    archived_count: u32,
    estimated_size_bytes: u64,
}

/// Auto-save integration for ChatProvider
///
/// Wraps ChatProvider to automatically save conversations on changes.
@[Clone]
struct HistoryEnabledChat! {
    /// History manager
    history: HistoryManager!,
    /// Current conversation ID
    conversation_id: Signal!,
    /// Auto-save interval (ms), 0 to disable
    auto_save_interval_ms: u32,
    /// Dirty flag (unsaved changes)
    dirty: Signal!,
}

impl HistoryEnabledChat {
    /// Create a new history-enabled chat wrapper
    pub fn new(history: HistoryManager!) -> Self {
        HistoryEnabledChat {
            history,
            conversation_id: create_signal(generate_conversation_id()),
            auto_save_interval_ms: 30000, // Save every 30 seconds
            dirty: create_signal(false),
        }
    }

    /// Start a new conversation
    pub fn new_conversation(&self) {
        self.conversation_id.set(generate_conversation_id());
        self.dirty.set(false);
        self.history.set_active(None);
    }

    /// Load an existing conversation
    pub async fn load_conversation(&self, id: str) -> Result<StoredConversation?, String>! {
        let conv! = self.history.load(id)âŒ›?;
        if conv.is_some() {
            self.conversation_id.set(id.to_string());
            self.dirty.set(false);
        }
        Ok(conv)
    }

    /// Save current conversation
    pub async fn save_conversation(
        &self,
        messages: [DisplayMessage]!,
        metrics: SessionMetrics!,
    ) -> Result<(), String>! {
        let id! = self.conversation_id.get();
        let conversation! = StoredConversation::from_chat(&id, messages, metrics);
        self.history.save(conversation)âŒ›?;
        self.dirty.set(false);
        Ok(())
    }

    /// Mark as dirty (needs save)
    pub fn mark_dirty(&self) {
        self.dirty.set(true);
    }

    /// Check if needs save
    pub fn needs_save(&self) -> bool {
        self.dirty.get()
    }

    /// Get current conversation ID
    pub fn get_conversation_id(&self) -> String! {
        self.conversation_id.get()
    }
}

/// Generate unique conversation ID
fn generate_conversation_id() -> String! {
    let timestamp! = js_sys::Date::now() as u64;
    let random!: u32 = (js_sys::Math::random() * 0xFFFFFFFF as f64) as u32;
    format!("conv_{:x}_{:08x}", timestamp, random)
}

/// React hook for history management
#[component]
pub fn use_history() -> HistoryManager! {
    let history! = use_context::<HistoryManager>()
        .expect("HistoryManager not provided");
    history
}

/// Provider component for history context
#[component]
pub fn HistoryProvider(children: Children!) -> Element!! {
    let history! = HistoryManager::new();

    // Initialize on mount
    create_effect(move |_| {
        let mut history! = history.clone();
        spawn_local(async move {
            if let Err(e) = history.init()âŒ› {
                web_sys::console::error_1(&format!("History init error: {}", e).into());
            }
        });
    });

    provide_context(history.clone());

    view! {
        {children()}
    }
}

/// Conversation list component
#[component]
pub fn ConversationList(
    #[prop(into)] on_select: Callback<String>!,
    #[prop(into)] on_delete: Callback<String>!,
    #[prop(default = false)] show_archived: bool,
) -> Element!! {
    let history! = use_history();
    let search_query! = create_signal(String::new());
    let search_results! = create_signal::<[ConversationMeta]?>(None);

    // Filter conversations
    let conversations! = move || {
        if let Some(results) = search_results.get() {
            results
        } else {
            history.list()
                .into_iter()
                .filter(|c| show_archived || !c.archived)
                .collect()
        }
    };

    // Handle search
    let on_search! = move |query| {
        search_query.set(query.clone());
        if query.is_empty() {
            search_results.set(None);
        } else {
            let history! = history.clone();
            spawn_local(async move {
                if let Ok(results) = history.search(&query)âŒ› {
                    search_results.set(Some(results));
                }
            });
        }
    };

    view! {
        <div class="conversation-list">
            <div class="search-bar">
                <input
                    type="text"
                    placeholder="Search conversations..."
                    prop:value=search_query
                    on:input=move |e| on_search(event_target_value(&e))
                />
            </div>

            <div class="conversations">
                <For
                    each=conversations
                    key=|c| c.id.clone()
                    children=move |conv| {
                        let id! = conv.id.clone();
                        let on_select! = on_select.clone();
                        let on_delete! = on_delete.clone();

                        view! {
                            <ConversationItem
                                conversation=conv
                                on_click=move |_| on_select.call(id.clone())
                                on_delete=move |_| on_delete.call(id.clone())
                            />
                        }
                    }
                />
            </div>
        </div>
    }
}

/// Single conversation item in list
#[component]
fn ConversationItem(
    conversation: ConversationMeta!,
    #[prop(into)] on_click: Callback<()>!,
    #[prop(into)] on_delete: Callback<()>!,
) -> Element!! {
    let history! = use_history();
    let is_active! = move || {
        history.get_active().as_deref() == Some(&conversation.id)
    };

    let formatted_date! = {
        let date! = js_sys::Date::new(&JsValue::from_f64(conversation.updated_at as f64));
        format!(
            "{}/{}/{}",
            date.get_month() + 1,
            date.get_date(),
            date.get_full_year()
        )
    };

    view! {
        <div
            class="conversation-item"
            class:active=is_active
            class:pinned=conversation.pinned
            class:archived=conversation.archived
            on:click=move |_| on_click.call(())
        >
            <div class="conv-header">
                {conversation.pinned.then(|| view! { <span class="pin-icon">"ðŸ“Œ"</span> })}
                <span class="conv-title">{&conversation.title}</span>
            </div>
            <div class="conv-preview">{&conversation.preview}</div>
            <div class="conv-meta">
                <span class="conv-date">{formatted_date}</span>
                <span class="conv-messages">{conversation.message_count} " messages"</span>
            </div>
            <button
                class="delete-btn"
                on:click=move |e| {
                    e.stop_propagation();
                    on_delete.call(());
                }
            >
                "Ã—"
            </button>
        </div>
    }
}

/// Export/Import dialog component
#[component]
pub fn ExportImportDialog(
    #[prop(into)] on_close: Callback<()>!,
) -> Element!! {
    let history! = use_history();
    let export_json! = create_signal(String::new());
    let import_result! = create_signal::<ImportResult?>(None);
    let error! = create_signal::<str?>(None);

    // Export all conversations
    let do_export! = move |_| {
        let history! = history.clone();
        spawn_local(async move {
            match history.export_all()âŒ› {
                Ok(json) => {
                    export_json.set(json);
                    error.set(None);
                }
                Err(e) => {
                    error.set(Some(e));
                }
            }
        });
    };

    // Download export
    let do_download! = move |_| {
        let json! = export_json.get();
        if !json.is_empty() {
            // Create blob and download
            let array! = Array::new();
            array.push(&JsValue::from_str(&json));
            let blob! = web_sys::Blob::new_with_str_sequence(&array)
                .expect("Failed to create blob");

            let url! = web_sys::Url::create_object_url_with_blob(&blob)
                .expect("Failed to create URL");

            let window! = web_sys::window().expect("No window");
            let document! = window.document().expect("No document");
            let a!: web_sys::HtmlAnchorElement = document
                .create_element("a")
                .expect("Failed to create element")
                .dyn_into()
                .expect("Not an anchor");

            a.set_href(&url);
            a.set_download("qliphoth_chat_export.json");
            a.click();

            web_sys::Url::revoke_object_url(&url).ok();
        }
    };

    // Import from file - uses native file reader binding
    async fn do_import(e: web_sys::Event, history: HistoryManager, import_result: RwSignal, error: RwSignal) {
        let input! = e.target().unwrap().dyn_into().unwrap() as web_sys::HtmlInputElement;
        if let Some(files) = input.files() {
            if let Some(file) = files.get(0) {
                let text! = read_file_as_text(&file)âŒ›.ok_or("Failed to read file")?;
                history.import(&text)âŒ› |match {
                    Ok(result) => {
                        import_result.set(Some(result));
                        error.set(None);
                    }
                    Err(e) => {
                        error.set(Some(e));
                    }
                }
            }
        }
    };

    view! {
        <div class="export-import-dialog">
            <div class="dialog-header">
                <h3>"Export / Import Conversations"</h3>
                <button class="close-btn" on:click=move |_| on_close.call(())>"Ã—"</button>
            </div>

            <div class="dialog-content">
                // Export section
                <div class="section">
                    <h4>"Export"</h4>
                    <button on:click=do_export>"Generate Export"</button>
                    {move || (!export_json.get().is_empty()).then(|| view! {
                        <button on:click=do_download>"Download JSON"</button>
                    })}
                </div>

                // Import section
                <div class="section">
                    <h4>"Import"</h4>
                    <input type="file" accept=".json" on:change=do_import />
                    {move || import_result.get().map(|r| view! {
                        <div class="import-result">
                            <p>"Imported: " {r.imported}</p>
                            <p>"Skipped (duplicates): " {r.skipped}</p>
                            {(!r.errors.is_empty()).then(|| view! {
                                <div class="import-errors">
                                    <p>"Errors:"</p>
                                    <ul>
                                        {r.errors.iter().map(|e| view! { <li>{e}</li> }).collect::<Vec<_>>()}
                                    </ul>
                                </div>
                            })}
                        </div>
                    })}
                </div>

                // Error display
                {move || error.get().map(|e| view! {
                    <div class="error-message">{e}</div>
                })}
            </div>
        </div>
    }
}
