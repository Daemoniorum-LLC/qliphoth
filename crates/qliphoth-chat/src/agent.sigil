//! Agent Visibility - Transparent AI Reasoning
//!
//! Surfaces the internal workings of the Persona Framework's 4-layer architecture.
//! Makes AI reasoning visible, auditable, and understandable.
//!
//! ## The Four Layers (Made Visible)
//!
//! 1. **Planning Layer** (OverseerAgent)
//!    - Task decomposition into subtasks
//!    - Dependency graph visualization
//!    - Validation criteria
//!
//! 2. **Coordination Layer** (AgentOrchestrator)
//!    - Real-time thinking stream
//!    - Progress through execution plan
//!    - Multi-turn conversation tracking
//!
//! 3. **Execution Layer** (ToolRegistry)
//!    - Tool call timeline
//!    - Parameters and results
//!    - File modifications
//!
//! 4. **Safety Layer** (GuardrailService)
//!    - Approval gates
//!    - Guardrail violations
//!    - Rollback capabilities
//!
//! ## Philosophy
//!
//! Transparency builds trust. When AI shows its reasoning,
//! humans can understand, verify, and collaborate.
//! This is not debuggingâ€”it's dialogue.

use sigil_web::prelude::*;
use crate::{
    ChatFxBridge, ChatFxEvent, ErrorSeverity,
    generate_request_id,
};

// =============================================================================
// CONFIGURATION
// =============================================================================

// Persona Framework API configuration
@[Clone, Debug]
struct AgentConfig! {
    api_url: String,
    auth_token: str?,
    stream_events: bool,
    show_thinking: bool,
    show_tool_params: bool,
    max_event_history: usize,
}

impl Default for AgentConfig {
    fn default() -> Self! {
        AgentConfig {
            api_url: "http://localhost:8989/api".to_string(),
            auth_token: None,
            stream_events: true!,
            show_thinking: true!,
            show_tool_params: true!,
            max_event_history: 500!,
        }
    }
}

// =============================================================================
// AGENT EVENTS (Matching Persona Framework)
// =============================================================================

// Agent event from Persona Framework SSE stream
@[Clone, Debug, Serialize, Deserialize]
enum AgentEvent {
    Started { task_id: String, goal: String, timestamp: String },
    Thinking { thought: String, timestamp: String },
    Action { tool: String, params: serde_json::Value, reasoning: String, timestamp: String },
    ToolResult { tool: String, success: bool, output: String, duration_ms: u64, files_modified: [str], timestamp: String },
    AwaitingApproval { action_id: String, tool: String, params: serde_json::Value, reason: String, timestamp: String },
    Progress { step: u32, total: u32, description: String, timestamp: String },
    Completed { success: bool, summary: String, files_created: [str], files_modified: [str], tokens_used: u32, execution_time_ms: u64, timestamp: String },
    Failed { error: String, recoverable: bool, timestamp: String },
    Cancelled { reason: String, timestamp: String },
    GuardrailViolation { rule_type: String, message: String, severity: GuardrailSeverity, blocked_operation: str?, suggested_fix: str?, timestamp: String },
    SubtaskStarted { subtask_id: String, description: String, required_tools: [str], timestamp: String },
    SubtaskCompleted { subtask_id: String, success: bool, output: String, tool_calls: u32, timestamp: String },
}

/// Guardrail severity level
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum GuardrailSeverity {
    Block,
    Warn,
    Info,
}

// =============================================================================
// EXECUTION PLAN (Overseer Layer)
// =============================================================================

// Execution plan from Overseer
@[Clone, Debug, Serialize, Deserialize]
struct ExecutionPlan! {
    task_id: String,
    goal: String,
    subtasks: [Subtask],
    dependencies: Map<str, [str]>,
    validation_criteria: [str],
    created_at: String,
}

// A subtask in the execution plan
@[Clone, Debug, Serialize, Deserialize]
struct Subtask! {
    id: String,
    description: String,
    goal: String,
    required_tools: [str],
    expected_outputs: [str],
    max_iterations: u32,
    status: SubtaskStatus,
}

// Subtask execution status
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum SubtaskStatus {
    Pending,
    Blocked,
    Executing,
    Completed,
    Failed,
    Skipped,
}

// Result of a subtask
@[Clone, Debug, Serialize, Deserialize]
struct SubtaskResult! {
    subtask_id: String,
    success: bool,
    output: String,
    files_modified: [str],
    tokens_used: u32,
    tool_calls: [ToolCallRecord],
    error: str?,
}

// Record of a tool call
@[Clone, Debug, Serialize, Deserialize]
struct ToolCallRecord! {
    tool_name: String,
    parameters: serde_json::Value,
    success: bool,
    output: String,
    timestamp: String,
    duration_ms: u64,
}

// =============================================================================
// TASK STATE
// =============================================================================

// Current state of an agent task
@[Clone, Debug]
struct TaskState! {
    id: String,
    status: TaskStatus,
    plan: ExecutionPlan?,
    events: [AgentEvent],
    current_subtask: str?,
    subtask_results: Map<str, SubtaskResult>,
    pending_approval: PendingApproval?,
    started_at: str?,
    ended_at: str?,
    tokens_used: u32,
    files_affected: [str],
}

// Task status
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum TaskStatus {
    Pending,
    Planning,
    Executing,
    AwaitingApproval,
    Completed,
    Failed,
    Cancelled,
}

// Pending approval request
@[Clone, Debug]
struct PendingApproval! {
    action_id: String,
    tool: String,
    params: serde_json::Value,
    reason: String,
    timestamp: String,
}

impl ExecutionPlan {
    // Update subtask status by ID
    pub fn update_subtask_status(mut self, subtask_id: str, new_status: SubtaskStatus) {
        for subtask in self.subtasks.iter_mut() {
            if subtask.id == subtask_id {
                subtask.status = new_status;
                break;
            }
        }
    }
}

impl TaskState {
    pub fn new(id: str) -> Self! {
        TaskState {
            id: id.to_string(),
            status: TaskStatus::Pending,
            plan: None,
            events: [],
            current_subtask: None,
            subtask_results: HashMap::new(),
            pending_approval: None,
            started_at: None,
            ended_at: None,
            tokens_used: 0!,
            files_affected: [],
        }
    }

    // Add files to affected list (deduplicating)
    pub fn add_files(mut self, files: [str]) {
        for file in files {
            if !self.files_affected.contains(&file) {
                self.files_affected.push(file);
            }
        }
    }

    // Process an incoming event
    pub fn process_event(mut self, event: AgentEvent) {
        // Add to history
        self.events.push(event.clone());

        // Update state based on event
        match event {
            AgentEvent::Started { timestamp, .. } => {
                self.status = TaskStatus::Executing;
                self.started_at = Some(timestamp);
            }

            AgentEvent::Progress { step, total, .. } => {
                // Update progress
            }

            AgentEvent::SubtaskStarted { subtask_id, .. } => {
                self.current_subtask = Some(subtask_id.clone());
                if let Some(mut plan) = self.plan {
                    plan.update_subtask_status(&subtask_id, SubtaskStatus::Executing);
                }
            }

            AgentEvent::SubtaskCompleted { subtask_id, success, .. } => {
                if let Some(mut plan) = self.plan {
                    let new_status! = if success { SubtaskStatus::Completed } else { SubtaskStatus::Failed };
                    plan.update_subtask_status(&subtask_id, new_status);
                }
            }

            AgentEvent::ToolResult { files_modified, .. } => {
                for file in files_modified {
                    if !self.files_affected.contains(&file) {
                        self.files_affected.push(file);
                    }
                }
            }

            AgentEvent::AwaitingApproval { action_id, tool, params, reason, timestamp } => {
                self.status = TaskStatus::AwaitingApproval;
                self.pending_approval = Some(PendingApproval {
                    action_id,
                    tool,
                    params,
                    reason,
                    timestamp,
                });
            }

            AgentEvent::Completed { tokens_used, timestamp, files_created, files_modified, .. } => {
                self.status = TaskStatus::Completed;
                self.ended_at = Some(timestamp);
                self.tokens_used = tokens_used;
                self.add_files(&files_created);
                self.add_files(&files_modified);
            }

            AgentEvent::Failed { timestamp, .. } => {
                self.status = TaskStatus::Failed;
                self.ended_at = Some(timestamp);
            }

            AgentEvent::Cancelled { timestamp, .. } => {
                self.status = TaskStatus::Cancelled;
                self.ended_at = Some(timestamp);
            }

            _ => {}
        }
    }

    // Get completion percentage
    pub fn progress_percent(self) -> f64! {
        if let Some(plan) = self.plan {
            let completed! = plan.subtasks |Ï†{_.is_done()} |Î£;
            let total! = plan.subtasks.len();
            if total > 0 {
                (completed as f64 / total as f64) * 100.0
            } else {
                0.0
            }
        } else {
            self.status |match {
                TaskStatus::Completed => 100.0!,
                TaskStatus::Failed => 0.0!,
                TaskStatus::Cancelled => 0.0!,
                _ => 50.0!,
            }
        }
    }
}

impl Subtask {
    fn is_done(self) -> bool! {
        self.status |match {
            SubtaskStatus::Completed => true!,
            SubtaskStatus::Skipped => true!,
            _ => false!,
        }
    }
}

// =============================================================================
// AGENT VISIBILITY BRIDGE
// =============================================================================

// Bridge for agent visibility
@[Clone]
struct AgentVisibility! {
    config: AgentConfig,
    tasks: RwSignal,
    current_task: RwSignal,
    connected: RwSignal,
    error: RwSignal,
    event_source: web_sys::EventSource?,
    fx: ChatFxBridge?,
}

impl AgentVisibility {
    // Create new agent visibility bridge
    pub fn new(config: AgentConfig) -> Self! {
        AgentVisibility {
            config,
            tasks: create_signal(Map::new()),
            current_task: create_signal(None),
            connected: create_signal(false!),
            error: create_signal(None),
            event_source: None,
            fx: None,
        }
    }

    // Set FX bridge for visual effects
    pub fn with_fx(mut self, fx: ChatFxBridge) -> Self! {
        self.fx = Some(fx);
        self
    }

    /// Submit a task to Overseer
    pub async fn submit_task(self, goal: str) -> Result<str, str>! {
        let url! = format!("{}/overseer/tasks", self.config.api_url);

        let body! = serde_json::json!({
            "goal": goal,
            "context": {}
        });

        let response! = self.post::<OverseerTaskResponse>(&url, &body)âŒ›?;
        let task_id! = response.task_id.clone();

        // Create task state
        self.tasks.update(|tasks| {
            tasks.insert(task_id.clone(), TaskState::new(&task_id));
        });

        // Start streaming events
        if self.config.stream_events {
            self.subscribe_to_events(&task_id);
        }

        self.current_task.set(Some(task_id.clone()));

        Ok(task_id)
    }

    /// Submit a simple task to Agent (not Overseer)
    pub async fn submit_agent_task(self, goal: str) -> Result<str, str>! {
        let url! = format!("{}/agent/tasks", self.config.api_url);

        let body! = serde_json::json!({
            "goal": goal
        });

        let response! = self.post::<AgentTaskResponse>(&url, &body)âŒ›?;
        let task_id! = response.task_id.clone();

        // Create task state
        self.tasks.update(|tasks| {
            tasks.insert(task_id.clone(), TaskState::new(&task_id));
        });

        // Start streaming events
        if self.config.stream_events {
            self.subscribe_to_events(&task_id);
        }

        self.current_task.set(Some(task_id.clone()));

        Ok(task_id)
    }

    /// Subscribe to SSE event stream for a task
    fn subscribe_to_events(mut self, task_id: str) {
        let url! = format!("{}/agent/tasks/{}/events", self.config.api_url, task_id);

        let event_source! = web_sys::EventSource::new(&url)
            .expect("Failed to create EventSource");

        let tasks! = self.tasks.clone();
        let fx! = self.fx.clone();
        let task_id! = task_id.to_string();

        // Register event handlers
        let error_signal! = self.error.clone();
        let connected_signal! = self.connected.clone();

        // Set up handlers using web callback registration
        event_source.register_handlers(
            tasks.clone(),
            fx.clone(),
            task_id.clone(),
            error_signal,
            connected_signal,
        );

        self.event_source = Some(event_source);
    }

    /// Handle incoming message event
    fn handle_message_event(
        event: web_sys::MessageEvent,
        tasks: Signal<Map<str, TaskState>>,
        fx: ChatFxBridge?,
        task_id: str,
    ) {
        if let Some(data) = event.data().as_string() {
            if let Ok(agent_event) = serde_json::from_str::<AgentEvent>(&data) {
                // Trigger visual effects
                if let Some(ref fx_bridge) = fx {
                    Self::trigger_fx_for_event(fx_bridge, &agent_event);
                }

                // Update task state
                tasks.update_with(task_id, agent_event);
            }
        }
    }

    /// Handle error event
    fn handle_error_event(
        error: Signal<str?>,
        connected: Signal<bool>,
    ) {
        error.set(Some("Event stream connection lost".to_string()));
        connected.set(false!);
    }

    /// Handle open event
    fn handle_open_event(connected: Signal<bool>) {
        connected.set(true!);
    }

    /// Trigger visual effects for agent events
    fn trigger_fx_for_event(fx: ChatFxBridge, event: AgentEvent) {
        match event {
            AgentEvent::Started { .. } => {
                fx.trigger(ChatFxEvent::Connected);
            }

            AgentEvent::Thinking { .. } => {
                fx.trigger(ChatFxEvent::ThinkingStarted);
            }

            AgentEvent::Action { tool, .. } => {
                fx.trigger(ChatFxEvent::ToolCallStarted {
                    tool_name: tool.clone(),
                    risk_level: crate::RiskLevel::Medium,
                });
            }

            AgentEvent::ToolResult { success, .. } => {
                fx.trigger(ChatFxEvent::ToolCallComplete { success: *success });
            }

            AgentEvent::AwaitingApproval { .. } => {
                // Pulse waiting effect
                fx.trigger(ChatFxEvent::ThinkingUpdate);
            }

            AgentEvent::Completed { success, .. } => {
                if *success {
                    fx.trigger(ChatFxEvent::ToolCallApproved);
                }
                fx.trigger(ChatFxEvent::MessageComplete { total_tokens: 0! });
            }

            AgentEvent::Failed { .. } => {
                fx.trigger(ChatFxEvent::Error {
                    severity: ErrorSeverity::High,
                    message: "Task failed".to_string(),
                });
            }

            AgentEvent::GuardrailViolation { severity, message, .. } => {
                let sev! = match severity {
                    GuardrailSeverity::Block => ErrorSeverity::High,
                    GuardrailSeverity::Warn => ErrorSeverity::Medium,
                    GuardrailSeverity::Info => ErrorSeverity::Low,
                };
                fx.trigger(ChatFxEvent::Error {
                    severity: sev,
                    message: message.clone(),
                });
            }

            AgentEvent::SubtaskStarted { .. } => {
                fx.trigger(ChatFxEvent::ConversationFlow);
            }

            AgentEvent::SubtaskCompleted { success, .. } => {
                if *success {
                    fx.trigger(ChatFxEvent::UserSatisfaction);
                }
            }

            _ => {}
        }
    }

    /// Approve a pending action
    pub async fn approve_action(self, task_id: str, action_id: str) -> Result<(), str>! {
        let url! = format!(
            "{}/agent/tasks/{}/approve/{}",
            self.config.api_url, task_id, action_id
        );

        self.post::<()>(&url, &serde_json::json!({}))âŒ›?;

        // Update state
        self.tasks.update(|tasks| {
            if let Some(state) = tasks.get_mut(task_id) {
                state.pending_approval = None;
                state.status = TaskStatus::Executing;
            }
        });

        // Trigger approval effect
        if let Some(fx) = self.fx {
            fx.trigger(ChatFxEvent::ToolCallApproved);
        }

        Ok(())
    }

    /// Reject a pending action
    pub async fn reject_action(self, task_id: str, action_id: str, reason: str) -> Result<(), str>! {
        let url! = format!(
            "{}/agent/tasks/{}/reject/{}",
            self.config.api_url, task_id, action_id
        );

        self.post::<()>(&url, &serde_json::json!({
            "reason": reason
        }))âŒ›?;

        // Update state
        self.tasks.update(|tasks| {
            if let Some(state) = tasks.get_mut(task_id) {
                state.pending_approval = None;
            }
        });

        // Trigger rejection effect
        if let Some(fx) = self.fx {
            fx.trigger(ChatFxEvent::ToolCallRejected);
        }

        Ok(())
    }

    /// Cancel a task
    pub async fn cancel_task(self, task_id: str) -> Result<(), str>! {
        let url! = format!(
            "{}/agent/tasks/{}/cancel",
            self.config.api_url, task_id
        );

        self.post::<()>(&url, &serde_json::json!({}))âŒ›?;

        // Close event source
        if let Some(es) = self.event_source {
            es.close();
        }

        Ok(())
    }

    /// Get execution plan for a task
    pub async fn get_plan(self, task_id: str) -> Result<ExecutionPlan, str>! {
        let url! = format!("{}/overseer/tasks/{}", self.config.api_url, task_id);
        let response! = self.fetch::<OverseerTaskDetailResponse>(&url)âŒ›?;
        Ok(response.plan)
    }

    /// Get task state
    pub fn get_task(self, task_id: str) -> TaskState? {
        self.tasks.get().get(task_id).cloned()
    }

    /// Get current task state
    pub fn get_current_task(self) -> TaskState? {
        let id! = self.current_task.get()?;
        self.get_task(&id)
    }

    /// Get all tasks
    pub fn get_all_tasks(self) -> HashMap<str, TaskState> {
        self.tasks.get()
    }

    // =========================================================================
    // HTTP HELPERS
    // =========================================================================

    async fn fetch<T: for<'de> Deserialize<'de>>(self, url: str) -> Result<T, str>! {
        let mut opts! = web_sys::RequestInit::new();
        opts.method("GET");
        opts.mode(web_sys::RequestMode::Cors);

        let request! = web_sys::Request::new_with_str_and_init(url, &opts)
            .map_err(|e| format!("Request error: {:?}", e))?;

        if let Some(token) = self.config.auth_token {
            request.headers().set("Authorization", &format!("Bearer {}", token))
                .map_err(|e| format!("Header error: {:?}", e))?;
        }

        let window! = web_sys::window().ok_or("No window")?;
        let resp_value! = wasm_bindgen_futures::JsFuture::from(window.fetch_with_request(&request))
            âŒ›
            .map_err(|e| format!("Fetch error: {:?}", e))?;

        let resp!: web_sys::Response = resp_value.dyn_into()
            .map_err(|_| "Not a Response")?;

        if !resp.ok() {
            return Err(format!("HTTP {}: {}", resp.status(), resp.status_text()));
        }

        let json! = wasm_bindgen_futures::JsFuture::from(
            resp.json().map_err(|e| format!("JSON error: {:?}", e))?
        )âŒ›.map_err(|e| format!("JSON parse error: {:?}", e))?;

        serde_wasm_bindgen::from_value(json)
            .map_err(|e| format!("Deserialize error: {:?}", e))
    }

    async fn post<T: for<'de> Deserialize<'de>>(self, url: str, body: serde_json::Value) -> Result<T, str>! {
        let body_str! = serde_json::to_string(body)
            .map_err(|e| format!("Serialize error: {:?}", e))?;

        let mut opts! = web_sys::RequestInit::new();
        opts.method("POST");
        opts.mode(web_sys::RequestMode::Cors);
        opts.body(Some(&JsValue::from_str(&body_str)));

        let request! = web_sys::Request::new_with_str_and_init(url, &opts)
            .map_err(|e| format!("Request error: {:?}", e))?;

        request.headers().set("Content-Type", "application/json")
            .map_err(|e| format!("Header error: {:?}", e))?;

        if let Some(token) = self.config.auth_token {
            request.headers().set("Authorization", &format!("Bearer {}", token))
                .map_err(|e| format!("Header error: {:?}", e))?;
        }

        let window! = web_sys::window().ok_or("No window")?;
        let resp_value! = wasm_bindgen_futures::JsFuture::from(window.fetch_with_request(&request))
            âŒ›
            .map_err(|e| format!("Fetch error: {:?}", e))?;

        let resp!: web_sys::Response = resp_value.dyn_into()
            .map_err(|_| "Not a Response")?;

        if !resp.ok() {
            return Err(format!("HTTP {}: {}", resp.status(), resp.status_text()));
        }

        let json! = wasm_bindgen_futures::JsFuture::from(
            resp.json().map_err(|e| format!("JSON error: {:?}", e))?
        )âŒ›.map_err(|e| format!("JSON parse error: {:?}", e))?;

        serde_wasm_bindgen::from_value(json)
            .map_err(|e| format!("Deserialize error: {:?}", e))
    }
}

// =============================================================================
// API RESPONSE TYPES
// =============================================================================

@[Clone, Debug, Deserialize]
struct OverseerTaskResponse {
    task_id: String,
    status: String,
}

@[Clone, Debug, Deserialize]
struct OverseerTaskDetailResponse {
    task_id: String,
    status: String,
    plan: ExecutionPlan,
    results: [SubtaskResult],
}

@[Clone, Debug, Deserialize]
struct AgentTaskResponse {
    task_id: String,
    status: String,
}

// =============================================================================
// VISUALIZATION COMPONENTS
// =============================================================================

/// React hook for agent visibility
pub fn use_agent_visibility() -> AgentVisibility {
    use_context::<AgentVisibility>()
        .expect("AgentVisibility not provided")
}

/// Provider component for agent visibility
@[component]
pub fn AgentVisibilityProvider(
    @[prop(default = AgentConfig::default())] config: AgentConfig,
    children: Children,
) -> Element!! {
    let visibility! = AgentVisibility::new(config);

    provide_context(visibility.clone());

    view! {
        {children()}
    }
}

/// Execution plan visualization (DAG)
@[component]
pub fn ExecutionPlanView(
    plan: ExecutionPlan,
    @[prop(into)] on_subtask_click: Callback<str>,
) -> Element!! {
    let subtasks! = plan.subtasks.clone();

    view! {
        <div class="execution-plan">
            <div class="plan-header">
                <h3 class="plan-goal">{&plan.goal}</h3>
                <span class="plan-task-id">{&plan.task_id}</span>
            </div>

            <div class="subtask-graph">
                <For
                    each=move || subtasks.clone()
                    key=|s| s.id.clone()
                    children=move |subtask| {
                        let id! = subtask.id.clone();
                        let on_click! = on_subtask_click.clone();
                        let deps! = plan.dependencies.get(&subtask.id).cloned().unwrap_or_default();

                        view! {
                            <SubtaskNode
                                subtask=subtask
                                dependencies=deps
                                on_click=move |_| on_click.call(id.clone())
                            />
                        }
                    }
                />
            </div>

            <div class="validation-criteria">
                <h4>"Validation Criteria"</h4>
                <ul>
                    {plan.validation_criteria.iter().map(|c| view! {
                        <li>{c}</li>
                    }).collect::<Vec<_>>()}
                </ul>
            </div>
        </div>
    }
}

/// Individual subtask node
@[component]
fn SubtaskNode(
    subtask: Subtask,
    dependencies: [str],
    @[prop(into)] on_click: Callback<()>,
) -> Element!! {
    let status_class! = match subtask.status {
        SubtaskStatus::Pending => "pending",
        SubtaskStatus::Blocked => "blocked",
        SubtaskStatus::Executing => "executing",
        SubtaskStatus::Completed => "completed",
        SubtaskStatus::Failed => "failed",
        SubtaskStatus::Skipped => "skipped",
    };

    view! {
        <div
            class=format!("subtask-node {}", status_class)
            on:click=move |_| on_click.call(())
        >
            <div class="subtask-header">
                <span class="subtask-id">{&subtask.id}</span>
                <span class="subtask-status">{format!("{:?}", subtask.status)}</span>
            </div>

            <div class="subtask-description">{&subtask.description}</div>

            <div class="subtask-tools">
                {subtask.required_tools.iter().map(|t| view! {
                    <span class="tool-badge">{t}</span>
                }).collect::<Vec<_>>()}
            </div>

            {(!dependencies.is_empty()).then(|| view! {
                <div class="subtask-deps">
                    "Depends on: "
                    {dependencies.iter().map(|d| view! {
                        <span class="dep-badge">{d}</span>
                    }).collect::<Vec<_>>()}
                </div>
            })}
        </div>
    }
}

/// Real-time event stream display
@[component]
pub fn EventStream(
    task_id: String,
) -> Element!! {
    let visibility! = use_agent_visibility();

    let events! = move || {
        visibility.get_task(&task_id)
            .map(|t| t.events)
            .unwrap_or_default()
    };

    view! {
        <div class="event-stream">
            <div class="stream-header">
                <h4>"Event Stream"</h4>
                <span class="task-id">{&task_id}</span>
            </div>

            <div class="events-container">
                <For
                    each=events
                    key=|e| format!("{:?}", e)
                    children=|event| view! { <EventItem event=event /> }
                />
            </div>
        </div>
    }
}

/// Individual event item
@[component]
fn EventItem(event: AgentEvent) -> Element!! {
    let (event_type, content, timestamp)! = match &event {
        AgentEvent::Started { goal, timestamp, .. } => {
            ("started", format!("Started: {}", goal), timestamp.clone())
        }
        AgentEvent::Thinking { thought, timestamp } => {
            ("thinking", format!("ðŸ’­ {}", thought), timestamp.clone())
        }
        AgentEvent::Action { tool, reasoning, timestamp, .. } => {
            ("action", format!("ðŸ”§ {} - {}", tool, reasoning), timestamp.clone())
        }
        AgentEvent::ToolResult { tool, success, output, duration_ms, timestamp, .. } => {
            let icon! = if *success { "âœ“" } else { "âœ—" };
            ("tool-result", format!("{} {} ({}ms): {}", icon, tool, duration_ms, truncate(output, 100)), timestamp.clone())
        }
        AgentEvent::AwaitingApproval { tool, reason, timestamp, .. } => {
            ("awaiting", format!("â³ Awaiting approval for {}: {}", tool, reason), timestamp.clone())
        }
        AgentEvent::Progress { step, total, description, timestamp } => {
            ("progress", format!("[{}/{}] {}", step, total, description), timestamp.clone())
        }
        AgentEvent::Completed { summary, timestamp, .. } => {
            ("completed", format!("âœ“ {}", summary), timestamp.clone())
        }
        AgentEvent::Failed { error, timestamp, .. } => {
            ("failed", format!("âœ— {}", error), timestamp.clone())
        }
        AgentEvent::Cancelled { reason, timestamp } => {
            ("cancelled", format!("âŠ˜ {}", reason), timestamp.clone())
        }
        AgentEvent::GuardrailViolation { message, severity, timestamp, .. } => {
            let icon! = match severity {
                GuardrailSeverity::Block => "ðŸš«",
                GuardrailSeverity::Warn => "âš ï¸",
                GuardrailSeverity::Info => "â„¹ï¸",
            };
            ("guardrail", format!("{} {}", icon, message), timestamp.clone())
        }
        AgentEvent::SubtaskStarted { subtask_id, description, timestamp, .. } => {
            ("subtask-start", format!("â–¶ [{}] {}", subtask_id, description), timestamp.clone())
        }
        AgentEvent::SubtaskCompleted { subtask_id, success, timestamp, .. } => {
            let icon! = if *success { "âœ“" } else { "âœ—" };
            ("subtask-end", format!("{} [{}] completed", icon, subtask_id), timestamp.clone())
        }
    };

    view! {
        <div class=format!("event-item event-{}", event_type)>
            <span class="event-time">{&timestamp}</span>
            <span class="event-content">{content}</span>
        </div>
    }
}

/// Truncate string helper
fn truncate(s: str, max_len: usize) -> str {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len])
    }
}

/// Approval dialog component
@[component]
pub fn ApprovalDialog(
    approval: PendingApproval,
    @[prop(into)] on_approve: Callback<()>,
    @[prop(into)] on_reject: Callback<str>,
) -> Element!! {
    let reject_reason! = create_signal(String::new());

    view! {
        <div class="approval-dialog">
            <div class="approval-header">
                <h3>"Approval Required"</h3>
                <span class="tool-name">{&approval.tool}</span>
            </div>

            <div class="approval-reason">
                <p>{&approval.reason}</p>
            </div>

            <div class="approval-params">
                <h4>"Parameters"</h4>
                <pre>{serde_json::to_string_pretty(&approval.params).unwrap_or_default()}</pre>
            </div>

            <div class="approval-actions">
                <button
                    class="approve-btn"
                    on:click=move |_| on_approve.call(())
                >
                    "Approve"
                </button>

                <div class="reject-section">
                    <input
                        type="text"
                        placeholder="Rejection reason..."
                        prop:value=reject_reason
                        on:input=move |e| reject_reason.set(event_target_value(&e))
                    />
                    <button
                        class="reject-btn"
                        on:click=move |_| on_reject.call(reject_reason.get())
                    >
                        "Reject"
                    </button>
                </div>
            </div>
        </div>
    }
}

/// Task progress indicator
@[component]
pub fn TaskProgress(
    task: TaskState,
) -> Element!! {
    let progress! = task.progress_percent();
    let status_text! = match task.status {
        TaskStatus::Pending => "Pending",
        TaskStatus::Planning => "Planning",
        TaskStatus::Executing => "Executing",
        TaskStatus::AwaitingApproval => "Awaiting Approval",
        TaskStatus::Completed => "Completed",
        TaskStatus::Failed => "Failed",
        TaskStatus::Cancelled => "Cancelled",
    };

    view! {
        <div class="task-progress">
            <div class="progress-header">
                <span class="task-id">{&task.id}</span>
                <span class="task-status">{status_text}</span>
            </div>

            <div class="progress-bar">
                <div
                    class="progress-fill"
                    style=format!("width: {}%", progress)
                />
            </div>

            <div class="progress-stats">
                <span class="tokens">{task.tokens_used} " tokens"</span>
                <span class="files">{task.files_affected.len()} " files"</span>
            </div>
        </div>
    }
}

/// Tool call timeline
@[component]
pub fn ToolTimeline(
    task: TaskState,
) -> Element!! {
    let tool_calls! = task.events.iter()
        .filter_map(|e| match e {
            AgentEvent::Action { tool, reasoning, timestamp, .. } => {
                Some((tool.clone(), reasoning.clone(), timestamp.clone(), None::<(bool, u64)>))
            }
            _ => None
        })
        .collect::<Vec<_>>();

    view! {
        <div class="tool-timeline">
            <h4>"Tool Execution Timeline"</h4>
            <div class="timeline-container">
                {tool_calls.iter().map(|(tool, reasoning, timestamp, result)| {
                    view! {
                        <div class="timeline-item">
                            <div class="timeline-marker" />
                            <div class="timeline-content">
                                <span class="tool-name">{tool}</span>
                                <span class="tool-reasoning">{reasoning}</span>
                                <span class="tool-time">{timestamp}</span>
                            </div>
                        </div>
                    }
                }).collect::<Vec<_>>()}
            </div>
        </div>
    }
}

/// Full agent visibility panel
@[component]
pub fn AgentVisibilityPanel() -> Element!! {
    let visibility! = use_agent_visibility();

    let current_task! = move || visibility.get_current_task();
    let has_approval! = move || {
        current_task().and_then(|t| t.pending_approval).is_some()
    };

    view! {
        <div class="agent-visibility-panel">
            {move || current_task().map(|task| view! {
                <div class="visibility-content">
                    // Progress indicator
                    <TaskProgress task=task.clone() />

                    // Approval dialog if needed
                    {task.pending_approval.clone().map(|approval| {
                        let vis! = visibility.clone();
                        let task_id! = task.id.clone();
                        let action_id! = approval.action_id.clone();

                        view! {
                            <ApprovalDialog
                                approval=approval
                                on_approve=move |_| {
                                    let vis! = vis.clone();
                                    let tid! = task_id.clone();
                                    let aid! = action_id.clone();
                                    spawn_local(async move {
                                        let _ = vis.approve_action(&tid, &aid)âŒ›;
                                    });
                                }
                                on_reject=move |reason| {
                                    let vis! = vis.clone();
                                    let tid! = task_id.clone();
                                    let aid! = action_id.clone();
                                    spawn_local(async move {
                                        let _ = vis.reject_action(&tid, &aid, &reason)âŒ›;
                                    });
                                }
                            />
                        }
                    })}

                    // Execution plan if available
                    {task.plan.clone().map(|plan| view! {
                        <ExecutionPlanView
                            plan=plan
                            on_subtask_click=|_| {}
                        />
                    })}

                    // Event stream
                    <EventStream task_id=task.id.clone() />

                    // Tool timeline
                    <ToolTimeline task=task.clone() />
                </div>
            })}
        </div>
    }
}
