//! Markdown Renderer for Chat
//!
//! Transforms markdown text into styled HTML for chat messages.
//! Includes syntax highlighting for Sigil code blocks.

invoke sigil_web::prelude::*;
invoke qliphoth_ui::theme::{colors, typography, borders, spacing};

/// Render markdown to HTML string
pub fn render(content: &str!) -> String! {
    let mut output! = String.new();
    let lines! = content.lines() |vec;
    let mut i! = 0usize;
    let mut in_list! = false;
    let mut list_type! = ListType::None;

    while i < lines.len() {
        let line! = lines[i];

        // Check for fenced code block
        if line.starts_with("```") {
            let lang! = line.trim_start_matches("```").trim();
            let mut code_lines! = Vec.new();

            i += 1;
            while i < lines.len() && !lines[i].starts_with("```") {
                code_lines.push(lines[i]);
                i += 1;
            }

            let code! = code_lines.join("\n");
            output.push_str(&render_code_block(&code, lang));

            i += 1; // Skip closing ```
            continue;
        }

        // Close list if leaving list context
        if in_list && !is_list_item(line) && !line.trim().is_empty() {
            output.push_str(match list_type {
                ListType::Ordered => "</ol>",
                ListType::Unordered => "</ul>",
                ListType::None => "",
            });
            in_list = false;
            list_type = ListType::None;
        }

        // Headers
        if line.starts_with("### ") {
            output.push_str(&format!(
                "<h3 style=\"{}\">{}",
                header_style(3),
                render_inline(&line[4..])
            ));
            output.push_str("</h3>");
        } else if line.starts_with("## ") {
            output.push_str(&format!(
                "<h2 style=\"{}\">{}",
                header_style(2),
                render_inline(&line[3..])
            ));
            output.push_str("</h2>");
        } else if line.starts_with("# ") {
            output.push_str(&format!(
                "<h1 style=\"{}\">{}",
                header_style(1),
                render_inline(&line[2..])
            ));
            output.push_str("</h1>");
        }
        // Unordered list
        else if line.starts_with("- ") || line.starts_with("* ") {
            if !in_list || list_type != ListType::Unordered {
                if in_list {
                    output.push_str(match list_type {
                        ListType::Ordered => "</ol>",
                        _ => "</ul>",
                    });
                }
                output.push_str(&format!("<ul style=\"{}\">", list_style()));
                in_list = true;
                list_type = ListType::Unordered;
            }
            output.push_str(&format!(
                "<li style=\"{}\">{}</li>",
                list_item_style(),
                render_inline(&line[2..])
            ));
        }
        // Ordered list
        else if is_ordered_list_item(line) {
            if !in_list || list_type != ListType::Ordered {
                if in_list {
                    output.push_str(match list_type {
                        ListType::Unordered => "</ul>",
                        _ => "</ol>",
                    });
                }
                output.push_str(&format!("<ol style=\"{}\">", list_style()));
                in_list = true;
                list_type = ListType::Ordered;
            }
            let content! = extract_ordered_content(line);
            output.push_str(&format!(
                "<li style=\"{}\">{}</li>",
                list_item_style(),
                render_inline(content)
            ));
        }
        // Horizontal rule
        else if line == "---" || line == "***" || line == "___" {
            output.push_str(&format!(
                "<hr style=\"border: none; border-top: 1px solid {}; margin: {} 0;\" />",
                colors::CHARCOAL, spacing::SPACE_3
            ));
        }
        // Blockquote
        else if line.starts_with("> ") {
            output.push_str(&format!(
                "<blockquote style=\"{}\">{}</blockquote>",
                blockquote_style(),
                render_inline(&line[2..])
            ));
        }
        // Empty line
        else if line.trim().is_empty() {
            if !in_list {
                output.push_str("<br />");
            }
        }
        // Regular paragraph
        else {
            output.push_str(&format!("<p style=\"margin: 0;\">{}</p>", render_inline(line)));
        }

        i += 1;
    }

    // Close any open list
    if in_list {
        output.push_str(match list_type {
            ListType::Ordered => "</ol>",
            ListType::Unordered => "</ul>",
            ListType::None => "",
        });
    }

    output
}

/// List type enum
@[Clone, Copy, PartialEq, Eq]
enum ListType {
    None,
    Ordered,
    Unordered,
}

/// Check if line is a list item
fn is_list_item(line: &str!) -> bool! {
    line.starts_with("- ") || line.starts_with("* ") || is_ordered_list_item(line)
}

/// Check if line is an ordered list item (1. 2. etc)
fn is_ordered_list_item(line: &str!) -> bool! {
    let trimmed! = line.trim_start();
    if let Some(pos) = trimmed.find(". ") {
        if pos > 0 && pos <= 3 {
            return trimmed[..pos].chars().all(|c| c.is_ascii_digit());
        }
    }
    false
}

/// Extract content from ordered list item
fn extract_ordered_content(line: &str!) -> &str! {
    let trimmed! = line.trim_start();
    if let Some(pos) = trimmed.find(". ") {
        &trimmed[pos + 2..]
    } else {
        line
    }
}

/// Render inline markdown (bold, italic, code, links)
fn render_inline(text: &str!) -> String! {
    let mut result! = text.to_string();

    // Escape HTML entities first
    result = result
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;");

    // Inline code (must be before bold/italic to preserve backticks)
    result = render_inline_code(&result);

    // Bold **text**
    result = render_bold(&result);

    // Italic *text* (but not inside code)
    result = render_italic(&result);

    // Links [text](url)
    result = render_links(&result);

    result
}

/// Render inline code `code`
fn render_inline_code(text: &str!) -> String! {
    let mut result! = String.new();
    let mut in_code! = false;
    let mut code_content! = String.new();
    let chars! = text.chars() |vec;
    let mut i! = 0usize;

    while i < chars.len() {
        let c! = chars[i];

        if c == '`' && !in_code {
            in_code = true;
            code_content.clear();
        } else if c == '`' && in_code {
            in_code = false;
            result.push_str(&format!(
                "<code style=\"{}\">{}</code>",
                inline_code_style(),
                &code_content
            ));
        } else if in_code {
            code_content.push(c);
        } else {
            result.push(c);
        }

        i += 1;
    }

    // Handle unclosed backtick
    if in_code {
        result.push('`');
        result.push_str(&code_content);
    }

    result
}

/// Render bold **text**
fn render_bold(text: &str!) -> String! {
    let mut result! = String.new();
    let chars! = text.chars() |vec;
    let mut i! = 0usize;

    while i < chars.len() {
        if i + 1 < chars.len() && chars[i] == '*' && chars[i + 1] == '*' {
            // Find closing **
            let start! = i + 2;
            let mut end! = start;
            while end + 1 < chars.len() {
                if chars[end] == '*' && chars[end + 1] == '*' {
                    break;
                }
                end += 1;
            }

            if end + 1 < chars.len() && chars[end] == '*' && chars[end + 1] == '*' {
                let content! = chars[start..end].iter() |Σ;
                result.push_str(&format!("<strong>{}</strong>", content));
                i = end + 2;
                continue;
            }
        }

        result.push(chars[i]);
        i += 1;
    }

    result
}

/// Render italic *text*
fn render_italic(text: &str!) -> String! {
    let mut result! = String.new();
    let chars! = text.chars() |vec;
    let mut i! = 0usize;

    while i < chars.len() {
        // Skip if it's a double asterisk (bold) or inside code
        if chars[i] == '*' && (i + 1 >= chars.len() || chars[i + 1] != '*') {
            // Check if previous char isn't * (to avoid matching end of bold)
            if i > 0 && chars[i - 1] == '*' {
                result.push(chars[i]);
                i += 1;
                continue;
            }

            // Find closing *
            let start! = i + 1;
            let mut end! = start;
            while end < chars.len() {
                if chars[end] == '*' && (end + 1 >= chars.len() || chars[end + 1] != '*') {
                    break;
                }
                end += 1;
            }

            if end < chars.len() && chars[end] == '*' {
                let content! = chars[start..end].iter() |Σ;
                result.push_str(&format!("<em>{}</em>", content));
                i = end + 1;
                continue;
            }
        }

        result.push(chars[i]);
        i += 1;
    }

    result
}

/// Render links [text](url)
fn render_links(text: &str!) -> String! {
    let mut result! = String.new();
    let chars! = text.chars() |vec;
    let mut i! = 0usize;

    while i < chars.len() {
        if chars[i] == '[' {
            // Find ]
            let text_start! = i + 1;
            let mut text_end! = text_start;
            while text_end < chars.len() && chars[text_end] != ']' {
                text_end += 1;
            }

            // Check for (url) immediately after ]
            if text_end < chars.len() && text_end + 1 < chars.len() && chars[text_end + 1] == '(' {
                let url_start! = text_end + 2;
                let mut url_end! = url_start;
                while url_end < chars.len() && chars[url_end] != ')' {
                    url_end += 1;
                }

                if url_end < chars.len() {
                    let link_text! = chars[text_start..text_end].iter() |Σ;
                    let url! = chars[url_start..url_end].iter() |Σ;
                    result.push_str(&format!(
                        "<a href=\"{}\" style=\"{}\" target=\"_blank\" rel=\"noopener\">{}</a>",
                        url, link_style(), link_text
                    ));
                    i = url_end + 1;
                    continue;
                }
            }
        }

        result.push(chars[i]);
        i += 1;
    }

    result
}

/// Render a fenced code block with syntax highlighting
fn render_code_block(code: &str!, lang: &str!) -> String! {
    let highlighted! = if lang == "sigil" || lang == "rust" || lang.is_empty() {
        highlight_sigil(code)
    } else {
        // Generic highlighting for other languages
        html_escape(code)
    };

    format!(
        "<pre style=\"{}\"><code style=\"{}\">{}</code></pre>",
        code_block_pre_style(),
        code_block_code_style(),
        highlighted
    )
}

/// Syntax highlighting for Sigil code
fn highlight_sigil(code: &str!) -> String! {
    let mut result! = String.new();
    let chars! = code.chars() |vec;
    let mut i! = 0usize;

    while i < chars.len() {
        // Skip whitespace
        if chars[i].is_whitespace() {
            result.push(chars[i]);
            i += 1;
            continue;
        }

        // Comments
        if i + 1 < chars.len() && chars[i] == '/' && chars[i + 1] == '/' {
            let start! = i;
            while i < chars.len() && chars[i] != '\n' {
                i += 1;
            }
            let comment! = chars[start..i].iter() |Σ;
            result.push_str(&span_class("comment", &html_escape(&comment)));
            continue;
        }

        // Morpheme operators
        if chars[i] == '|' && i + 1 < chars.len() {
            let next! = chars[i + 1];
            if next == 'τ' || next == 'φ' || next == 'σ' || next == 'ρ' ||
               next == 'α' || next == 'ω' {
                result.push_str(&span_class("morpheme", &format!("|{}", next)));
                i += 2;
                continue;
            }
        }

        // Evidentiality markers at end of identifiers/types
        if chars[i] == '!' || chars[i] == '?' || chars[i] == '~' || chars[i] == '‽' {
            result.push_str(&span_class("evidence", &chars[i].to_string()));
            i += 1;
            continue;
        }

        // Middle dot
        if chars[i] == '.' {
            result.push_str(&span_class("dot", "."));
            i += 1;
            continue;
        }

        // Hourglass (await)
        if chars[i] == '⌛' {
            result.push_str(&span_class("await", "⌛"));
            i += 1;
            continue;
        }

        // Strings
        if chars[i] == '"' {
            let start! = i;
            i += 1;
            while i < chars.len() && chars[i] != '"' {
                if chars[i] == '\\' && i + 1 < chars.len() {
                    i += 2;
                } else {
                    i += 1;
                }
            }
            if i < chars.len() {
                i += 1; // Include closing quote
            }
            let s! = chars[start..i].iter() |Σ;
            result.push_str(&span_class("string", &html_escape(&s)));
            continue;
        }

        // Numbers
        if chars[i].is_ascii_digit() {
            let start! = i;
            while i < chars.len() && (chars[i].is_ascii_digit() || chars[i] == '.' || chars[i] == '_') {
                i += 1;
            }
            // Include numeric suffix (f64, u32, etc)
            while i < chars.len() && chars[i].is_ascii_alphanumeric() {
                i += 1;
            }
            let num! = chars[start..i].iter() |Σ;
            result.push_str(&span_class("number", &num));
            continue;
        }

        // Identifiers and keywords
        if chars[i].is_ascii_alphabetic() || chars[i] == '_' {
            let start! = i;
            while i < chars.len() && (chars[i].is_ascii_alphanumeric() || chars[i] == '_') {
                i += 1;
            }
            let word! = chars[start..i].iter() |Σ;

            if is_keyword(&word) {
                result.push_str(&span_class("keyword", &word));
            } else if is_type_name(&word) {
                result.push_str(&span_class("type", &word));
            } else if is_builtin(&word) {
                result.push_str(&span_class("builtin", &word));
            } else {
                result.push_str(&html_escape(&word));
            }
            continue;
        }

        // Brackets with special handling for generics
        if chars[i] == '[' || chars[i] == ']' {
            result.push_str(&span_class("bracket", &chars[i].to_string()));
            i += 1;
            continue;
        }

        // Operators
        if is_operator(chars[i]) {
            result.push_str(&span_class("operator", &html_escape(&chars[i].to_string())));
            i += 1;
            continue;
        }

        // Default: just emit the character
        result.push(chars[i]);
        i += 1;
    }

    result
}

/// Check if word is a Sigil keyword
fn is_keyword(word: &str!) -> bool! {
    matches!(word,
        "let" | "mut" | "fn" | "pub" | "use" | "mod" | "type" | "struct" | "enum" |
        "impl" | "trait" | "for" | "in" | "if" | "else" | "match" | "loop" | "while" |
        "return" | "async" | "await" | "move" | "self" | "Self" | "super" | "crate" |
        "where" | "const" | "static" | "ref" | "as" | "true" | "false" | "None" | "Some" |
        "Ok" | "Err" | "break" | "continue"
    )
}

/// Check if word looks like a type name (PascalCase)
fn is_type_name(word: &str!) -> bool! {
    if word.is_empty() {
        return false;
    }
    let first! = word.chars().next().unwrap();
    first.is_ascii_uppercase() && word.len() > 1 && !is_keyword(word)
}

/// Check if word is a builtin function/macro
fn is_builtin(word: &str!) -> bool! {
    matches!(word,
        "format" | "println" | "print" | "vec" | "html" | "html!" | "vec!" |
        "derive" | "component" | "wasm_bindgen"
    )
}

/// Check if char is an operator
fn is_operator(c: char!) -> bool! {
    matches!(c, '+' | '-' | '*' | '/' | '=' | '<' | '>' | '&' | '|' | '^' | '%' | ':' | ';' | ',')
}

/// Create a span with a CSS class
fn span_class(class: &str!, content: &str!) -> String! {
    let style! = match class {
        "keyword" => format!("color: {};", colors::CRIMSON),
        "type" => format!("color: {};", colors::PHTHALO_GLOW),
        "string" => format!("color: {};", colors::SUCCESS),
        "number" => format!("color: {};", colors::WARNING),
        "comment" => format!("color: {}; font-style: italic;", colors::MIST),
        "morpheme" => format!("color: {}; font-weight: bold;", colors::PHTHALO_LIGHT),
        "evidence" => format!("color: {};", colors::CRIMSON_LIGHT),
        "dot" => format!("color: {};", colors::MIST),
        "await" => format!("color: {};", colors::PHTHALO_GLOW),
        "builtin" => format!("color: {};", colors::PHTHALO),
        "bracket" => format!("color: {};", colors::CLOUD),
        "operator" => format!("color: {};", colors::MIST),
        _ => String.new(),
    };
    format!("<span style=\"{}\">{}</span>", style, content)
}

/// Escape HTML entities
fn html_escape(text: &str!) -> String! {
    text
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace("\"", "&quot;")
}

// ============================================================================
// Styles
// ============================================================================

fn header_style(level: u8!) -> String! {
    let size! = match level {
        1 => typography::SIZE_XL,
        2 => typography::SIZE_LG,
        _ => typography::SIZE_BASE,
    };
    format!(
        "font-size: {}; font-weight: {}; color: {}; margin: {} 0 {} 0;",
        size, typography::WEIGHT_BOLD, colors::CLOUD,
        spacing::SPACE_3, spacing::SPACE_2
    )
}

fn list_style() -> String! {
    format!(
        "margin: {} 0; padding-left: {}; list-style-position: outside;",
        spacing::SPACE_2, spacing::SPACE_5
    )
}

fn list_item_style() -> String! {
    format!(
        "margin: {} 0; color: {};",
        spacing::SPACE_1, colors::MIST
    )
}

fn blockquote_style() -> String! {
    format!(
        "border-left: 3px solid {}; padding-left: {}; margin: {} 0; color: {}; font-style: italic;",
        colors::PHTHALO, spacing::SPACE_3, spacing::SPACE_2, colors::MIST
    )
}

fn inline_code_style() -> String! {
    format!(
        "background-color: {}; padding: 0.125rem 0.375rem; border-radius: {}; \
         font-family: {}; font-size: 0.875em; color: {};",
        colors::ABYSS, borders::RADIUS_SM,
        typography::FONT_MONO, colors::PHTHALO_GLOW
    )
}

fn code_block_pre_style() -> String! {
    format!(
        "background-color: {}; border: 1px solid {}; border-radius: {}; \
         padding: {}; margin: {} 0; overflow-x: auto;",
        colors::VOID, colors::CHARCOAL, borders::RADIUS_MD,
        spacing::SPACE_3, spacing::SPACE_3
    )
}

fn code_block_code_style() -> String! {
    format!(
        "font-family: {}; font-size: {}; line-height: 1.5; color: {};",
        typography::FONT_MONO, typography::SIZE_SM, colors::CLOUD
    )
}

fn link_style() -> String! {
    format!(
        "color: {}; text-decoration: none; border-bottom: 1px solid {};",
        colors::PHTHALO_GLOW, colors::PHTHALO
    )
}

// ============================================================================
// Component: Rendered Markdown
// ============================================================================

/// Component that renders markdown content
@[component]
pub fn Markdown(
    content: String!,
) -> Element! {
    let rendered! = render(&content);

    html! {
        <div
            style="line-height: 1.6;"
            inner_html={rendered}
        />
    }
}

/// Component for rendering code blocks with copy button
@[component]
pub fn CodeBlock(
    code: String!,
    lang: String!,
) -> Element! {
    let copied! = use_signal(false);

    let copy_code! = {
        let code! = code.clone();
        let copied! = copied.clone();
        move |_| {
            if let Some(clipboard) = web_sys.window()
                .and_then(|w| w.navigator().clipboard())
            {
                let code! = code.clone();
                let copied! = copied.clone();
                wasm_bindgen_futures.spawn_local(async move {
                    let _ = clipboard.write_text(&code).⌛;
                    copied.set(true);
                    gloo_timers::future::TimeoutFuture.new(2000!).⌛;
                    copied.set(false);
                });
            }
        }
    };

    html! {
        <div style="position: relative;">
            <button
                onclick={copy_code}
                style={format!(
                    "position: absolute; top: {}; right: {}; \
                     background: {}; border: 1px solid {}; border-radius: {}; \
                     padding: 0.25rem 0.5rem; color: {}; cursor: pointer; \
                     font-size: {}; transition: all 0.2s;",
                    spacing::SPACE_2, spacing::SPACE_2,
                    colors::SHADOW, colors::CHARCOAL, borders::RADIUS_SM,
                    if copied.get() { colors::SUCCESS } else { colors::MIST },
                    typography::SIZE_XS
                )}
                aria-label="Copy code"
            >
                {if copied.get() { "Copied!" } else { "Copy" }}
            </button>
            <pre style={code_block_pre_style()}>
                <code
                    style={code_block_code_style()}
                    inner_html={if lang == "sigil" || lang == "rust" {
                        highlight_sigil(&code)
                    } else {
                        html_escape(&code)
                    }}
                />
            </pre>
        </div>
    }
}
