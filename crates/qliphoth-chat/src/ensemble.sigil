//! Ensemble Orchestration - Multi-Persona Collaboration
//!
//! The conductor's podium. Where multiple AI personas deliberate,
//! their reasoning visible, their contributions attributed.
//!
//! ## Philosophy
//!
//! Complex problems benefit from multiple perspectives.
//! A security expert sees vulnerabilities. A UX designer sees friction.
//! An optimist sees possibility. A devil's advocate sees flaws.
//!
//! This module orchestrates their collaboration, making the
//! deliberation process transparent and the synthesis traceable.
//!
//! ## Workflow Patterns
//!
//! 1. **Parallel-Then-Synthesize** - All analyze simultaneously, merge results
//! 2. **Sequential-Discussion** - Each builds on previous analysis
//! 3. **Escalation-Chain** - Progressive expertise engagement
//! 4. **Iterative-Feedback** - Cyclic refinement across rounds
//! 5. **Adversarial-Synthesis** - Proposer-challenger with consensus

invoke sigil_web::prelude::*;
invoke crate::{
    ChatFxBridge, ChatFxEvent, ErrorSeverity,
    AgentEvent, TaskStatus,
    generate_request_id,
};

// =============================================================================
// CONFIGURATION
// =============================================================================

/// Ensemble orchestration configuration
@[Clone, Debug]
struct EnsembleConfig! {
    /// Persona API base URL
    api_url: str,
    /// Authentication token
    auth_token: str?,
    /// Maximum parallel consultations
    max_parallel: usize,
    /// Timeout per persona (ms)
    persona_timeout_ms: u32,
    /// Enable deliberation streaming
    stream_deliberation: bool,
}

impl Default for EnsembleConfig {
    fn default() -> Self! {
        EnsembleConfig {
            api_url: "http://localhost:8989/api".to_string(),
            auth_token: None,
            max_parallel: 4,
            persona_timeout_ms: 60000,
            stream_deliberation: true,
        }
    }
}

// =============================================================================
// PERSONA TYPES
// =============================================================================

/// A persona from the Grimoire
@[Clone, Debug, Serialize, Deserialize]
struct GrimoirePersona! {
    /// Unique persona code (e.g., "BACKEND_ENGINEER")
    code: str,
    /// Display name
    name: str,
    /// Description of expertise
    description: str,
    /// Default model to use
    default_model: str?,
    /// Temperature setting
    temperature: f64?,
    /// Top-p setting
    top_p: f64?,
    /// Tags for categorization
    tags: [str],
    /// Allowed tools
    allowed_tools: [str]?,
    /// Capabilities
    capabilities: [str]?,
    /// Is active
    active: bool,
}

/// Role assignment within an ensemble
@[Clone, Debug, Serialize, Deserialize]
struct EnsembleRole! {
    /// Persona code
    code: str,
    /// Role description for this ensemble
    role: str,
    /// Focus areas for analysis
    focus: [str],
    /// Priority (lower = earlier/more important)
    priority: u32,
}

// =============================================================================
// ENSEMBLE DEFINITION
// =============================================================================

/// An ensemble configuration
@[Clone, Debug, Serialize, Deserialize]
struct Ensemble! {
    /// Ensemble ID
    id: str,
    /// Display name
    name: str,
    /// Description
    description: str,
    /// Participating personas with roles
    personas: [EnsembleRole],
    /// Workflow pattern
    workflow: WorkflowPattern,
    /// Synthesis configuration
    synthesis: SynthesisConfig,
    /// Output configuration
    output: OutputConfig,
    /// Tags
    tags: [str],
}

/// Workflow patterns for ensemble orchestration
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum WorkflowPattern {
    /// All personas analyze simultaneously, results merged
    ParallelThenSynthesize,
    /// Each persona builds on previous analysis
    SequentialDiscussion,
    /// Progressive expertise engagement (triage â†’ specialist)
    EscalationChain,
    /// Cyclic refinement across multiple rounds
    IterativeFeedback,
    /// Proposer-challenger iterations with consensus
    AdversarialSynthesis,
}

impl WorkflowPattern {
    pub fn display_name(self) -> str {
        match self {
            WorkflowPattern::ParallelThenSynthesize => "Parallel Analysis",
            WorkflowPattern::SequentialDiscussion => "Sequential Discussion",
            WorkflowPattern::EscalationChain => "Escalation Chain",
            WorkflowPattern::IterativeFeedback => "Iterative Feedback",
            WorkflowPattern::AdversarialSynthesis => "Adversarial Synthesis",
        }
    }

    pub fn description(self) -> str {
        match self {
            WorkflowPattern::ParallelThenSynthesize =>
                "All personas analyze simultaneously, results merged into synthesis",
            WorkflowPattern::SequentialDiscussion =>
                "Each persona builds on previous analysis in sequence",
            WorkflowPattern::EscalationChain =>
                "Progressive engagement from triage to specialist",
            WorkflowPattern::IterativeFeedback =>
                "Multiple rounds of refinement across personas",
            WorkflowPattern::AdversarialSynthesis =>
                "Proposer-challenger debate until consensus",
        }
    }
}

/// Synthesis configuration
@[Clone, Debug, Serialize, Deserialize]
struct SynthesisConfig! {
    /// Output format
    format: SynthesisFormat,
    /// Sections to include
    sections: [SynthesisSection],
    /// Include attribution
    attribution: bool,
    /// Include confidence scores
    confidence_scores: bool,
    /// Include dissenting opinions
    dissenting_opinions: bool,
}

/// Synthesis output format
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum SynthesisFormat {
    Markdown,
    Html,
    Json,
    PullRequestComment,
}

/// Section in synthesis output
@[Clone, Debug, Serialize, Deserialize]
struct SynthesisSection! {
    name: str,
    content_prompt: str,
    required: bool,
}

/// Output configuration
@[Clone, Debug, Serialize, Deserialize]
struct OutputConfig! {
    /// Output format
    format: str,
    /// Include severity labels
    severity_labels: bool,
    /// Include line annotations (for code review)
    line_annotations: bool,
}

// =============================================================================
// DELIBERATION STATE
// =============================================================================

/// State of an ensemble deliberation
@[Clone, Debug]
struct DeliberationState! {
    /// Deliberation ID
    id: str,
    /// The ensemble being used
    ensemble: Ensemble,
    /// The query/task being addressed
    query: str,
    /// Context provided
    context: DeliberationContext,
    /// Current status
    status: DeliberationStatus,
    /// Contributions from each persona
    contributions: [PersonaContribution],
    /// Current round (for iterative workflows)
    current_round: u32,
    /// Maximum rounds
    max_rounds: u32,
    /// Synthesis result (when complete)
    synthesis: SynthesisResult?,
    /// Start time
    started_at: str,
    /// End time
    ended_at: str?,
    /// Errors encountered
    errors: [DeliberationError],
}

/// Deliberation context
@[Clone, Debug, Serialize, Deserialize]
struct DeliberationContext! {
    /// Files being analyzed
    files: [str],
    /// Code snippets
    code_snippets: [CodeSnippet],
    /// Pull request info
    pull_request: PullRequestContext?,
    /// Additional context
    additional: HashMap<str, str>,
}

/// Code snippet for context
@[Clone, Debug, Serialize, Deserialize]
struct CodeSnippet! {
    path: str,
    content: str,
    language: str,
    start_line: u32?,
    end_line: u32?,
}

/// Pull request context
@[Clone, Debug, Serialize, Deserialize]
struct PullRequestContext! {
    number: u64,
    title: str,
    description: str?,
    diff: str,
}

/// Deliberation status
@[Clone, Copy, Debug, PartialEq, Eq]
enum DeliberationStatus {
    /// Initializing
    Pending,
    /// Personas are analyzing
    Analyzing,
    /// Waiting for next round
    BetweenRounds,
    /// Synthesizing results
    Synthesizing,
    /// Complete
    Complete,
    /// Failed
    Failed,
    /// Cancelled
    Cancelled,
}

/// Contribution from a single persona
@[Clone, Debug]
struct PersonaContribution! {
    /// Persona code
    persona_code: str,
    /// Persona name
    persona_name: str,
    /// Role in this ensemble
    role: str,
    /// Round number
    round: u32,
    /// Status
    status: ContributionStatus,
    /// Thinking/reasoning (streaming)
    thinking: [str],
    /// Analysis content
    analysis: str,
    /// Findings/issues identified
    findings: [Finding],
    /// Suggestions made
    suggestions: [Suggestion],
    /// Confidence score (0-1)
    confidence: f64,
    /// Agrees with synthesis
    agrees_with_synthesis: bool?,
    /// Dissenting opinion
    dissent: str?,
    /// Timestamp
    timestamp: str,
    /// Tokens used
    tokens_used: u32,
}

/// Contribution status
@[Clone, Copy, Debug, PartialEq, Eq]
enum ContributionStatus {
    Pending,
    Thinking,
    Analyzing,
    Complete,
    Failed,
    Skipped,
}

/// A finding from analysis
@[Clone, Debug, Serialize, Deserialize]
struct Finding! {
    /// Finding ID
    id: str,
    /// Severity
    severity: FindingSeverity,
    /// Category
    category: str,
    /// Title
    title: str,
    /// Description
    description: str,
    /// Location (file:line)
    location: str?,
    /// Code snippet
    code_snippet: str?,
}

/// Finding severity
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum FindingSeverity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

impl FindingSeverity {
    pub fn color(self) -> str {
        match self {
            FindingSeverity::Critical => "#dc2626",
            FindingSeverity::High => "#ea580c",
            FindingSeverity::Medium => "#ca8a04",
            FindingSeverity::Low => "#2563eb",
            FindingSeverity::Info => "#6b7280",
        }
    }

    pub fn icon(self) -> str {
        match self {
            FindingSeverity::Critical => "ðŸš¨",
            FindingSeverity::High => "âš ï¸",
            FindingSeverity::Medium => "ðŸ“‹",
            FindingSeverity::Low => "ðŸ’¡",
            FindingSeverity::Info => "â„¹ï¸",
        }
    }
}

/// A suggestion for improvement
@[Clone, Debug, Serialize, Deserialize]
struct Suggestion! {
    /// Suggestion ID
    id: str,
    /// Related finding ID
    finding_id: str?,
    /// Title
    title: str,
    /// Description
    description: str,
    /// Suggested code (if applicable)
    suggested_code: str?,
    /// Location
    location: str?,
}

/// Error during deliberation
@[Clone, Debug]
struct DeliberationError! {
    persona_code: str?,
    phase: str,
    message: str,
    recoverable: bool,
    timestamp: str,
}

// =============================================================================
// SYNTHESIS RESULT
// =============================================================================

/// Result of ensemble synthesis
@[Clone, Debug, Serialize, Deserialize]
struct SynthesisResult! {
    /// Executive summary
    summary: str,
    /// Sections
    sections: [SynthesizedSection],
    /// All findings (merged and deduplicated)
    findings: [AttributedFinding],
    /// All suggestions
    suggestions: [AttributedSuggestion],
    /// Consensus level (0-1)
    consensus: f64,
    /// Dissenting opinions
    dissents: [DissentingOpinion],
    /// Overall recommendation
    recommendation: OverallRecommendation,
    /// Metadata
    metadata: SynthesisMetadata,
}

/// A synthesized section
@[Clone, Debug, Serialize, Deserialize]
struct SynthesizedSection! {
    name: str,
    content: str,
    contributors: [str],
}

// Finding with attribution
@[Clone, Debug, Serialize, Deserialize]
struct AttributedFinding! {
    finding: Finding,
    identified_by: [str],
    agreement: f64,
}

// Suggestion with attribution
@[Clone, Debug, Serialize, Deserialize]
struct AttributedSuggestion! {
    suggestion: Suggestion,
    suggested_by: str,
    endorsed_by: [str],
}

/// Dissenting opinion
@[Clone, Debug, Serialize, Deserialize]
struct DissentingOpinion! {
    persona_code: str,
    persona_name: str,
    opinion: str,
    reasoning: str,
}

// Overall recommendation
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum OverallRecommendation {
    Approve,
    ApproveWithSuggestions,
    RequestChanges,
    Block,
    Inconclusive,
}

impl OverallRecommendation {
    pub fn display(self) -> str {
        match self {
            OverallRecommendation::Approve => "âœ… Approved",
            OverallRecommendation::ApproveWithSuggestions => "âœ… Approved with Suggestions",
            OverallRecommendation::RequestChanges => "ðŸ”„ Changes Requested",
            OverallRecommendation::Block => "ðŸš« Blocked",
            OverallRecommendation::Inconclusive => "â“ Inconclusive",
        }
    }

    pub fn color(self) -> str {
        match self {
            OverallRecommendation::Approve => "#22c55e",
            OverallRecommendation::ApproveWithSuggestions => "#84cc16",
            OverallRecommendation::RequestChanges => "#f59e0b",
            OverallRecommendation::Block => "#ef4444",
            OverallRecommendation::Inconclusive => "#6b7280",
        }
    }
}

// Synthesis metadata
@[Clone, Debug, Serialize, Deserialize]
struct SynthesisMetadata! {
    personas_consulted: u32,
    rounds: u32,
    tokens_used: u32,
    duration_ms: u64,
    synthesized_at: str,
}

// =============================================================================
// ENSEMBLE BRIDGE
// =============================================================================

// Bridge for ensemble orchestration
@[Clone]
struct EnsembleBridge! {
    config: EnsembleConfig,
    ensembles: RwSignal,
    personas: RwSignal,
    current_deliberation: RwSignal,
    history: RwSignal,
    connected: RwSignal,
    error: RwSignal,
    fx: ChatFxBridge?,
}

impl EnsembleBridge {
    // Create a new ensemble bridge
    pub fn new(config: EnsembleConfig) -> Self! {
        EnsembleBridge {
            config,
            ensembles: create_signal([]),
            personas: create_signal([]),
            current_deliberation: create_signal(None),
            history: create_signal([]),
            connected: create_signal(false),
            error: create_signal(None),
            fx: None,
        }
    }

    // Set FX bridge
    pub fn with_fx(mut self, fx: ChatFxBridge) -> Self! {
        self.fx = Some(fx);
        self
    }

    /// Initialize - load ensembles and personas
    pub async fn init(self) -> Result<(), str>! {
        // Load personas
        let personas! = self.fetch("/personas")âŒ›? as [GrimoirePersona];
        self.personas.set(personas);

        // Load ensembles (from config or API)
        let ensembles = self.load_ensembles()âŒ›?;
        self.ensembles.set(ensembles);

        self.connected.set(true);
        Ok(())
    }

    /// Load ensemble configurations
    async fn load_ensembles(self) -> Result<[Ensemble], str>! {
        // Built-in ensembles
        Ok(vec![
            self.code_review_ensemble(),
            self.balanced_planning_ensemble(),
            self.design_review_ensemble(),
            self.security_audit_ensemble(),
            self.accessibility_review_ensemble(),
        ])
    }

    /// Start a new deliberation
    pub async fn start_deliberation(
        self,
        ensemble_id: str,
        query: str,
        context: DeliberationContext,
    ) -> Result<str, str>! {
        let ensemble = self.ensembles.get()
            |Ï†{_.id == ensemble_id}
            |Î±
            .ok_or("Ensemble not found")?;

        let deliberation_id = generate_request_id();
        let now = get_timestamp();

        let state = DeliberationState {
            id: deliberation_id.clone(),
            ensemble: ensemble.clone(),
            query,
            context,
            status: DeliberationStatus::Pending,
            contributions: [],
            current_round: 1,
            max_rounds: match ensemble.workflow {
                WorkflowPattern::IterativeFeedback => 3,
                WorkflowPattern::AdversarialSynthesis => 5,
                _ => 1,
            },
            synthesis: None,
            started_at: now,
            ended_at: None,
            errors: [],
        };

        self.current_deliberation.set(Some(state.clone()));

        // Trigger start effect
        if let Some(fx) = self.fx {
            fx.trigger(ChatFxEvent::Connected);
        }

        // Execute workflow
        self.execute_workflow()âŒ›?;

        Ok(deliberation_id)
    }

    /// Execute the deliberation workflow
    async fn execute_workflow(self) -> Result<(), str>! {
        let state = self.current_deliberation.get()
            .ok_or("No active deliberation")?;

        match state.ensemble.workflow {
            WorkflowPattern::ParallelThenSynthesize => {
                self.execute_parallel()âŒ›?;
            }
            WorkflowPattern::SequentialDiscussion => {
                self.execute_sequential()âŒ›?;
            }
            WorkflowPattern::EscalationChain => {
                self.execute_escalation()âŒ›?;
            }
            WorkflowPattern::IterativeFeedback => {
                self.execute_iterative()âŒ›?;
            }
            WorkflowPattern::AdversarialSynthesis => {
                self.execute_adversarial()âŒ›?;
            }
        }

        // Synthesize results
        self.synthesize()âŒ›?;

        Ok(())
    }

    /// Execute parallel workflow
    async fn execute_parallel(self) -> Result<(), str>! {
        self.update_status(DeliberationStatus::Analyzing);

        let state = self.current_deliberation.get().unwrap();
        let personas = state.ensemble.personas.clone();

        // Create contribution placeholders
        for role in personas.iter() {
            self.add_contribution_placeholder(role);
        }

        // Execute all personas in parallel and collect results
        let config! = self.config.clone();
        let query! = state.query.clone();
        let context! = state.context.clone();
        let fx! = self.fx.clone();

        for role in personas {
            let result! = Self::consult_persona(config.clone(), role.clone(), query.clone(), context.clone(), fx.as_ref())âŒ›;
            result |match {
                Ok(contribution) => self.update_contribution(contribution),
                Err(e) => self.add_error(None, "parallel_execution", e, true!),
            }
        }

        Ok(())
    }

    /// Execute sequential workflow
    async fn execute_sequential(self) -> Result<(), str>! {
        self.update_status(DeliberationStatus::Analyzing);

        let state = self.current_deliberation.get().unwrap();
        let personas = state.ensemble.personas.clone();
        let mut previous_analysis = String::new();

        for role in personas {
            self.add_contribution_placeholder(role.clone());

            // Include previous analyses in context
            let mut context = state.context.clone();
            if !previous_analysis.is_empty() {
                context.additional.insert(
                    "previous_analyses".to_string(),
                    previous_analysis.clone()
                );
            }

            match Self::consult_persona(self.config.clone(), role.clone(), state.query.clone(), context, self.fx.as_ref())âŒ› {
                Ok(contribution) => {
                    previous_analysis.push_str(&format!(
                        "\n\n## {} ({})\n{}",
                        contribution.persona_name,
                        contribution.role,
                        contribution.analysis
                    ));
                    self.update_contribution(contribution);
                }
                Err(e) => {
                    self.add_error(Some(role.code.clone()), "sequential_execution", e, true);
                }
            }
        }

        Ok(())
    }

    /// Execute escalation workflow
    async fn execute_escalation(self) -> Result<(), str>! {
        self.update_status(DeliberationStatus::Analyzing);

        let state = self.current_deliberation.get().unwrap();
        let personas! = state.ensemble.personas.clone() |Ïƒ{_.priority};

        let mut escalate = true;
        let mut previous_findings: [Finding] = [];

        for role in personas {
            if !escalate { break; }

            self.add_contribution_placeholder(role.clone());

            let mut context = state.context.clone();
            if !previous_findings.is_empty() {
                context.additional.insert(
                    "previous_findings".to_string(),
                    serde_json::to_string(&previous_findings).unwrap_or_default()
                );
            }

            match Self::consult_persona(self.config.clone(), role.clone(), state.query.clone(), context, self.fx.as_ref())âŒ› {
                Ok(contribution) => {
                    // Check if escalation is needed
                    let has_critical! = contribution.findings
                        |Ï†{_.severity |match { FindingSeverity::Critical => true, FindingSeverity::High => true, _ => false }}
                        .len() > 0;

                    previous_findings.extend(contribution.findings.clone());
                    self.update_contribution(contribution);

                    // Stop escalation if no critical issues
                    if !has_critical {
                        escalate = false;
                    }
                }
                Err(e) => {
                    self.add_error(Some(role.code.clone()), "escalation_execution", e, true);
                }
            }
        }

        Ok(())
    }

    /// Execute iterative workflow
    async fn execute_iterative(self) -> Result<(), str>! {
        let state = self.current_deliberation.get().unwrap();
        let max_rounds = state.max_rounds;

        for round in 1..=max_rounds {
            self.update_round(round);
            self.update_status(DeliberationStatus::Analyzing);

            // Get previous round feedback
            let previous_feedback = self.collect_round_feedback(round - 1);

            for role in state.ensemble.personas.iter() {
                self.add_contribution_placeholder(role.clone());

                let mut context = state.context.clone();
                if !previous_feedback.is_empty() {
                    context.additional.insert(
                        "previous_round_feedback".to_string(),
                        previous_feedback.clone()
                    );
                    context.additional.insert(
                        "round".to_string(),
                        round.to_string()
                    );
                }

                match Self::consult_persona(self.config.clone(), role.clone(), state.query.clone(), context, self.fx.as_ref())âŒ› {
                    Ok(mut contribution) => {
                        contribution.round = round;
                        self.update_contribution(contribution);
                    }
                    Err(e) => {
                        self.add_error(Some(role.code.clone()), format!("round_{}", round), e, true);
                    }
                }
            }

            // Check for convergence
            if self.check_convergence() {
                break;
            }

            if round < max_rounds {
                self.update_status(DeliberationStatus::BetweenRounds);
            }
        }

        Ok(())
    }

    /// Execute adversarial workflow
    async fn execute_adversarial(self) -> Result<(), str>! {
        let state = self.current_deliberation.get().unwrap();
        let personas = state.ensemble.personas.clone();

        if personas.len() < 2 {
            return Err("Adversarial workflow requires at least 2 personas".to_string());
        }

        let proposer = &personas[0];
        let challenger = &personas[1];
        let mut consensus = false;
        let max_rounds = state.max_rounds;

        for round in 1..=max_rounds {
            self.update_round(round);
            self.update_status(DeliberationStatus::Analyzing);

            // Proposer makes proposal
            let proposal = Self::consult_persona(
                self.config.clone(),
                proposer.clone(),
                state.query.clone(),
                state.context.clone(),
                self.fx.as_ref()
            )âŒ›?;
            self.update_contribution(proposal.clone());

            // Challenger challenges
            let mut challenge_context = state.context.clone();
            challenge_context.additional.insert(
                "proposal".to_string(),
                proposal.analysis.clone()
            );

            let challenge = Self::consult_persona(
                self.config.clone(),
                challenger.clone(),
                format!("Challenge this proposal: {}", proposal.analysis),
                challenge_context,
                self.fx.as_ref()
            )âŒ›?;
            self.update_contribution(challenge.clone());

            // Check for consensus
            if challenge.agrees_with_synthesis == Some(true) {
                consensus = true;
                break;
            }

            // Additional personas weigh in
            for role in personas.iter().skip(2) {
                let mut vote_context = state.context.clone();
                vote_context.additional.insert("proposal".to_string(), proposal.analysis.clone());
                vote_context.additional.insert("challenge".to_string(), challenge.analysis.clone());

                let vote = Self::consult_persona(
                    self.config.clone(),
                    role.clone(),
                    "Evaluate the proposal and challenge. Who has the stronger argument?".to_string(),
                    vote_context,
                    self.fx.as_ref()
                )âŒ›?;
                self.update_contribution(vote);
            }
        }

        Ok(())
    }

    /// Consult a single persona
    async fn consult_persona(
        config: EnsembleConfig,
        role: EnsembleRole,
        query: str,
        context: DeliberationContext,
        fx: ChatFxBridge?,
    ) -> Result<PersonaContribution, str>! {
        // Trigger thinking effect
        if let Some(fx) = fx {
            fx.trigger(ChatFxEvent::ThinkingStarted);
        }

        let url = format!("{}/ensemble/consult", config.api_url);
        let body = serde_json::json!({
            "persona_code": role.code,
            "role": role.role,
            "focus": role.focus,
            "query": query,
            "context": context
        });

        let response! = Self::post(url, body, config.auth_token)âŒ›? as ConsultResponse;

        // Trigger completion effect
        if let Some(fx) = fx {
            fx.trigger(ChatFxEvent::ThinkingComplete);
        }

        Ok(PersonaContribution {
            persona_code: role.code.clone(),
            persona_name: response.persona_name,
            role: role.role.clone(),
            round: 1,
            status: ContributionStatus::Complete,
            thinking: response.thinking,
            analysis: response.analysis,
            findings: response.findings,
            suggestions: response.suggestions,
            confidence: response.confidence,
            agrees_with_synthesis: None,
            dissent: None,
            timestamp: get_timestamp(),
            tokens_used: response.tokens_used,
        })
    }

    /// Synthesize all contributions
    async fn synthesize(self) -> Result<(), str>! {
        self.update_status(DeliberationStatus::Synthesizing);

        let state = self.current_deliberation.get().unwrap();
        let contributions = state.contributions.clone();

        // Merge and deduplicate findings
        let mut all_findings: Map<str, (Finding, [str])> = Map::new();
        for contrib in &contributions {
            for finding in &contrib.findings {
                let key = format!("{}:{}", finding.category, finding.title);
                all_findings
                    .entry(key)
                    .or_insert_with(|| (finding.clone(), []))
                    .1
                    .push(contrib.persona_code.clone());
            }
        }

        let attributed_findings! = all_findings.into_values()
            |Ï„{ (finding, identified_by) => {
                let agreement! = identified_by.len() as f64 / contributions.len() as f64;
                AttributedFinding { finding, identified_by, agreement }
            }}
            |vec;

        // Merge suggestions
        let attributed_suggestions! = contributions
            |Ï„{ c => c.suggestions |Ï„{ s => AttributedSuggestion {
                suggestion: s.clone(),
                suggested_by: c.persona_code.clone(),
                endorsed_by: [],
            }}}
            |flatten
            |vec;

        // Calculate consensus
        let consensus! = self.calculate_consensus(contributions.clone());

        // Collect dissents
        let dissents! = contributions
            |Ï†{ c => c.dissent.is_some() }
            |Ï„{ c => DissentingOpinion {
                persona_code: c.persona_code.clone(),
                persona_name: c.persona_name.clone(),
                opinion: c.dissent.unwrap().clone(),
                reasoning: String::new(),
            }}
            |vec;

        // Determine recommendation
        let recommendation = self.determine_recommendation(attributed_findings.clone(), consensus);

        // Build sections
        let sections = self.build_synthesis_sections(contributions.clone(), state.ensemble.synthesis.clone());

        // Generate summary
        let summary = self.generate_summary(attributed_findings.clone(), recommendation.clone());

        let synthesis = SynthesisResult {
            summary,
            sections,
            findings: attributed_findings,
            suggestions: attributed_suggestions,
            consensus,
            dissents,
            recommendation,
            metadata: SynthesisMetadata {
                personas_consulted: contributions.len() as u32,
                rounds: state.current_round,
                tokens_used: contributions |Ï„{_.tokens_used} |Î£,
                duration_ms: 0, // Calculate from timestamps
                synthesized_at: get_timestamp(),
            },
        };

        // Update deliberation state
        let current! = self.current_deliberation.get();
        if let Some(mut state) = current {
            state.synthesis = Some(synthesis);
            state.status = DeliberationStatus::Complete;
            state.ended_at = Some(get_timestamp());
            self.current_deliberation.set(Some(state));
        }

        // Trigger completion effect
        if let Some(fx) = self.fx {
            fx.trigger(ChatFxEvent::MessageComplete { total_tokens: 0 });
        }

        Ok(())
    }

    // =========================================================================
    // HELPER METHODS
    // =========================================================================

    fn update_status(self, status: DeliberationStatus) {
        let current! = self.current_deliberation.get();
        if let Some(mut state) = current {
            state.status = status;
            self.current_deliberation.set(Some(state));
        }
    }

    fn update_round(self, round: u32) {
        let current! = self.current_deliberation.get();
        if let Some(mut state) = current {
            state.current_round = round;
            self.current_deliberation.set(Some(state));
        }
    }

    fn add_contribution_placeholder(self, role: EnsembleRole) {
        let current! = self.current_deliberation.get();
        if let Some(mut state) = current {
            state.contributions.push(PersonaContribution {
                persona_code: role.code.clone(),
                persona_name: String::new(),
                role: role.role.clone(),
                round: state.current_round,
                status: ContributionStatus::Pending,
                thinking: [],
                analysis: String::new(),
                findings: [],
                suggestions: [],
                confidence: 0.0,
                agrees_with_synthesis: None,
                dissent: None,
                timestamp: get_timestamp(),
                tokens_used: 0,
            });
            self.current_deliberation.set(Some(state));
        }
    }

    fn update_contribution(self, contribution: PersonaContribution) {
        let current! = self.current_deliberation.get();
        if let Some(mut state) = current {
            // Find and update existing or add new
            let idx! = state.contributions
                |Ï†{_.persona_code == contribution.persona_code && _.round == contribution.round}
                |Î±;
            if let Some(i) = idx {
                state.contributions[i] = contribution;
            } else {
                state.contributions.push(contribution);
            }
            self.current_deliberation.set(Some(state));
        }
    }

    fn add_error(self, persona_code: str?, phase: str, message: str, recoverable: bool) {
        let current! = self.current_deliberation.get();
        if let Some(mut state) = current {
            state.errors.push(DeliberationError {
                persona_code: persona_code.map(String::from),
                phase: phase.to_string(),
                message: message.to_string(),
                recoverable,
                timestamp: get_timestamp(),
            });
            self.current_deliberation.set(Some(state));
        }

        if let Some(fx) = self.fx {
            fx.trigger(ChatFxEvent::Error {
                severity: if recoverable { ErrorSeverity::Medium } else { ErrorSeverity::High },
                message: message.to_string(),
            });
        }
    }

    fn collect_round_feedback(self, round: u32) -> str {
        if round == 0 { return String::new(); }

        let state = self.current_deliberation.get().unwrap();
        state.contributions
            |Ï†{_.round == round}
            |Ï„{format!("## {} ({})\n{}", _.persona_name, _.role, _.analysis)}
            |vec
            .join("\n\n")
    }

    fn check_convergence(self) -> bool {
        let state = self.current_deliberation.get().unwrap();
        let current_round = state.current_round;

        if current_round < 2 { return false; }

        // Check if all personas agree
        let round_contribs! = state.contributions |Ï†{_.round == current_round};
        let agrees! = round_contribs |Ï†{_.agrees_with_synthesis == Some(true)};
        agrees.len() == round_contribs.len() && !round_contribs.is_empty()
    }

    fn calculate_consensus(self, contributions: [PersonaContribution]) -> f64 {
        if contributions.is_empty() { return 0.0; }

        // Simple average confidence weighted by agreement
        let mut total: f64 = 0.0;
        for c in contributions.iter() {
            let agreement_weight! = if c.dissent.is_some() { 0.5 } else { 1.0 };
            total += c.confidence * agreement_weight;
        }

        total / contributions.len() as f64
    }

    fn determine_recommendation(
        self,
        findings: [AttributedFinding],
        consensus: f64,
    ) -> OverallRecommendation {
        let critical_count! = findings
            |Ï†{_.finding.severity |match { FindingSeverity::Critical => true, _ => false }}
            .len();
        let high_count! = findings
            |Ï†{_.finding.severity |match { FindingSeverity::High => true, _ => false }}
            .len();

        if critical_count > 0 {
            OverallRecommendation::Block
        } else if high_count > 2 {
            OverallRecommendation::RequestChanges
        } else if high_count > 0 || findings.len() > 5 {
            OverallRecommendation::ApproveWithSuggestions
        } else if consensus < 0.5 {
            OverallRecommendation::Inconclusive
        } else {
            OverallRecommendation::Approve
        }
    }

    fn build_synthesis_sections(
        self,
        contributions: [PersonaContribution],
        config: SynthesisConfig,
    ) -> [SynthesizedSection] {
        let mut sections: [SynthesizedSection] = [];
        for section in config.sections {
            let relevant! = contributions |Ï†{!_.analysis.is_empty()};
            let content! = relevant
                |Ï„{format!("**{}**: {}", _.persona_name, _.analysis.lines() |Î½{0..3} |vec.join(" "))}
                |vec
                .join("\n\n");

            sections.push(SynthesizedSection {
                name: section.name.clone(),
                content,
                contributors: contributions |Ï„{_.persona_code.clone()} |vec,
            });
        }
        sections
    }

    fn generate_summary(self, findings: [AttributedFinding], recommendation: OverallRecommendation) -> str {
        let critical! = findings |Ï†{_.finding.severity |match { FindingSeverity::Critical => true, _ => false }} .len();
        let high! = findings |Ï†{_.finding.severity |match { FindingSeverity::High => true, _ => false }} .len();
        let medium! = findings |Ï†{_.finding.severity |match { FindingSeverity::Medium => true, _ => false }} .len();

        format!(
            "{}\n\nFindings: {} critical, {} high, {} medium severity issues identified.",
            recommendation.display(),
            critical, high, medium
        )
    }

    // =========================================================================
    // HTTP HELPERS
    // =========================================================================

    async fn fetch<T: Deserialize>(self, path: str) -> Result<T, str>! {
        let url = format!("{}{}", self.config.api_url, path);
        Self::get(url, self.config.auth_token.clone())âŒ›
    }

    async fn get<T: Deserialize>(url: str, auth: str?) -> Result<T, str>! {
        let mut opts = web_sys::RequestInit::new();
        opts.method("GET");

        let request = web_sys::Request::new_with_str_and_init(url, opts)
            .err_to_string()?;

        if let Some(token) = auth {
            request.headers().set("Authorization", format!("Bearer {}", token)).ok();
        }

        let window = web_sys::window().ok_or("No window")?;
        let resp = wasm_bindgen_futures::JsFuture::from(window.fetch_with_request(request))
            âŒ›.err_to_string()?;

        let resp: web_sys::Response = resp.dyn_into().ok_or("Not Response")?;
        let json = wasm_bindgen_futures::JsFuture::from(resp.json().err_to_string()?)
            âŒ›.err_to_string()?;

        serde_wasm_bindgen::from_value(json).err_to_string()
    }

    async fn post<T: Deserialize>(url: str, body: serde_json::Value, auth: str?) -> Result<T, str>! {
        let body_str = serde_json::to_string(body).err_to_string()?;

        let mut opts = web_sys::RequestInit::new();
        opts.method("POST");
        opts.body(Some(JsValue::from_str(body_str)));

        let request = web_sys::Request::new_with_str_and_init(url, opts)
            .err_to_string()?;

        request.headers().set("Content-Type", "application/json").ok();
        if let Some(token) = auth {
            request.headers().set("Authorization", format!("Bearer {}", token)).ok();
        }

        let window = web_sys::window().ok_or("No window")?;
        let resp = wasm_bindgen_futures::JsFuture::from(window.fetch_with_request(request))
            âŒ›.err_to_string()?;

        let resp: web_sys::Response = resp.dyn_into().ok_or("Not Response")?;
        let json = wasm_bindgen_futures::JsFuture::from(resp.json().err_to_string()?)
            âŒ›.err_to_string()?;

        serde_wasm_bindgen::from_value(json).err_to_string()
    }

    // =========================================================================
    // BUILT-IN ENSEMBLES
    // =========================================================================

    fn code_review_ensemble(self) -> Ensemble {
        Ensemble {
            id: "code-review-team".to_string(),
            name: "Code Review Team".to_string(),
            description: "Comprehensive multi-perspective code review".to_string(),
            personas: vec![
                EnsembleRole {
                    code: "SECURITY_REVIEWER".to_string(),
                    role: "Find security vulnerabilities".to_string(),
                    focus: vec!["SQL injection".to_string(), "XSS".to_string(), "Auth flaws".to_string()],
                    priority: 1,
                },
                EnsembleRole {
                    code: "BACKEND_ENGINEER".to_string(),
                    role: "Review implementation quality".to_string(),
                    focus: vec!["Code structure".to_string(), "Performance".to_string(), "Best practices".to_string()],
                    priority: 2,
                },
                EnsembleRole {
                    code: "BREAKER".to_string(),
                    role: "Find edge cases and failure modes".to_string(),
                    focus: vec!["Edge cases".to_string(), "Error handling".to_string(), "Race conditions".to_string()],
                    priority: 3,
                },
                EnsembleRole {
                    code: "DEVILS_ADVOCATE".to_string(),
                    role: "Challenge assumptions".to_string(),
                    focus: vec!["Hidden assumptions".to_string(), "Alternatives".to_string()],
                    priority: 4,
                },
            ],
            workflow: WorkflowPattern::ParallelThenSynthesize,
            synthesis: SynthesisConfig {
                format: SynthesisFormat::PullRequestComment,
                sections: vec![
                    SynthesisSection { name: "Executive Summary".to_string(), content_prompt: "Overall assessment".to_string(), required: true },
                    SynthesisSection { name: "Critical Issues".to_string(), content_prompt: "Must-fix issues".to_string(), required: true },
                    SynthesisSection { name: "Suggestions".to_string(), content_prompt: "Improvement suggestions".to_string(), required: false },
                ],
                attribution: true,
                confidence_scores: true,
                dissenting_opinions: true,
            },
            output: OutputConfig {
                format: "pull-request-comment".to_string(),
                severity_labels: true,
                line_annotations: true,
            },
            tags: vec!["code-review".to_string(), "security".to_string(), "quality".to_string()],
        }
    }

    fn balanced_planning_ensemble(self) -> Ensemble {
        Ensemble {
            id: "balanced-planning".to_string(),
            name: "Balanced Planning".to_string(),
            description: "Multiple perspectives for project planning".to_string(),
            personas: vec![
                EnsembleRole {
                    code: "OPTIMIST".to_string(),
                    role: "Identify opportunities and best-case scenarios".to_string(),
                    focus: vec!["Opportunities".to_string(), "Quick wins".to_string()],
                    priority: 1,
                },
                EnsembleRole {
                    code: "PESSIMIST".to_string(),
                    role: "Identify risks and worst-case scenarios".to_string(),
                    focus: vec!["Risks".to_string(), "Blockers".to_string()],
                    priority: 2,
                },
                EnsembleRole {
                    code: "DEVILS_ADVOCATE".to_string(),
                    role: "Challenge the plan".to_string(),
                    focus: vec!["Assumptions".to_string(), "Alternatives".to_string()],
                    priority: 3,
                },
            ],
            workflow: WorkflowPattern::SequentialDiscussion,
            synthesis: SynthesisConfig {
                format: SynthesisFormat::Markdown,
                sections: vec![
                    SynthesisSection { name: "Opportunities".to_string(), content_prompt: "Best-case outcomes".to_string(), required: true },
                    SynthesisSection { name: "Risks".to_string(), content_prompt: "Potential problems".to_string(), required: true },
                    SynthesisSection { name: "Recommendations".to_string(), content_prompt: "Balanced recommendations".to_string(), required: true },
                ],
                attribution: true,
                confidence_scores: false,
                dissenting_opinions: true,
            },
            output: OutputConfig {
                format: "markdown".to_string(),
                severity_labels: false,
                line_annotations: false,
            },
            tags: vec!["planning".to_string(), "strategy".to_string()],
        }
    }

    fn design_review_ensemble(self) -> Ensemble {
        Ensemble {
            id: "design-review".to_string(),
            name: "Design Review".to_string(),
            description: "Architecture and design validation".to_string(),
            personas: vec![
                EnsembleRole {
                    code: "SYSTEMS_ARCHITECT".to_string(),
                    role: "Evaluate architectural decisions".to_string(),
                    focus: vec!["Scalability".to_string(), "Maintainability".to_string(), "Patterns".to_string()],
                    priority: 1,
                },
                EnsembleRole {
                    code: "BACKEND_ENGINEER".to_string(),
                    role: "Assess implementation feasibility".to_string(),
                    focus: vec!["Implementation complexity".to_string(), "Technical debt".to_string()],
                    priority: 2,
                },
            ],
            workflow: WorkflowPattern::SequentialDiscussion,
            synthesis: SynthesisConfig {
                format: SynthesisFormat::Markdown,
                sections: vec![
                    SynthesisSection { name: "Architecture Assessment".to_string(), content_prompt: "".to_string(), required: true },
                    SynthesisSection { name: "Recommendations".to_string(), content_prompt: "".to_string(), required: true },
                ],
                attribution: true,
                confidence_scores: true,
                dissenting_opinions: true,
            },
            output: OutputConfig {
                format: "markdown".to_string(),
                severity_labels: true,
                line_annotations: false,
            },
            tags: vec!["architecture".to_string(), "design".to_string()],
        }
    }

    fn security_audit_ensemble(self) -> Ensemble {
        Ensemble {
            id: "security-audit".to_string(),
            name: "Security Audit".to_string(),
            description: "Comprehensive security review".to_string(),
            personas: vec![
                EnsembleRole {
                    code: "SECURITY_REVIEWER".to_string(),
                    role: "Primary security analysis".to_string(),
                    focus: vec!["OWASP Top 10".to_string(), "Authentication".to_string(), "Authorization".to_string()],
                    priority: 1,
                },
                EnsembleRole {
                    code: "BREAKER".to_string(),
                    role: "Penetration testing perspective".to_string(),
                    focus: vec!["Attack vectors".to_string(), "Exploit paths".to_string()],
                    priority: 2,
                },
            ],
            workflow: WorkflowPattern::EscalationChain,
            synthesis: SynthesisConfig {
                format: SynthesisFormat::Markdown,
                sections: vec![
                    SynthesisSection { name: "Security Assessment".to_string(), content_prompt: "".to_string(), required: true },
                    SynthesisSection { name: "Vulnerabilities".to_string(), content_prompt: "".to_string(), required: true },
                    SynthesisSection { name: "Remediation".to_string(), content_prompt: "".to_string(), required: true },
                ],
                attribution: true,
                confidence_scores: true,
                dissenting_opinions: false,
            },
            output: OutputConfig {
                format: "markdown".to_string(),
                severity_labels: true,
                line_annotations: true,
            },
            tags: vec!["security".to_string(), "audit".to_string()],
        }
    }

    fn accessibility_review_ensemble(self) -> Ensemble {
        Ensemble {
            id: "accessibility-review".to_string(),
            name: "Accessibility Review".to_string(),
            description: "A11y compliance review".to_string(),
            personas: vec![
                EnsembleRole {
                    code: "UX_DESIGNER".to_string(),
                    role: "Evaluate accessibility from design perspective".to_string(),
                    focus: vec!["WCAG compliance".to_string(), "Screen reader support".to_string(), "Keyboard navigation".to_string()],
                    priority: 1,
                },
                EnsembleRole {
                    code: "FRONTEND_ENGINEER".to_string(),
                    role: "Assess implementation of a11y features".to_string(),
                    focus: vec!["ARIA labels".to_string(), "Semantic HTML".to_string(), "Focus management".to_string()],
                    priority: 2,
                },
            ],
            workflow: WorkflowPattern::ParallelThenSynthesize,
            synthesis: SynthesisConfig {
                format: SynthesisFormat::Markdown,
                sections: vec![
                    SynthesisSection { name: "Compliance Status".to_string(), content_prompt: "".to_string(), required: true },
                    SynthesisSection { name: "Issues".to_string(), content_prompt: "".to_string(), required: true },
                    SynthesisSection { name: "Recommendations".to_string(), content_prompt: "".to_string(), required: true },
                ],
                attribution: true,
                confidence_scores: false,
                dissenting_opinions: false,
            },
            output: OutputConfig {
                format: "markdown".to_string(),
                severity_labels: true,
                line_annotations: true,
            },
            tags: vec!["accessibility".to_string(), "a11y".to_string(), "wcag".to_string()],
        }
    }

    // =========================================================================
    // ACCESSORS
    // =========================================================================

    pub fn get_ensembles(self) -> [Ensemble] {
        self.ensembles.get()
    }

    pub fn get_personas(self) -> [GrimoirePersona] {
        self.personas.get()
    }

    pub fn get_current_deliberation(self) -> DeliberationState? {
        self.current_deliberation.get()
    }

    pub fn get_history(self) -> [DeliberationState] {
        self.history.get()
    }

    pub fn is_connected(self) -> bool {
        self.connected.get()
    }
}

// =============================================================================
// API RESPONSE TYPES
// =============================================================================

@[Clone, Debug, Deserialize]
struct ConsultResponse {
    persona_name: str,
    thinking: [str],
    analysis: str,
    findings: [Finding],
    suggestions: [Suggestion],
    confidence: f64,
    tokens_used: u32,
}

// =============================================================================
// REACT HOOKS & PROVIDERS
// =============================================================================

/// Hook for ensemble bridge
pub fn use_ensemble() -> EnsembleBridge {
    use_context() as EnsembleBridge
        .expect("EnsembleBridge not provided")
}

/// Provider component
@[component]
pub fn EnsembleProvider(
    @[prop(default = EnsembleConfig::default())] config: EnsembleConfig,
    children: Children,
) -> Element! {
    let bridge! = EnsembleBridge::new(config);

    // Initialize on mount
    on_mount(bridge.clone(), async {
        if let Err(e) = bridge.init()âŒ› {
            web_sys::console::error_1(&format!("Ensemble init error: {}", e).into());
        }
    });

    provide_context(bridge.clone());

    view! { {children()} }
}

// =============================================================================
// VISUALIZATION COMPONENTS
// =============================================================================

/// Ensemble selector
@[component]
pub fn EnsembleSelector(
    @[prop(into)] on_select: Callback<str>,
) -> Element! {
    let bridge! = use_ensemble();

    view! {
        <div class="ensemble-selector">
            <h3>"Select Ensemble"</h3>
            <div class="ensemble-grid">
                {bridge.get_ensembles() |Ï„{
                    let id! = _.id.clone();
                    view! {
                        <div
                            class="ensemble-card"
                            @click={on_select.call(id.clone())}
                        >
                            <h4>{_.name}</h4>
                            <p>{_.description}</p>
                            <div class="ensemble-meta">
                                <span class="persona-count">{_.personas.len()} " personas"</span>
                                <span class="workflow">{_.workflow.display_name()}</span>
                            </div>
                            <div class="ensemble-tags">
                                {_.tags |Ï„{view! { <span class="tag">{_}</span> }} |vec}
                            </div>
                        </div>
                    }
                } |vec}
            </div>
        </div>
    }
}

/// Deliberation view - the conductor's podium
@[component]
pub fn DeliberationView() -> Element! {
    let bridge! = use_ensemble();
    let state! = bridge.get_current_deliberation();

    view! {
        <div class="deliberation-view">
            <Show when={state.is_some()}>
                <div class="deliberation-content">
                    // Header
                    <div class="deliberation-header">
                        <h2>{state.unwrap().ensemble.name}</h2>
                        <span class="status">{format!("{:?}", state.unwrap().status)}</span>
                        <span class="round">"Round " {state.unwrap().current_round} "/" {state.unwrap().max_rounds}</span>
                    </div>

                    // Query
                    <div class="deliberation-query">
                        <h4>"Query"</h4>
                        <p>{state.unwrap().query}</p>
                    </div>

                    // Persona contributions (the podium)
                    <div class="persona-podium">
                        {state.unwrap().contributions |Ï„{view! {
                            <PersonaContributionCard contribution={_} />
                        }} |vec}
                    </div>

                    // Synthesis result
                    <Show when={state.unwrap().synthesis.is_some()}>
                        <SynthesisView synthesis={state.unwrap().synthesis.unwrap()} />
                    </Show>

                    // Errors
                    <Show when={!state.unwrap().errors.is_empty()}>
                        <div class="deliberation-errors">
                            <h4>"Errors"</h4>
                            {state.unwrap().errors |Ï„{view! {
                                <div class="error-item">
                                    <Show when={_.persona_code.is_some()}>
                                        <span class="persona">{_.persona_code.unwrap()}</span>
                                    </Show>
                                    <span class="phase">{_.phase}</span>
                                    <span class="message">{_.message}</span>
                                </div>
                            }} |vec}
                        </div>
                    </Show>
                </div>
            </Show>
        </div>
    }
}

/// Individual persona contribution card
@[component]
fn PersonaContributionCard(contribution: PersonaContribution) -> Element! {
    let status_class! = contribution.status |match {
        ContributionStatus::Pending => "pending",
        ContributionStatus::Thinking => "thinking",
        ContributionStatus::Analyzing => "analyzing",
        ContributionStatus::Complete => "complete",
        ContributionStatus::Failed => "failed",
        ContributionStatus::Skipped => "skipped",
    };

    view! {
        <div class=format!("persona-card {}", status_class)>
            <div class="persona-header">
                <span class="persona-name">{contribution.persona_name}</span>
                <span class="persona-role">{contribution.role}</span>
                <span class="confidence">{format!("{:.0}%", contribution.confidence * 100.0)}</span>
            </div>

            // Thinking (streaming)
            <Show when={!contribution.thinking.is_empty()}>
                <div class="thinking-stream">
                    {contribution.thinking |Ï„{view! {
                        <div class="thought">"ðŸ’­ " {_}</div>
                    }} |vec}
                </div>
            </Show>

            // Analysis
            <Show when={!contribution.analysis.is_empty()}>
                <div class="analysis">{contribution.analysis}</div>
            </Show>

            // Findings
            <Show when={!contribution.findings.is_empty()}>
                <div class="findings">
                    <h5>"Findings"</h5>
                    {contribution.findings |Ï„{view! {
                        <div class="finding" style=format!("border-left: 3px solid {}", _.severity.color())>
                            <span class="icon">{_.severity.icon()}</span>
                            <span class="title">{_.title}</span>
                        </div>
                    }} |vec}
                </div>
            </Show>

            // Dissent
            <Show when={contribution.dissent.is_some()}>
                <div class="dissent">
                    <h5>"âš¡ Dissenting Opinion"</h5>
                    <p>{contribution.dissent.unwrap()}</p>
                </div>
            </Show>
        </div>
    }
}

/// Synthesis result view
@[component]
fn SynthesisView(synthesis: SynthesisResult) -> Element! {
    view! {
        <div class="synthesis-view">
            // Recommendation banner
            <div
                class="recommendation-banner"
                style=format!("background-color: {}", synthesis.recommendation.color())
            >
                {synthesis.recommendation.display()}
            </div>

            // Summary
            <div class="synthesis-summary">
                <p>{synthesis.summary}</p>
            </div>

            // Sections
            <div class="synthesis-sections">
                {synthesis.sections |Ï„{view! {
                    <div class="section">
                        <h4>{_.name}</h4>
                        <div class="section-content">{_.content}</div>
                        <div class="contributors">
                            "Contributors: "
                            {_.contributors.join(", ")}
                        </div>
                    </div>
                }} |vec}
            </div>

            // Attributed findings
            <div class="attributed-findings">
                <h4>"Findings"</h4>
                {synthesis.findings |Ï„{view! {
                    <div class="attributed-finding">
                        <span class="icon">{_.finding.severity.icon()}</span>
                        <span class="title">{_.finding.title}</span>
                        <span class="agreement">{format!("{:.0}% agreement", _.agreement * 100.0)}</span>
                        <div class="identified-by">
                            {_.identified_by.join(", ")}
                        </div>
                    </div>
                }} |vec}
            </div>

            // Dissenting opinions
            <Show when={!synthesis.dissents.is_empty()}>
                <div class="dissents">
                    <h4>"Dissenting Opinions"</h4>
                    {synthesis.dissents |Ï„{view! {
                        <div class="dissent">
                            <span class="persona">{_.persona_name}</span>
                            <p>{_.opinion}</p>
                        </div>
                    }} |vec}
                </div>
            </Show>

            // Metadata
            <div class="synthesis-meta">
                <span>{synthesis.metadata.personas_consulted} " personas"</span>
                <span>{synthesis.metadata.rounds} " rounds"</span>
                <span>{synthesis.metadata.tokens_used} " tokens"</span>
            </div>
        </div>
    }
}

// =============================================================================
// UTILITY
// =============================================================================

fn get_timestamp() -> str {
    let date = js_sys::Date::new_0();
    format!(
        "{}-{:02}-{:02}T{:02}:{:02}:{:02}",
        date.get_full_year(),
        date.get_month() + 1,
        date.get_date(),
        date.get_hours(),
        date.get_minutes(),
        date.get_seconds()
    )
}
