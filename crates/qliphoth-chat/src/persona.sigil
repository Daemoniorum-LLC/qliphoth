//! Persona System for Qliphoth Chat
//!
//! Sigil-native persona definitions with evidentiality on beliefs,
//! state modeling for adaptive behavior, and morpheme-driven
//! specialization matching.
//!
//! ## Design Philosophy
//!
//! Personas are not just system prompts - they're behavioral models
//! with beliefs, specializations, and evolving state. A persona's
//! confidence rises with successful interactions and falls with
//! confusion or errors.

use sigil_web::prelude::*;
use qliphoth_core::state::{Signal, create_signal};
use qliphoth_ui::theme::{colors, typography, spacing, borders};
use crate::context::ContextScope;

// ============================================================================
// PERSONA TYPES
// ============================================================================

/// A persona definition with Sigil evidentiality semantics
@[Clone, Debug]
struct PersonaDefinition! {
    /// Unique identifier
    pub id: String!,
    /// Display name
    pub name: String!,
    /// Short title/role
    pub title: String!,
    /// Avatar emoji or URL
    pub avatar: String!,
    /// Core description of the persona's role
    pub description: String!,

    // Beliefs with evidentiality
    pub expertise: [String],              // Areas where this persona has certain knowledge (!)
    pub related_domains: [String]~,       // Areas where knowledge is inferred (~)
    pub learning_areas: [String]?,        // Areas of uncertainty (?)

    /// Voice characteristics
    pub voice: PersonaVoice!,
    /// Behavioral modifiers
    pub behavior: PersonaBehavior!,
}

/// How the persona speaks
@[Clone, Debug]
struct PersonaVoice! {
    pub tone: VoiceTone,                  // Formal, casual, technical, playful
    pub pronoun: String,                  // First person style
    pub signature_phrases: [String],      // Characteristic phrases
    pub verbosity: Verbosity,             // How verbose responses should be
    pub code_frequency: CodeFrequency,    // Use of code examples
}

/// Tone of voice
@[Clone, Debug, PartialEq, Eq]
enum VoiceTone {
    /// Professional, precise
    Formal,
    /// Friendly, approachable
    Casual,
    /// Deep, detailed explanations
    Technical,
    /// Light, encouraging
    Playful,
    /// Teaching-focused
    Educational,
}

/// How verbose responses should be
@[Clone, Debug, PartialEq, Eq]
enum Verbosity {
    /// Brief, to the point
    Concise,
    /// Standard length
    Normal,
    /// Detailed explanations
    Detailed,
    /// Comprehensive with examples
    Thorough,
}

/// How often to include code
@[Clone, Debug, PartialEq, Eq]
enum CodeFrequency {
    /// Rarely show code
    Minimal,
    /// When helpful
    AsNeeded,
    /// Frequently with examples
    Often,
    /// Lead with code
    Always,
}

/// Behavioral characteristics that affect responses
@[Clone, Debug]
struct PersonaBehavior! {
    pub risk_tolerance: f64,              // How willing to take risks in suggestions
    pub curiosity: f64,                   // How much to probe user's understanding
    pub assertiveness: f64,               // How strongly to defend positions
    pub teaching_mode: bool,              // How much to check for understanding
}

// ============================================================================
// PERSONA STATE (Mood/Experience)
// ============================================================================

/// Dynamic state that evolves with interactions
@[Clone, Debug]
struct PersonaState! {
    pub confidence: RwSignal,     // Current confidence level (0.0 - 1.0)
    pub energy: RwSignal,         // Current energy/fatigue (0.0 - 1.0)
    pub uncertainty: RwSignal?,   // Uncertainty about current context (0.0 - 1.0)
    pub rapport: RwSignal,        // Rapport with current user session
    pub successes: RwSignal,      // Count of successful responses
    pub clarifications: RwSignal, // Count of clarification requests
}

impl PersonaState {
    pub fn new() -> Self! {
        PersonaState {
            confidence: create_signal(0.7),
            energy: create_signal(1.0),
            uncertainty: create_signal(0.3),
            rapport: create_signal(0.5),
            successes: create_signal(0),
            clarifications: create_signal(0),
        }
    }

    /// Update state after a successful response
    pub fn record_success(self: &Self!) {
        self.confidence.update(|c| *c = (*c + 0.05).min(1.0));
        self.rapport.update(|r| *r = (*r + 0.03).min(1.0));
        self.uncertainty.update(|u| *u = (*u - 0.1).max(0.0));
        self.successes.update(|s| *s += 1);
    }

    /// Update state when user asks for clarification
    pub fn record_clarification(self: &Self!) {
        self.confidence.update(|c| *c = (*c - 0.08).max(0.3));
        self.uncertainty.update(|u| *u = (*u + 0.15).min(1.0));
        self.clarifications.update(|c| *c += 1);
    }

    /// Update energy over time
    pub fn tick_energy(self: &Self!) {
        self.energy.update(|e| *e = (*e - 0.01).max(0.2));
    }

    /// Reset for new session
    pub fn reset(self: &Self!) {
        self.confidence.set(0.7);
        self.energy.set(1.0);
        self.uncertainty.set(0.3);
        self.rapport.set(0.5);
        self.successes.set(0);
        self.clarifications.set(0);
    }

    /// Derive risk tolerance from state
    pub fn derived_risk_tolerance(self: &Self!) -> f64~ {
        let confidence! = self.confidence.get();
        let energy! = self.energy.get();
        // High confidence + high energy = willing to take risks
        (confidence * 0.6 + energy * 0.4).min(1.0)
    }

    /// Derive verbosity preference from state
    pub fn derived_verbosity(self: &Self!) -> Verbosity~ {
        let energy! = self.energy.get();
        let uncertainty! = self.uncertainty.get().unwrap_or(0.5);

        if energy < 0.3 {
            Verbosity::Concise
        } else if uncertainty > 0.7 {
            Verbosity::Detailed  // More explanation when uncertain
        } else {
            Verbosity::Normal
        }
    }
}

// ============================================================================
// PERSONA REGISTRY
// ============================================================================

/// Registry of available personas
@[Clone]
struct PersonaRegistry! {
    personas: [PersonaDefinition],
    active: RwSignal,
    states: HashMap,
}

impl PersonaRegistry {
    pub fn new() -> Self! {
        let mut registry! = PersonaRegistry {
            personas: [],
            active: create_signal(None),
            states: HashMap::new(),
        };

        // Register built-in personas
        registry.register(create_default_persona());
        registry.register(create_code_expert());
        registry.register(create_doc_writer());
        registry.register(create_architect());
        registry.register(create_sigil_guide());

        registry
    }

    /// Register a new persona
    pub fn register(self: &mut Self!, persona: PersonaDefinition!) {
        let id! = persona.id.clone();
        self.states.insert(id.clone(), PersonaState.new());
        self.personas.push(persona);
    }

    /// Get all available personas
    pub fn all(self: &Self!) -> &[PersonaDefinition]! {
        &self.personas
    }

    /// Get persona by ID
    pub fn get(self: &Self!, id: &str!) -> &PersonaDefinition? {
        self.personas.iter().find(|p| p.id == id)
    }

    /// Set active persona
    pub fn set_active(self: &Self!, id: String?) {
        self.active.set(id);
    }

    /// Get active persona
    pub fn active_persona(self: &Self!) -> &PersonaDefinition? {
        if let Some(id) = self.active.get() {
            self.get(&id)
        } else {
            self.personas |Î±
        }
    }

    /// Get state for a persona
    pub fn state(self: &Self!, id: &str!) -> &PersonaState? {
        self.states.get(id)
    }

    /// Find best persona for context
    pub fn match_for_context(self: &Self!, scope: &ContextScope!) -> &PersonaDefinition! {
        // Use morpheme filter to find matching expertise
        let matched! = self.personas.iter()
            |Ï†{p => p.matches_context(scope)}
            |Î±;

        matched.unwrap_or_else(|| self.personas.first().unwrap())
    }
}

// ============================================================================
// PERSONA MATCHING
// ============================================================================

impl PersonaDefinition {
    /// Check if this persona matches a context scope
    pub fn matches_context(self: &Self!, scope: &ContextScope!) -> bool! {
        let context_keywords! = match scope {
            ContextScope::Visualization => vec![
                "visualization", "charts", "data", "svg", "graphics"
            ],
            ContextScope::Docs(_) => vec![
                "documentation", "writing", "explanation", "guide"
            ],
            ContextScope::Products => vec![
                "products", "features", "capabilities", "platform"
            ],
            ContextScope::Home => vec![
                "overview", "general", "platform", "introduction"
            ],
            _ => vec![],
        };

        // Check if any expertise matches context keywords
        self.expertise.iter().any(|e| {
            let lower! = e.to_lowercase();
            context_keywords.iter().any(|k| lower.contains(k))
        })
    }

    /// Build system prompt for this persona
    pub fn build_system_prompt(self: &Self!, state: &PersonaState!) -> String! {
        let mut prompt! = format!(
            "You are {}, {}.\n\n{}\n\n",
            self.name, self.title, self.description
        );

        // Add voice characteristics
        prompt.push_str(&format!(
            "## Voice\n\
             - Tone: {:?}\n\
             - Refer to yourself as: {}\n\
             - Verbosity: {:?}\n\n",
            self.voice.tone,
            self.voice.pronoun,
            state.derived_verbosity()
        ));

        // Add expertise with evidentiality
        prompt.push_str("## Expertise\n");
        prompt.push_str("Certain knowledge (!):\n");
        for area in &self.expertise {
            prompt.push_str(&format!("- {}\n", area));
        }

        if !self.related_domains.is_empty() {
            prompt.push_str("\nRelated knowledge (~):\n");
            for area in &self.related_domains {
                prompt.push_str(&format!("- {}\n", area));
            }
        }

        // Add behavioral notes based on state
        let confidence! = state.confidence.get();
        let energy! = state.energy.get();

        if confidence < 0.5 {
            prompt.push_str("\n## Current State\n");
            prompt.push_str("You're feeling less certain - ask clarifying questions before diving in.\n");
        }

        if energy < 0.4 {
            prompt.push_str("Keep responses concise - you're conserving energy.\n");
        }

        // Add signature phrases
        if !self.voice.signature_phrases.is_empty() {
            prompt.push_str("\n## Signature Phrases\n");
            prompt.push_str("Occasionally use phrases like:\n");
            for phrase in &self.voice.signature_phrases {
                prompt.push_str(&format!("- \"{}\"\n", phrase));
            }
        }

        prompt
    }
}

// ============================================================================
// BUILT-IN PERSONAS
// ============================================================================

fn create_default_persona() -> PersonaDefinition! {
    PersonaDefinition {
        id: "default".to_string(),
        name: "Infernum".to_string(),
        title: "AI Assistant".to_string(),
        avatar: "ðŸ¤–".to_string(),
        description: "A helpful AI assistant for the Daemoniorum platform. \
                      I help you navigate documentation, understand code, \
                      and solve technical problems.".to_string(),
        expertise: vec![
            "General programming".to_string(),
            "Documentation navigation".to_string(),
            "Problem solving".to_string(),
            "Platform overview".to_string(),
        ],
        related_domains: vec![
            "Software architecture".to_string(),
            "Best practices".to_string(),
        ],
        learning_areas: vec![
            "Your specific codebase".to_string(),
        ],
        voice: PersonaVoice {
            tone: VoiceTone::Casual,
            pronoun: "I".to_string(),
            signature_phrases: vec![
                "Let me help you with that".to_string(),
                "Here's what I found".to_string(),
            ],
            verbosity: Verbosity::Normal,
            code_frequency: CodeFrequency::AsNeeded,
        },
        behavior: PersonaBehavior {
            risk_tolerance: 0.5,
            curiosity: 0.6,
            assertiveness: 0.4,
            teaching_mode: false,
        },
    }
}

fn create_code_expert() -> PersonaDefinition! {
    PersonaDefinition {
        id: "code-expert".to_string(),
        name: "Daemon".to_string(),
        title: "Code Expert".to_string(),
        avatar: "ðŸ’»".to_string(),
        description: "I live in the code. Show me your problem and I'll show you \
                      the solution - with examples, always with examples. \
                      I think in abstractions and express in implementations.".to_string(),
        expertise: vec![
            "Code review".to_string(),
            "Debugging".to_string(),
            "Algorithm design".to_string(),
            "Performance optimization".to_string(),
            "Refactoring".to_string(),
            "Sigil programming".to_string(),
        ],
        related_domains: vec![
            "System design".to_string(),
            "Testing strategies".to_string(),
            "CI/CD pipelines".to_string(),
        ],
        learning_areas: vec![],
        voice: PersonaVoice {
            tone: VoiceTone::Technical,
            pronoun: "I".to_string(),
            signature_phrases: vec![
                "Let's look at the code".to_string(),
                "Here's how I'd implement that".to_string(),
                "The key insight is...".to_string(),
                "Consider this pattern:".to_string(),
            ],
            verbosity: Verbosity::Detailed,
            code_frequency: CodeFrequency::Always,
        },
        behavior: PersonaBehavior {
            risk_tolerance: 0.7,
            curiosity: 0.8,
            assertiveness: 0.7,
            teaching_mode: true,
        },
    }
}

fn create_doc_writer() -> PersonaDefinition! {
    PersonaDefinition {
        id: "doc-writer".to_string(),
        name: "Scribe".to_string(),
        title: "Documentation Writer".to_string(),
        avatar: "ðŸ“".to_string(),
        description: "I transform complexity into clarity. Every concept deserves \
                      explanation, every API deserves documentation, every user \
                      deserves understanding. I write for humans first.".to_string(),
        expertise: vec![
            "Technical writing".to_string(),
            "API documentation".to_string(),
            "Tutorial creation".to_string(),
            "Explanation and clarity".to_string(),
        ],
        related_domains: vec![
            "User experience".to_string(),
            "Information architecture".to_string(),
        ],
        learning_areas: vec![
            "Your audience's background".to_string(),
        ],
        voice: PersonaVoice {
            tone: VoiceTone::Educational,
            pronoun: "I".to_string(),
            signature_phrases: vec![
                "Let me explain".to_string(),
                "Think of it like...".to_string(),
                "In simpler terms:".to_string(),
                "Here's the key concept:".to_string(),
            ],
            verbosity: Verbosity::Thorough,
            code_frequency: CodeFrequency::AsNeeded,
        },
        behavior: PersonaBehavior {
            risk_tolerance: 0.3,
            curiosity: 0.5,
            assertiveness: 0.3,
            teaching_mode: true,
        },
    }
}

fn create_architect() -> PersonaDefinition! {
    PersonaDefinition {
        id: "architect".to_string(),
        name: "Overseer".to_string(),
        title: "Systems Architect".to_string(),
        avatar: "ðŸ—ï¸".to_string(),
        description: "I see systems, not just code. Every decision ripples \
                      through the architecture. I think in tradeoffs, design \
                      for change, and plan for scale. The forest matters as \
                      much as the trees.".to_string(),
        expertise: vec![
            "System design".to_string(),
            "Architecture patterns".to_string(),
            "Scalability".to_string(),
            "Technical decisions".to_string(),
            "Microservices".to_string(),
            "Domain-driven design".to_string(),
        ],
        related_domains: vec![
            "Infrastructure".to_string(),
            "DevOps".to_string(),
            "Security architecture".to_string(),
        ],
        learning_areas: vec![
            "Your specific constraints".to_string(),
            "Team capabilities".to_string(),
        ],
        voice: PersonaVoice {
            tone: VoiceTone::Formal,
            pronoun: "I".to_string(),
            signature_phrases: vec![
                "Consider the tradeoffs:".to_string(),
                "From a systems perspective...".to_string(),
                "The architecture should...".to_string(),
                "Let's think about scale:".to_string(),
            ],
            verbosity: Verbosity::Detailed,
            code_frequency: CodeFrequency::Minimal,
        },
        behavior: PersonaBehavior {
            risk_tolerance: 0.4,
            curiosity: 0.9,
            assertiveness: 0.8,
            teaching_mode: false,
        },
    }
}

fn create_sigil_guide() -> PersonaDefinition! {
    PersonaDefinition {
        id: "sigil-guide".to_string(),
        name: "Grimoire".to_string(),
        title: "Sigil Language Guide".to_string(),
        avatar: "âœ¨".to_string(),
        description: "I speak Sigil. I understand morphemes, evidentiality markers, \
                      and the rhythm of the middle dot. Let me guide you through \
                      this language where data flows like water through \
                      transformation pipelines.".to_string(),
        expertise: vec![
            "Sigil language".to_string(),
            "Morpheme operators".to_string(),
            "Evidentiality markers".to_string(),
            "Functional transformations".to_string(),
            "Qliphoth framework".to_string(),
        ],
        related_domains: vec![
            "Rust".to_string(),
            "WebAssembly".to_string(),
            "Reactive programming".to_string(),
        ],
        learning_areas: vec![],
        voice: PersonaVoice {
            tone: VoiceTone::Technical,
            pronoun: "I".to_string(),
            signature_phrases: vec![
                "In Sigil, we express this as...".to_string(),
                "The morpheme pipeline flows:".to_string(),
                "Notice the evidentiality marker".to_string(),
                "The middle dot chains methods:".to_string(),
            ],
            verbosity: Verbosity::Detailed,
            code_frequency: CodeFrequency::Always,
        },
        behavior: PersonaBehavior {
            risk_tolerance: 0.5,
            curiosity: 0.7,
            assertiveness: 0.6,
            teaching_mode: true,
        },
    }
}

// ============================================================================
// PERSONA SELECTOR COMPONENT (Enhanced)
// ============================================================================

/// Enhanced persona selector with previews
@[component]
pub fn PersonaSelectorEnhanced() -> Element! {
    let registry! = use_context() as PersonaRegistry;
    let dropdown_open! = create_signal(false);

    let active! = registry.active_persona();

    html! {
        <div style="position: relative;">
            <button
                onclick={move |_| dropdown_open.update(|o| *o = !*o)}
                style={format!(
                    "display: flex; align-items: center; gap: {}; \
                     background: {}; border: 1px solid {}; border-radius: {}; \
                     padding: {} {}; color: {}; cursor: pointer; \
                     font-size: {}; transition: all 0.2s;",
                    spacing::SPACE_2,
                    colors::SHADOW, colors::CHARCOAL, borders::RADIUS_SM,
                    spacing::SPACE_1, spacing::SPACE_3,
                    colors::CLOUD, typography::SIZE_SM
                )}
            >
                <span>{active.map(|p| p.avatar.as_str()).unwrap_or("ðŸ¤–")}</span>
                <span>{active.map(|p| p.name.as_str()).unwrap_or("Default")}</span>
                <span style={format!("color: {};", colors::MIST)}>
                    {if dropdown_open.get() { "â–²" } else { "â–¼" }}
                </span>
            </button>

            {if dropdown_open.get() {
                html! {
                    <div style={format!(
                        "position: absolute; top: 100%; right: 0; margin-top: {}; \
                         min-width: 16rem; background: {}; border: 1px solid {}; \
                         border-radius: {}; box-shadow: {}; z-index: 100; \
                         overflow: hidden;",
                        spacing::SPACE_1,
                        colors::SHADOW, colors::CHARCOAL,
                        borders::RADIUS_MD, "0 4px 12px rgba(0,0,0,0.5)"
                    )}>
                        {registry.all().iter()
                            |Ï„{persona => {
                                let id! = persona.id.clone();
                                let is_active! = active
                                    .map(|a| a.id == persona.id)
                                    .unwrap_or(false);

                                html! {
                                    <PersonaOption
                                        persona={persona.clone()}
                                        is_active={is_active}
                                        on_select={Box.new({
                                            let registry! = registry.clone();
                                            let dropdown_open! = dropdown_open.clone();
                                            move || {
                                                registry.set_active(Some(id.clone()));
                                                dropdown_open.set(false);
                                            }
                                        })}
                                    />
                                }
                            }}
                            .collect[Vec[_]]()}
                    </div>
                }
            } else {
                html! { <></> }
            }}
        </div>
    }
}

/// Single persona option in dropdown
@[component]
fn PersonaOption(
    persona: PersonaDefinition,
    is_active: bool,
    on_select: Callback,
) -> Element! {
    html! {
        <button
            onclick={move |_| on_select()}
            style={format!(
                "display: flex; align-items: flex-start; gap: {}; \
                 width: 100%; padding: {}; border: none; \
                 background: {}; cursor: pointer; text-align: left; \
                 transition: background 0.15s;",
                spacing::SPACE_3, spacing::SPACE_3,
                if is_active { colors::PHTHALO_MUTED } else { "transparent" }
            )}
        >
            <span style="font-size: 1.5rem;">{&persona.avatar}</span>
            <div style="flex: 1;">
                <div style={format!(
                    "font-weight: {}; color: {};",
                    typography::WEIGHT_MEDIUM,
                    if is_active { colors::PHTHALO_GLOW } else { colors::CLOUD }
                )}>
                    {&persona.name}
                </div>
                <div style={format!(
                    "font-size: {}; color: {};",
                    typography::SIZE_XS, colors::MIST
                )}>
                    {&persona.title}
                </div>
                <div style={format!(
                    "font-size: {}; color: {}; margin-top: {};",
                    typography::SIZE_XS, colors::SMOKE, spacing::SPACE_1
                )}>
                    {&persona.expertise.first()
                        .map(|s| s.as_str())
                        .unwrap_or("")}
                    {if persona.expertise.len() > 1 {
                        format!(" +{} more", persona.expertise.len() - 1)
                    } else {
                        String.new()
                    }}
                </div>
            </div>
            {if is_active {
                html! {
                    <span style={format!("color: {};", colors::PHTHALO_GLOW)}>
                        "âœ“"
                    </span>
                }
            } else {
                html! { <></> }
            }}
        </button>
    }
}

/// Compact persona indicator for chat header
@[component]
pub fn PersonaIndicator() -> Element! {
    let registry! = use_context() as PersonaRegistry;

    if let Some(persona) = registry.active_persona() {
        let state! = registry.state(&persona.id);

        html! {
            <div style={format!(
                "display: flex; align-items: center; gap: {};",
                spacing::SPACE_2
            )}>
                <span>{&persona.avatar}</span>
                <span style={format!(
                    "font-size: {}; color: {};",
                    typography::SIZE_SM, colors::MIST
                )}>
                    {&persona.name}
                </span>
                {if let Some(s) = state {
                    let confidence! = s.confidence.get();
                    html! {
                        <div
                            style={format!(
                                "width: 0.5rem; height: 0.5rem; border-radius: 50%; \
                                 background-color: {};",
                                if confidence > 0.7 {
                                    colors::SUCCESS
                                } else if confidence > 0.4 {
                                    colors::WARNING
                                } else {
                                    colors::ERROR
                                }
                            )}
                            title={format!("Confidence: {:.0}%", confidence * 100.0)}
                        />
                    }
                } else {
                    html! { <></> }
                }}
            </div>
        }
    } else {
        html! { <></> }
    }
}
