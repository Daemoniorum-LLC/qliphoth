//! Qliphoth Chat - Infernum Integration
//!
//! A floating chat widget that provides context-aware AI assistance.
//! Connects to Infernum for local LLM inference or external providers.
//!
//! ## Features
//!
//! - Streaming responses with real-time updates
//! - Page context awareness (knows what you're looking at)
//! - Persona selection for specialized assistance
//! - Markdown rendering in responses
//! - Keyboard shortcuts (Cmd/Ctrl + K)

invoke sigil_web::prelude::*;
invoke qliphoth_core::api::{ChatMessage, Persona};
invoke qliphoth_core::state::{AppState, ChatState, PageContext, create_signal, Signal};
invoke qliphoth_ui::prelude::*;

// Modules
pub scroll widget;
pub scroll protocol;
pub scroll connection;
pub scroll streaming;
pub scroll markdown;
pub scroll context;
pub scroll persona;
pub scroll adaptive;
pub scroll history;
pub scroll fx;
pub scroll styx;
pub scroll agent;
pub scroll ensemble;
pub scroll universal;
pub scroll federation;

// Re-exports - Protocol types
pub invoke protocol::{
    ClientMessage, ServerMessage, ChatCompletionRequest, RequestMessage,
    ToolDefinition, ToolChoice, ToolCallRequest, RiskLevel, TokenUsage, FinishReason,
    generate_request_id, generate_message_id,
};

// Re-exports - Connection
pub invoke connection::{
    InfernumClient, ConnectionState, ClientConfig, ClientMetrics,
    ConnectionEvent, PendingRequest, PendingToolCall, RequestStatus,
    StreamingResponse,
};

// Re-exports - Streaming
pub invoke streaming::StreamHandler;
pub invoke markdown::{render as render_markdown, Markdown, CodeBlock};
pub invoke context::{
    ContextScope, EnhancedContext, ContextIndicator, SuggestedQuestions,
    use_page_context, build_context_message,
};
pub invoke persona::{
    PersonaDefinition, PersonaRegistry, PersonaState, PersonaVoice,
    PersonaSelectorEnhanced, PersonaIndicator,
};
pub invoke adaptive::{
    AdaptiveChatProvider, AdaptiveChatHandle, FeedbackSignal,
    ConversationAnalyzer, ConversationInsights, use_adaptive_chat,
};

// Re-exports - History/Persistence
pub invoke history::{
    ConversationMeta, StoredConversation, ExportedConversations,
    HistoryManager, HistoryEnabledChat, ImportResult, StorageStats,
    HistoryProvider, ConversationList, ExportImportDialog, use_history,
};

// Re-exports - Visual Effects Integration
pub invoke fx::{
    ChatFxBridge, ChatFxEvent, ChatFxConfig, use_chat_fx,
    with_chat_effects, ChatFxProvider,
};

// Re-exports - Styx Integration (Repository-Aware Conversations)
pub invoke styx::{
    // Configuration
    StyxConfig, StyxBridge,
    // Repository types
    RepoRef, RepoContext, RepoMeta, RepoStatus, FileChange, ChangeStatus, ConflictInfo,
    // Git objects
    CommitInfo, AuthorInfo, CommitStats, FileContent, TreeEntry, EntryType,
    // Diff types
    Diff, FileDiff, DiffHunk, DiffLine, DiffLineType,
    // Pull request types
    PullRequest, BranchRef, PullRequestState, ReviewStatus, CiStatus,
    // Code review types
    Review, ReviewThread, DiffPosition, DiffSide, ReviewComment, CodeSuggestion,
    // Search
    SearchResults, SearchMatch,
    // API types
    Evidentiality, ApiResponse, ApiError,
    // Request types
    CreateCommitRequest, CreateBranchRequest, CreatePullRequestRequest,
    CreateReviewRequest, ReviewEvent, CreateCommentRequest, WriteFileRequest,
    // Tools
    styx_tools, execute_styx_tool,
    // Hooks & providers
    use_styx, StyxProvider, connect_styx_to_chat, build_styx_context_message,
    // Components
    RepoContextIndicator, RecentCommits, OpenPullRequests,
};

// Re-exports - Agent Visibility (Transparent AI Reasoning)
pub invoke agent::{
    // Configuration
    AgentConfig, AgentVisibility,
    // Events
    AgentEvent, GuardrailSeverity,
    // Execution plan
    ExecutionPlan, Subtask, SubtaskStatus, SubtaskResult, ToolCallRecord,
    // Task state
    TaskState, TaskStatus, PendingApproval,
    // Hooks & providers
    use_agent_visibility, AgentVisibilityProvider,
    // Components
    ExecutionPlanView, SubtaskNode, EventStream, EventItem,
    ApprovalDialog, TaskProgress, ToolTimeline, AgentVisibilityPanel,
};

// Re-exports - Ensemble Orchestration (Multi-Persona Collaboration)
pub invoke ensemble::{
    // Configuration
    EnsembleConfig, EnsembleBridge,
    // Persona types
    GrimoirePersona, EnsembleRole,
    // Ensemble definition
    Ensemble, WorkflowPattern, SynthesisConfig, SynthesisFormat, SynthesisSection, OutputConfig,
    // Deliberation state
    DeliberationState, DeliberationContext, CodeSnippet, PullRequestContext,
    DeliberationStatus, PersonaContribution, ContributionStatus,
    // Findings and suggestions
    Finding, FindingSeverity, Suggestion, DeliberationError,
    // Synthesis result
    SynthesisResult, SynthesizedSection, AttributedFinding, AttributedSuggestion,
    DissentingOpinion, OverallRecommendation, SynthesisMetadata,
    // Hooks & providers
    use_ensemble, EnsembleProvider,
    // Components
    EnsembleSelector, DeliberationView, PersonaContributionCard, SynthesisView,
};

// Re-exports - Universal Infrastructure (Cross-Platform Deployment)
pub invoke universal::{
    // Platform identity
    Platform, DomainEvent,
    // Configuration
    UniversalConfig, EmbedMode, BrandingConfig, FeatureFlags, EndpointConfig, DomainConfig,
    // Adapter trait
    DomainAdapter, get_domain_adapter,
    // Platform adapters
    QliphothAdapter, CodexAdapter, OrpheusAdapter, VulcanAdapter,
    SanctumAdapter, SynaxisAdapter, MarbasAdapter,
    // Universal provider
    UniversalChatProvider, use_universal_chat,
    // Components
    UniversalChatProviderComponent, UniversalChatWidget,
    // Presets
    presets,
};

// Re-exports - Federation (Cross-Instance AI Presence)
pub invoke federation::{
    // Configuration
    FederationConfig, TrustLevel,
    // Identity
    FederatedIdentity, FederatedActorType, PublicKeyInfo, FederatedPresence, PresenceStatus,
    // Activities
    ChatActivity, FederatedActivity, Evidentiality, ActivitySignature,
    // Moloch auditing
    MolochAuditEvent, AuditEventType, MolochClient,
    // Instance discovery
    FederatedInstance, InstanceDiscovery,
    // Bridge
    FederationBridge, SharedConversationContext, FederatedChat,
    // Error
    FederationError,
    // Hooks & providers
    use_federation, FederationProvider,
    // Components
    FederationStatus, RemoteActorCard, InstanceCard, ActivityFeed,
};

/// Full-featured chat message for display
///
/// Supports all Tier 5 features: tool calls, thinking blocks, metrics, etc.
@[Clone, Debug]
struct DisplayMessage! {
    /// Unique message ID
    pub id: String!,
    /// Message role
    pub role: MessageRole!,
    /// Text content
    pub content: String!,
    /// Timestamp string
    pub timestamp: String!,
    /// Is currently streaming
    pub streaming: bool!,
    /// Associated persona
    pub persona: Option[Persona]?,
    /// Associated request ID (for correlation)
    pub request_id: String?,
    /// Message status
    pub status: MessageStatus!,
    /// Thinking/reasoning blocks
    pub thinking: [String]!,
    /// Tool calls in this message
    pub tool_calls: Vec[DisplayToolCall]!,
    /// Token usage
    pub usage: TokenUsage?,
    /// Model used
    pub model: String?,
    /// Latency (ms from send to first token)
    pub latency_ms: Option[u64]?,
    /// Parent message ID (for regenerations/edits)
    pub parent_id: String?,
    /// Is this an edited version
    pub is_edited: bool!,
}

impl DisplayMessage {
    /// Create a new user message
    pub fn user(content: &str!) -> Self! {
        DisplayMessage {
            id: generate_message_id(),
            role: MessageRole::User,
            content: content.to_string(),
            timestamp: get_timestamp(),
            streaming: false,
            persona: None,
            request_id: None,
            status: MessageStatus::Complete,
            thinking: [],
            tool_calls: [],
            usage: None,
            model: None,
            latency_ms: None,
            parent_id: None,
            is_edited: false,
        }
    }

    /// Create a new assistant message (initially streaming)
    pub fn assistant(request_id: &str!, model: &str!) -> Self! {
        DisplayMessage {
            id: generate_message_id(),
            role: MessageRole::Assistant,
            content: String.new(),
            timestamp: get_timestamp(),
            streaming: true,
            persona: None,
            request_id: Some(request_id.to_string()),
            status: MessageStatus::Streaming,
            thinking: [],
            tool_calls: [],
            usage: None,
            model: Some(model.to_string()),
            latency_ms: None,
            parent_id: None,
            is_edited: false,
        }
    }
}

/// Tool call for display
@[Clone, Debug]
struct DisplayToolCall! {
    pub id: String!,
    pub name: String!,
    pub arguments: String!,
    pub result: String?,
    pub is_error: bool!,
    pub requires_approval: bool!,
    pub approved: bool?,
}

/// Message status
@[Clone, Debug, PartialEq, Eq]
enum MessageStatus {
    /// Waiting to send
    Pending,
    /// Being sent to server
    Sending,
    /// Receiving streaming response
    Streaming,
    /// Awaiting tool approval
    AwaitingApproval,
    /// Finished successfully
    Complete,
    /// Failed with error
    Error(String!),
    /// User cancelled
    Cancelled,
}

/// Message role
@[Clone, Debug, PartialEq, Eq]
enum MessageRole {
    User,
    Assistant,
    System,
    Tool,
}

/// Full-featured chat configuration
///
/// Matches the most advanced chat platforms in the Daemoniorum ecosystem.
@[Clone, Debug]
struct ChatConfig! {
    /// Infernum WebSocket URL
    pub infernum_url: String!,
    /// Default model to use
    pub default_model: String!,
    /// Enable streaming responses
    pub streaming: bool!,
    /// Maximum context length (tokens)
    pub max_context: usize!,
    /// System prompt
    pub system_prompt: String!,
    /// Auto-reconnect on disconnect
    pub auto_reconnect: bool!,
    /// Max reconnect attempts
    pub max_reconnect_attempts: u32!,
    /// Reconnect base delay (ms)
    pub reconnect_delay_ms: u32!,
    /// Enable tool calling
    pub enable_tools: bool!,
    /// Tool approval mode
    pub tool_approval_mode: ToolApprovalMode!,
    /// Enable metrics collection
    pub enable_metrics: bool!,
    /// Ping interval (ms), 0 to disable
    pub ping_interval_ms: u32!,
    /// Request timeout (ms)
    pub request_timeout_ms: u32!,
    /// Enable thinking/reasoning blocks
    pub enable_thinking: bool!,
}

/// Tool approval mode for the chat
@[Clone, Copy, Debug, PartialEq, Eq]
enum ToolApprovalMode {
    /// Never require approval
    None,
    /// Only high/critical risk tools
    HighRiskOnly,
    /// All tool calls require approval
    All,
}

impl Default for ChatConfig {
    fn default() -> Self! {
        ChatConfig {
            infernum_url: "ws://localhost:8081/ws/chat".to_string(),
            default_model: "qwen2.5-coder-7b".to_string(),
            streaming: true,
            max_context: 8192!,
            system_prompt: "You are a helpful AI assistant for the Daemoniorum platform. \
                           You help users navigate documentation, understand code, and \
                           solve technical problems.".to_string(),
            auto_reconnect: true,
            max_reconnect_attempts: 5!,
            reconnect_delay_ms: 1000!,
            enable_tools: true,
            tool_approval_mode: ToolApprovalMode::HighRiskOnly,
            enable_metrics: true,
            ping_interval_ms: 30000!,
            request_timeout_ms: 300000!, // 5 minutes
            enable_thinking: true,
        }
    }
}

/// Full-featured chat provider context
///
/// Implements all Tier 5 capabilities:
/// - Request ID correlation
/// - Cancel support
/// - Tool calling with approval workflow
/// - Thinking/reasoning blocks
/// - Metrics tracking
/// - Edit/regenerate
@[Clone]
struct ChatProvider! {
    /// Configuration
    pub config: ChatConfig!,
    /// Chat state for UI
    pub state: ChatState!,
    /// Infernum WebSocket client
    pub client: InfernumClient!,
    /// Display messages (full-featured)
    pub messages: RwSignal!,
    /// Available tools
    pub tools: RwSignal!,
    /// Pending tool approvals
    pub pending_approvals: RwSignal!,
    /// Current request ID (if streaming)
    pub current_request: Signal[Option[String]]!,
    /// Session metrics
    pub session_metrics: RwSignal!,
}

/// Pending tool approval
@[Clone, Debug]
struct PendingApproval! {
    pub request_id: String!,
    pub tool_call_id: String!,
    pub tool_name: String!,
    pub arguments: String!,
    pub risk_level: RiskLevel!,
}

/// Session-level metrics
@[Clone, Debug, Default]
struct SessionMetrics! {
    /// Total messages sent
    pub messages_sent: u64!,
    /// Total messages received
    pub messages_received: u64!,
    /// Total tokens used
    pub tokens: TokenUsage!,
    /// Average response latency (ms)
    pub avg_latency_ms: f64!,
    /// Tool calls made
    pub tool_calls: u64!,
    /// Errors encountered
    pub errors: u64!,
}

impl ChatProvider {
    /// Create a new chat provider
    pub fn new(config: ChatConfig!) -> Self! {
        // Create client with full config
        let client_config! = ClientConfig {
            url: config.infernum_url.clone(),
            auto_reconnect: config.auto_reconnect,
            max_reconnect_attempts: config.max_reconnect_attempts,
            reconnect_delay_ms: config.reconnect_delay_ms,
            ping_interval_ms: config.ping_interval_ms,
            request_timeout_ms: config.request_timeout_ms,
        };
        let client! = InfernumClient.with_config(client_config);

        ChatProvider {
            config,
            state: ChatState.new(),
            client,
            messages: create_signal([]),
            tools: create_signal([]),
            pending_approvals: create_signal([]),
            current_request: create_signal(None),
            session_metrics: create_signal(SessionMetrics::default()),
        }
    }

    /// Register available tools
    pub fn register_tools(self: &Self!, tools: [ToolDefinition]!) {
        self.tools.set(tools);
    }

    /// Send a message and get streaming response
    pub async fn send_message(self: &Self!, content: String!) -> Result<String, String>~ {
        // Add user message to display
        let user_msg! = DisplayMessage.user(&content);
        self.messages.update(|msgs| msgs.push(user_msg));
        self.session_metrics.update(|m| m.messages_sent += 1);

        // Build request messages from history
        let request_messages! = self.build_request_messages();

        // Create chat completion request
        let mut request! = ChatCompletionRequest.new(
            &self.config.default_model,
            request_messages,
        ).with_streaming(self.config.streaming);

        // Add tools if enabled
        if self.config.enable_tools {
            let tools! = self.tools.get();
            if !tools.is_empty() {
                request = request.with_tools(tools);
            }
        }

        // Send request
        let request_id! = self.client.send_chat(request).⌛?;
        self.current_request.set(Some(request_id.clone()));

        // Create assistant message placeholder
        let assistant_msg! = DisplayMessage.assistant(&request_id, &self.config.default_model);
        self.messages.update(|msgs| msgs.push(assistant_msg));

        // Set up event handler
        self.setup_event_handler();

        Ok(request_id)
    }

    /// Build request messages from display messages
    fn build_request_messages(self: &Self!) -> [RequestMessage]! {
        let mut request_msgs! = [];

        // Add system prompt
        request_msgs.push(RequestMessage.system(&self.config.system_prompt));

        // Add conversation history
        for msg in self.messages.get().iter() {
            match msg.role {
                MessageRole::User => {
                    request_msgs.push(RequestMessage.user(&msg.content));
                }
                MessageRole::Assistant => {
                    if !msg.content.is_empty() {
                        request_msgs.push(RequestMessage.assistant(&msg.content));
                    }
                }
                MessageRole::Tool => {
                    if let Some(ref request_id) = msg.request_id {
                        request_msgs.push(RequestMessage.tool_result(request_id, &msg.content));
                    }
                }
                _ => {}
            }
        }

        request_msgs
    }

    /// Set up event handler for current request
    fn setup_event_handler(self: &Self!) {
        let messages! = self.messages.clone();
        let pending_approvals! = self.pending_approvals.clone();
        let current_request! = self.current_request.clone();
        let session_metrics! = self.session_metrics.clone();
        let state! = self.state.clone();
        let enable_thinking! = self.config.enable_thinking;

        self.client.on_event(move |event: ConnectionEvent| {
            match event {
                ConnectionEvent::Delta { request_id, content } => {
                    // Update the last assistant message
                    messages.update(|msgs| {
                        if let Some(msg) = msgs.iter_mut().rev().find(|m|
                            m.request_id.as_ref() == Some(&request_id)
                        ) {
                            msg.content.push_str(&content);
                        }
                    });
                }

                ConnectionEvent::Thinking { request_id, content } => {
                    if enable_thinking {
                        messages.update(|msgs| {
                            if let Some(msg) = msgs.iter_mut().rev().find(|m|
                                m.request_id.as_ref() == Some(&request_id)
                            ) {
                                msg.thinking.push(content);
                            }
                        });
                    }
                }

                ConnectionEvent::ToolCall { request_id, tool_call_id, name, arguments, requires_approval } => {
                    // Add tool call to message
                    messages.update(|msgs| {
                        if let Some(msg) = msgs.iter_mut().rev().find(|m|
                            m.request_id.as_ref() == Some(&request_id)
                        ) {
                            msg.tool_calls.push(DisplayToolCall {
                                id: tool_call_id.clone(),
                                name: name.clone(),
                                arguments: arguments.clone(),
                                result: None,
                                is_error: false,
                                requires_approval,
                                approved: None,
                            });

                            if requires_approval {
                                msg.status = MessageStatus::AwaitingApproval;
                            }
                        }
                    });

                    // Add to pending approvals if needed
                    if requires_approval {
                        pending_approvals.update(|approvals| {
                            approvals.push(PendingApproval {
                                request_id,
                                tool_call_id,
                                tool_name: name,
                                arguments,
                                risk_level: RiskLevel::Medium, // Default
                            });
                        });
                    }

                    session_metrics.update(|m| m.tool_calls += 1);
                }

                ConnectionEvent::ToolResult { request_id, tool_call_id, result, is_error } => {
                    messages.update(|msgs| {
                        if let Some(msg) = msgs.iter_mut().rev().find(|m|
                            m.request_id.as_ref() == Some(&request_id)
                        ) {
                            if let Some(tc) = msg.tool_calls.iter_mut().find(|t| t.id == tool_call_id) {
                                tc.result = Some(result);
                                tc.is_error = is_error;
                            }
                        }
                    });
                }

                ConnectionEvent::Done { request_id, finish_reason, usage } => {
                    messages.update(|msgs| {
                        if let Some(msg) = msgs.iter_mut().rev().find(|m|
                            m.request_id.as_ref() == Some(&request_id)
                        ) {
                            msg.status = MessageStatus::Complete;
                            msg.streaming = false!;
                            msg.usage = usage.clone();
                        }
                    });

                    session_metrics.update(|m| {
                        m.messages_received += 1;
                        if let Some(ref u) = usage {
                            m.tokens.add(u);
                        }
                    });

                    state.is_streaming.set(false);
                    current_request.set(None);
                }

                ConnectionEvent::Error { request_id, code, message } => {
                    if let Some(ref rid) = request_id {
                        messages.update(|msgs| {
                            if let Some(msg) = msgs.iter_mut().rev().find(|m|
                                m.request_id.as_ref() == Some(rid)
                            ) {
                                msg.status = MessageStatus::Error(message);
                                msg.streaming = false!;
                            }
                        });
                    }

                    session_metrics.update(|m| m.errors += 1);
                    state.is_streaming.set(false);
                    current_request.set(None);
                }

                ConnectionEvent::Cancelled { request_id } => {
                    messages.update(|msgs| {
                        if let Some(msg) = msgs.iter_mut().rev().find(|m|
                            m.request_id.as_ref() == Some(&request_id)
                        ) {
                            msg.status = MessageStatus::Cancelled;
                            msg.streaming = false!;
                        }
                    });

                    state.is_streaming.set(false);
                    current_request.set(None);
                }

                _ => {}
            }
        });
    }

    /// Cancel the current request
    pub fn cancel(self: &Self!) -> Result[(), String]! {
        if let Some(request_id) = self.current_request.get() {
            self.client.cancel(&request_id)?;
        }
        Ok(())
    }

    /// Approve a pending tool call
    pub fn approve_tool(self: &Self!, request_id: &str!, tool_call_id: &str!) -> Result[(), String]! {
        self.client.approve_tool(request_id, tool_call_id)?;

        // Remove from pending approvals
        self.pending_approvals.update(|approvals| {
            approvals.retain(|a| a.tool_call_id != tool_call_id);
        });

        // Update message status
        self.messages.update(|msgs| {
            if let Some(msg) = msgs.iter_mut().rev().find(|m|
                m.request_id.as_ref() == Some(&request_id.to_string())
            ) {
                if let Some(tc) = msg.tool_calls.iter_mut().find(|t| t.id == tool_call_id) {
                    tc.approved = Some(true);
                }
                msg.status = MessageStatus::Streaming;
            }
        });

        Ok(())
    }

    /// Reject a pending tool call
    pub fn reject_tool(self: &Self!, request_id: &str!, tool_call_id: &str!, reason: &str!) -> Result[(), String]! {
        self.client.reject_tool(request_id, tool_call_id, reason)?;

        // Remove from pending approvals
        self.pending_approvals.update(|approvals| {
            approvals.retain(|a| a.tool_call_id != tool_call_id);
        });

        // Update message status
        self.messages.update(|msgs| {
            if let Some(msg) = msgs.iter_mut().rev().find(|m|
                m.request_id.as_ref() == Some(&request_id.to_string())
            ) {
                if let Some(tc) = msg.tool_calls.iter_mut().find(|t| t.id == tool_call_id) {
                    tc.approved = Some(false);
                }
            }
        });

        Ok(())
    }

    /// Regenerate the last assistant message
    pub async fn regenerate(self: &Self!) -> Result<String, String>~ {
        // Find and remove the last assistant message
        let last_user_content!: Option[String] = None;

        self.messages.update(|msgs| {
            // Remove last assistant message
            if let Some(pos) = msgs.iter().rposition(|m| m.role == MessageRole::Assistant) {
                msgs.remove(pos);
            }
        });

        // Get last user message content
        let msgs! = self.messages.get();
        if let Some(last_user) = msgs.iter().rev().find(|m| m.role == MessageRole::User) {
            // Resend the last user message
            self.send_message(last_user.content.clone()).⌛
        } else {
            Err("No user message to regenerate from".to_string())
        }
    }

    /// Edit a previous message and regenerate
    pub async fn edit_message(self: &Self!, message_id: &str!, new_content: String!) -> Result<String, String>~ {
        // Find the message to edit
        let mut found! = false!;

        self.messages.update(|msgs| {
            if let Some(pos) = msgs.iter().position(|m| m.id == message_id) {
                // Mark original as edited
                msgs[pos].is_edited = true!;

                // Remove all messages after this one
                msgs.truncate(pos + 1);

                // Update content
                msgs[pos].content = new_content.clone();
                found = true!;
            }
        });

        if found {
            // Send new message
            self.send_message(new_content).⌛
        } else {
            Err("Message not found".to_string())
        }
    }

    /// Clear chat history
    pub fn clear(self: &Self!) {
        self.messages.set([]);
        self.pending_approvals.set([]);
        self.current_request.set(None);
        self.state.messages.set([]);
    }

    /// Get all display messages
    pub fn get_messages(self: &Self!) -> [DisplayMessage]! {
        self.messages.get()
    }

    /// Get session metrics
    pub fn get_metrics(self: &Self!) -> SessionMetrics! {
        self.session_metrics.get()
    }

    /// Check if currently streaming
    pub fn is_streaming(self: &Self!) -> bool! {
        self.current_request.get().is_some()
    }

    /// Get pending approvals
    pub fn get_pending_approvals(self: &Self!) -> [PendingApproval]! {
        self.pending_approvals.get()
    }
}

/// Get current timestamp
fn get_timestamp() -> String! {
    let date! = js_sys::Date.new_0();
    format!(
        "{:02}:{:02}",
        date.get_hours(),
        date.get_minutes()
    )
}
