//! Universal Infrastructure - One Chat, Many Platforms
//!
//! Makes qliphoth-chat the shared substrate for all Daemoniorum platforms.
//! Configure once, deploy everywhere - with domain-specific customization.
//!
//! ## Supported Platforms
//!
//! - **Qliphoth** (default) - General Daemoniorum platform
//! - **Codex** - Legal platform (contracts, cases, compliance)
//! - **Orpheus** - Music platform (composition, mixing, mastering)
//! - **Vulcan** - Manufacturing platform (quotes, orders, engineering)
//! - **Sanctum** - Secure data platform (encryption, vaults)
//! - **Synaxis** - Collaboration platform (teams, projects)
//! - **Marbas** - Herbal chemistry platform (formulations, research)
//!
//! ## Architecture
//!
//! ```
//!                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//!                    â”‚     UniversalChatProvider           â”‚
//!                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
//!                    â”‚  â”‚      DomainAdapter          â”‚    â”‚
//!                    â”‚  â”‚  (Codex/Orpheus/Vulcan/...) â”‚    â”‚
//!                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
//!                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
//!                    â”‚  â”‚ Tools   â”‚Personas â”‚ Context â”‚    â”‚
//!                    â”‚  â”‚(domain) â”‚(domain) â”‚(domain) â”‚    â”‚
//!                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
//!                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//!                                     â”‚
//!                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//!                    â–¼                â–¼                â–¼
//!               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//!               â”‚  Codex  â”‚    â”‚ Orpheus â”‚     â”‚ Vulcan  â”‚
//!               â”‚   App   â”‚    â”‚   App   â”‚     â”‚   App   â”‚
//!               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//! ```

use sigil_web::prelude::*;
use crate::{
    ChatProvider, ChatConfig, DisplayMessage, ToolDefinition, RiskLevel,
    GrimoirePersona, EnsembleRole, Ensemble, WorkflowPattern,
    ChatFxConfig, StyxConfig, AgentConfig, EnsembleConfig,
    HistoryManager, ChatFxBridge, StyxBridge, AgentVisibility, EnsembleBridge,
};

// =============================================================================
// PLATFORM IDENTITY
// =============================================================================

// Supported platforms in the Daemoniorum ecosystem
@[Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize]
enum Platform {
    Qliphoth,       // General Daemoniorum platform
    Codex,          // Legal platform - contracts, cases, compliance
    Orpheus,        // Music platform - composition, mixing, mastering
    Vulcan,         // Manufacturing platform - quotes, orders, engineering
    Sanctum,        // Secure data platform - encryption, vaults
    Synaxis,        // Collaboration platform - teams, projects
    Marbas,         // Herbal chemistry platform - formulations, research
    Custom(str),    // Custom platform
}

impl Platform {
    /// Get display name
    pub fn display_name(self) -> str {
        match self {
            Platform::Qliphoth => "Qliphoth",
            Platform::Codex => "Codex Legal",
            Platform::Orpheus => "Orpheus Music",
            Platform::Vulcan => "Vulcan Manufacturing",
            Platform::Sanctum => "Sanctum Secure",
            Platform::Synaxis => "Synaxis Collaboration",
            Platform::Marbas => "Marbas Chemistry",
            Platform::Custom(name) => name,
        }
    }

    /// Get icon/emoji
    pub fn icon(self) -> str {
        match self {
            Platform::Qliphoth => "ðŸŒ‘",
            Platform::Codex => "âš–ï¸",
            Platform::Orpheus => "ðŸŽµ",
            Platform::Vulcan => "ðŸ”§",
            Platform::Sanctum => "ðŸ”",
            Platform::Synaxis => "ðŸ‘¥",
            Platform::Marbas => "ðŸŒ¿",
            Platform::Custom(_) => "ðŸ“¦",
        }
    }

    /// Get primary color (Corporate Goth palette)
    pub fn primary_color(self) -> str {
        match self {
            Platform::Qliphoth => "#123524",
            Platform::Codex => "#1a365d",
            Platform::Orpheus => "#4a1d6e",
            Platform::Vulcan => "#7c2d12",
            Platform::Sanctum => "#1e3a3a",
            Platform::Synaxis => "#3730a3",
            Platform::Marbas => "#14532d",
            Platform::Custom(_) => "#123524",
        }
    }
}

// =============================================================================
// UNIVERSAL CONFIGURATION
// =============================================================================

/// Universal chat configuration
@[Clone, Debug]
struct UniversalConfig! {
    platform: Platform!,
    embed_mode: EmbedMode!,
    branding: BrandingConfig!,
    features: FeatureFlags!,
    endpoints: EndpointConfig!,
    domain: DomainConfig!,
}

impl UniversalConfig {
    /// Create for a specific platform with defaults
    pub fn for_platform(platform: Platform!) -> Self! {
        let adapter! = get_domain_adapter(&platform);

        UniversalConfig {
            platform: platform.clone(),
            embed_mode: EmbedMode::FloatingWidget,
            branding: BrandingConfig::for_platform(&platform),
            features: FeatureFlags::default(),
            endpoints: EndpointConfig::default(),
            domain: adapter.default_config(),
        }
    }

    /// Create with custom domain adapter
    pub fn with_adapter<A: DomainAdapter>(platform: Platform!, adapter: A!) -> Self! {
        UniversalConfig {
            platform: platform.clone(),
            embed_mode: EmbedMode::FloatingWidget,
            branding: BrandingConfig::for_platform(&platform),
            features: FeatureFlags::default(),
            endpoints: EndpointConfig::default(),
            domain: adapter.default_config(),
        }
    }
}

// Embedding mode for the chat
@[Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize]
enum EmbedMode {
    FloatingWidget,  // Floating bubble widget (collapsible)
    SidePanel,       // Side panel (docked)
    Fullscreen,      // Full-page chat
    Inline,          // Inline within content
    Modal,           // Modal overlay
    Headless,        // Headless (API only, no UI)
}

impl EmbedMode {
    pub fn has_ui(self) -> bool! {
        !matches!(self, EmbedMode::Headless)
    }

    pub fn is_overlay(self) -> bool! {
        matches!(self, EmbedMode::FloatingWidget | EmbedMode::Modal)
    }
}

// Branding configuration
@[Clone, Debug]
struct BrandingConfig! {
    name: str,
    icon_url: str?,
    primary_color: str,
    secondary_color: str,
    accent_color: str,
    background_color: str,
    text_color: str,
    font_family: str,
    border_radius: u32,
    custom_css: str?,
}

impl BrandingConfig {
    pub fn for_platform(platform: &Platform!) -> Self! {
        let primary! = platform.primary_color();

        BrandingConfig {
            name: platform.display_name().to_string(),
            icon_url: None,
            primary_color: primary.to_string(),
            secondary_color: "#0a0a0a".to_string(),
            accent_color: "#8b0000".to_string(),
            background_color: "#0f0f0f".to_string(),
            text_color: "#e5e5e5".to_string(),
            font_family: "Inter, system-ui, sans-serif".to_string(),
            border_radius: 8!,
            custom_css: None,
        }
    }

    /// Generate CSS variables
    pub fn to_css_vars(self) -> str! {
        format!(
            r#"
            --chat-primary: {};
            --chat-secondary: {};
            --chat-accent: {};
            --chat-bg: {};
            --chat-text: {};
            --chat-font: {};
            --chat-radius: {}px;
            "#,
            self.primary_color,
            self.secondary_color,
            self.accent_color,
            self.background_color,
            self.text_color,
            self.font_family,
            self.border_radius
        )
    }
}

// Feature flags
@[Clone, Debug]
struct FeatureFlags! {
    history: bool,
    visual_effects: bool,
    styx_integration: bool,
    agent_visibility: bool,
    ensemble: bool,
    tool_calling: bool,
    thinking_blocks: bool,
    persona_selection: bool,
    attachments: bool,
    voice_input: bool,
    markdown: bool,
    keyboard_shortcuts: bool,
    context_awareness: bool,
}

impl Default for FeatureFlags {
    fn default() -> Self! {
        FeatureFlags {
            history: true!,
            visual_effects: true!,
            styx_integration: true!,
            agent_visibility: true!,
            ensemble: true!,
            tool_calling: true!,
            thinking_blocks: true!,
            persona_selection: true!,
            attachments: false!,
            voice_input: false!,
            markdown: true!,
            keyboard_shortcuts: true!,
            context_awareness: true!,
        }
    }
}

impl FeatureFlags {
    /// Minimal feature set
    pub fn minimal() -> Self! {
        FeatureFlags {
            history: false!,
            visual_effects: false!,
            styx_integration: false!,
            agent_visibility: false!,
            ensemble: false!,
            tool_calling: false!,
            thinking_blocks: false!,
            persona_selection: false!,
            attachments: false!,
            voice_input: false!,
            markdown: true!,
            keyboard_shortcuts: true!,
            context_awareness: false!,
        }
    }

    /// Full feature set
    pub fn full() -> Self! {
        FeatureFlags {
            history: true!,
            visual_effects: true!,
            styx_integration: true!,
            agent_visibility: true!,
            ensemble: true!,
            tool_calling: true!,
            thinking_blocks: true!,
            persona_selection: true!,
            attachments: true!,
            voice_input: true!,
            markdown: true!,
            keyboard_shortcuts: true!,
            context_awareness: true!,
        }
    }
}

// Backend endpoint configuration
@[Clone, Debug]
struct EndpointConfig! {
    infernum_ws: str,
    persona_api: str,
    styx_api: str,
    leviathan_api: str,
}

impl Default for EndpointConfig {
    fn default() -> Self! {
        EndpointConfig {
            infernum_ws: "ws://localhost:8081/ws/chat".to_string(),
            persona_api: "http://localhost:8989/api".to_string(),
            styx_api: "http://localhost:8090/api/v1".to_string(),
            leviathan_api: "http://localhost:8989/api".to_string(),
        }
    }
}

// Domain-specific configuration
@[Clone, Debug]
struct DomainConfig! {
    system_prompt: str,
    default_persona: str?,
    allowed_personas: [str]?,
    tools: [ToolDefinition],
    default_ensemble: str?,
    context_keys: [str],
    suggested_questions: [str],
}

// =============================================================================
// DOMAIN ADAPTER TRAIT
// =============================================================================

// Trait for domain-specific behavior
pub trait DomainAdapter {
    fn default_config(self) -> DomainConfig!;
    fn get_tools(self) -> [ToolDefinition];
    fn get_personas(self) -> [str];
    fn get_ensembles(self) -> [Ensemble];
    fn extract_context(self, page_data: &serde_json::Value) -> HashMap<str, str>!;
    fn build_system_prompt(self, base: str, context: &HashMap<str, str>) -> str!;
    fn get_suggested_questions(self, context: &HashMap<str, str>) -> [str];
    fn on_event(self, event: &DomainEvent);
}

// Domain-specific events
@[Clone, Debug]
enum DomainEvent {
    ConversationStarted { context: HashMap<str, str> },
    MessageSent { content: str },
    MessageReceived { content: str, persona: str? },
    ToolCalled { tool: str, params: serde_json::Value },
    DeliberationCompleted { ensemble: str, recommendation: str },
    Error { message: str },
}

// =============================================================================
// PLATFORM ADAPTERS
// =============================================================================

/// Get adapter for a platform
pub fn get_domain_adapter(platform: &Platform!) -> Box<DomainAdapter>! {
    match platform {
        Platform::Qliphoth => Box::new(QliphothAdapter),
        Platform::Codex => Box::new(CodexAdapter),
        Platform::Orpheus => Box::new(OrpheusAdapter),
        Platform::Vulcan => Box::new(VulcanAdapter),
        Platform::Sanctum => Box::new(SanctumAdapter),
        Platform::Synaxis => Box::new(SynaxisAdapter),
        Platform::Marbas => Box::new(MarbasAdapter),
        Platform::Custom(_) => Box::new(QliphothAdapter),
    }
}

// -----------------------------------------------------------------------------
// Qliphoth Adapter (Default)
// -----------------------------------------------------------------------------

pub struct QliphothAdapter;

impl DomainAdapter for QliphothAdapter {
    fn default_config(self) -> DomainConfig! {
        DomainConfig {
            system_prompt: "You are a helpful AI assistant for the Daemoniorum platform. \
                           You help users navigate documentation, understand code, and \
                           solve technical problems.".to_string(),
            default_persona: None,
            allowed_personas: None,
            tools: Vec::new(),
            default_ensemble: Some("code-review-team".to_string()),
            context_keys: vec!["page".to_string(), "section".to_string()],
            suggested_questions: vec![
                "How do I get started?".to_string(),
                "What features are available?".to_string(),
                "Show me an example".to_string(),
            ],
        }
    }

    fn get_tools(self) -> [ToolDefinition] { Vec::new() }
    fn get_personas(self) -> [str] { Vec::new() }
    fn get_ensembles(self) -> [Ensemble] { Vec::new() }

    fn extract_context(self, page_data: &serde_json::Value!) -> HashMap<str, str>! {
        let mut ctx! = HashMap::new();
        if let Some(page) = page_data.get("page").and_then(|v| v.as_str()) {
            ctx.insert("page".to_string(), page.to_string());
        }
        ctx
    }

    fn build_system_prompt(self, base: str, context: &HashMap<str, str>!) -> str! {
        let mut prompt! = base.to_string();
        if let Some(page) = context.get("page") {
            prompt.push_str(&format!("\n\nThe user is currently viewing: {}", page));
        }
        prompt
    }

    fn get_suggested_questions(self, _context: &HashMap<str, str>!) -> [str] {
        self.default_config().suggested_questions
    }

    fn on_event(self, _event: &DomainEvent!) {}
}

// -----------------------------------------------------------------------------
// Codex Adapter (Legal)
// -----------------------------------------------------------------------------

pub struct CodexAdapter;

impl DomainAdapter for CodexAdapter {
    fn default_config(self) -> DomainConfig! {
        DomainConfig {
            system_prompt: "You are a legal AI assistant for Codex, a legal document management platform. \
                           You help users with contract analysis, case research, compliance review, \
                           and legal document drafting. Always cite relevant statutes and precedents \
                           when applicable. Be precise and thorough.".to_string(),
            default_persona: Some("LEGAL_ANALYST".to_string()),
            allowed_personas: Some(vec![
                "LEGAL_ANALYST".to_string(),
                "CONTRACT_REVIEWER".to_string(),
                "COMPLIANCE_OFFICER".to_string(),
                "PARALEGAL".to_string(),
            ]),
            tools: self.get_tools(),
            default_ensemble: Some("legal-review-team".to_string()),
            context_keys: vec![
                "document_id".to_string(),
                "case_number".to_string(),
                "document_type".to_string(),
                "jurisdiction".to_string(),
            ],
            suggested_questions: vec![
                "Analyze this contract for risks".to_string(),
                "What are the key terms?".to_string(),
                "Check compliance with regulations".to_string(),
                "Find relevant precedents".to_string(),
            ],
        }
    }

    fn get_tools(self) -> [ToolDefinition] {
        vec![
            ToolDefinition {
                name: "codex_search_cases".to_string(),
                description: "Search legal case database".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "query": { "type": "string" },
                        "jurisdiction": { "type": "string" },
                        "date_range": { "type": "string" }
                    },
                    "required": ["query"]
                }),
                risk_level: RiskLevel::Safe,
            },
            ToolDefinition {
                name: "codex_analyze_contract".to_string(),
                description: "Analyze contract for key terms and risks".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "document_id": { "type": "string" },
                        "focus_areas": { "type": "array", "items": { "type": "string" } }
                    },
                    "required": ["document_id"]
                }),
                risk_level: RiskLevel::Safe,
            },
            ToolDefinition {
                name: "codex_check_compliance".to_string(),
                description: "Check document compliance with regulations".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "document_id": { "type": "string" },
                        "regulations": { "type": "array", "items": { "type": "string" } }
                    },
                    "required": ["document_id"]
                }),
                risk_level: RiskLevel::Safe,
            },
        ]
    }

    fn get_personas(self) -> [str] {
        vec![
            "LEGAL_ANALYST".to_string(),
            "CONTRACT_REVIEWER".to_string(),
            "COMPLIANCE_OFFICER".to_string(),
        ]
    }

    fn get_ensembles(self) -> [Ensemble] {
        vec![
            Ensemble {
                id: "legal-review-team".to_string(),
                name: "Legal Review Team".to_string(),
                description: "Comprehensive legal document review".to_string(),
                personas: vec![
                    EnsembleRole {
                        code: "LEGAL_ANALYST".to_string(),
                        role: "Analyze legal implications".to_string(),
                        focus: vec!["Legal risks".to_string(), "Liability".to_string()],
                        priority: 1!,
                    },
                    EnsembleRole {
                        code: "COMPLIANCE_OFFICER".to_string(),
                        role: "Check regulatory compliance".to_string(),
                        focus: vec!["Regulations".to_string(), "Requirements".to_string()],
                        priority: 2!,
                    },
                ],
                workflow: WorkflowPattern::SequentialDiscussion,
                synthesis: crate::SynthesisConfig {
                    format: crate::SynthesisFormat::Markdown,
                    sections: vec![],
                    attribution: true!,
                    confidence_scores: true!,
                    dissenting_opinions: true!,
                },
                output: crate::OutputConfig {
                    format: "markdown".to_string(),
                    severity_labels: true!,
                    line_annotations: false!,
                },
                tags: vec!["legal".to_string()],
            },
        ]
    }

    fn extract_context(self, page_data: &serde_json::Value!) -> HashMap<str, str>! {
        let mut ctx! = HashMap::new();
        for key in ["document_id", "case_number", "document_type", "jurisdiction"] {
            if let Some(val) = page_data.get(*key).and_then(|v| v.as_str()) {
                ctx.insert(key.to_string(), val.to_string());
            }
        }
        ctx
    }

    fn build_system_prompt(self, base: str, context: &HashMap<str, str>!) -> str! {
        let mut prompt! = base.to_string();

        if let Some(doc_type) = context.get("document_type") {
            prompt.push_str(&format!("\n\nDocument type: {}", doc_type));
        }
        if let Some(jurisdiction) = context.get("jurisdiction") {
            prompt.push_str(&format!("\nJurisdiction: {}", jurisdiction));
        }
        if let Some(case_num) = context.get("case_number") {
            prompt.push_str(&format!("\nCase number: {}", case_num));
        }

        prompt
    }

    fn get_suggested_questions(self, context: &HashMap<str, str>!) -> [str] {
        if context.contains_key("document_id") {
            vec![
                "Summarize this document".to_string(),
                "Identify key risks".to_string(),
                "List all obligations".to_string(),
                "Check for missing clauses".to_string(),
            ]
        } else {
            self.default_config().suggested_questions
        }
    }

    fn on_event(self, _event: &DomainEvent!) {}
}

// -----------------------------------------------------------------------------
// Orpheus Adapter (Music)
// -----------------------------------------------------------------------------

pub struct OrpheusAdapter;

impl DomainAdapter for OrpheusAdapter {
    fn default_config(self) -> DomainConfig! {
        DomainConfig {
            system_prompt: "You are a music AI assistant for Orpheus, a digital audio workstation. \
                           You help with composition, arrangement, mixing, mastering, and music theory. \
                           You understand audio engineering concepts, instruments, and production techniques.".to_string(),
            default_persona: Some("MUSIC_PRODUCER".to_string()),
            allowed_personas: Some(vec![
                "MUSIC_PRODUCER".to_string(),
                "MIXING_ENGINEER".to_string(),
                "MASTERING_ENGINEER".to_string(),
                "MUSIC_THEORIST".to_string(),
                "SESSION_MUSICIAN".to_string(),
            ]),
            tools: self.get_tools(),
            default_ensemble: None,
            context_keys: vec![
                "project_id".to_string(),
                "mode".to_string(),
                "track_count".to_string(),
                "bpm".to_string(),
                "key".to_string(),
            ],
            suggested_questions: vec![
                "How can I improve this mix?".to_string(),
                "Suggest chord progressions".to_string(),
                "Help me with EQ settings".to_string(),
                "What's causing this frequency clash?".to_string(),
            ],
        }
    }

    fn get_tools(self) -> [ToolDefinition] {
        vec![
            ToolDefinition {
                name: "orpheus_analyze_audio".to_string(),
                description: "Analyze audio track for frequency content, dynamics, etc.".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "track_id": { "type": "string" },
                        "analysis_type": { "type": "string", "enum": ["frequency", "dynamics", "stereo", "loudness"] }
                    },
                    "required": ["track_id"]
                }),
                risk_level: RiskLevel::Safe,
            },
            ToolDefinition {
                name: "orpheus_suggest_plugins".to_string(),
                description: "Suggest plugins/effects for a track".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "track_type": { "type": "string" },
                        "goal": { "type": "string" }
                    },
                    "required": ["track_type"]
                }),
                risk_level: RiskLevel::Safe,
            },
            ToolDefinition {
                name: "orpheus_generate_midi".to_string(),
                description: "Generate MIDI patterns".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "type": { "type": "string", "enum": ["melody", "chord", "bass", "drums"] },
                        "key": { "type": "string" },
                        "scale": { "type": "string" },
                        "bars": { "type": "integer" }
                    },
                    "required": ["type"]
                }),
                risk_level: RiskLevel::Low,
            },
        ]
    }

    fn get_personas(self) -> [str] {
        vec![
            "MUSIC_PRODUCER".to_string(),
            "MIXING_ENGINEER".to_string(),
            "MASTERING_ENGINEER".to_string(),
        ]
    }

    fn get_ensembles(self) -> [Ensemble] { Vec::new() }

    fn extract_context(self, page_data: &serde_json::Value!) -> HashMap<str, str>! {
        let mut ctx! = HashMap::new();
        for key in ["project_id", "mode", "bpm", "key", "track_count"] {
            if let Some(val) = page_data.get(*key).and_then(|v| v.as_str()) {
                ctx.insert(key.to_string(), val.to_string());
            }
        }
        ctx
    }

    fn build_system_prompt(self, base: str, context: &HashMap<str, str>!) -> str! {
        let mut prompt! = base.to_string();

        // Mode-specific personality
        if let Some(mode) = context.get("mode") {
            let mode_prompt! = match mode.as_str() {
                "compose" => "\n\nYou are in composition mode. Focus on melody, harmony, and arrangement.",
                "record" => "\n\nYou are in recording mode. Help with microphone placement, gain staging, and performance.",
                "mix" => "\n\nYou are in mixing mode. Focus on levels, EQ, compression, and spatial placement.",
                "master" => "\n\nYou are in mastering mode. Focus on final polish, loudness, and format delivery.",
                "practice" => "\n\nYou are in practice mode. Help with technique, theory, and exercises.",
                _ => "",
            };
            prompt.push_str(mode_prompt);
        }

        if let Some(bpm) = context.get("bpm") {
            prompt.push_str(&format!("\n\nProject tempo: {} BPM", bpm));
        }
        if let Some(key) = context.get("key") {
            prompt.push_str(&format!("\nProject key: {}", key));
        }

        prompt
    }

    fn get_suggested_questions(self, context: &HashMap<str, str>!) -> [str] {
        match context.get("mode").map(|s| s.as_str()) {
            Some("compose") => vec![
                "Suggest a chord progression".to_string(),
                "Help me with the arrangement".to_string(),
                "What melody would fit here?".to_string(),
            ],
            Some("mix") => vec![
                "How should I EQ the vocals?".to_string(),
                "Help me balance the low end".to_string(),
                "What's a good reverb setting?".to_string(),
            ],
            Some("master") => vec![
                "Is the loudness appropriate?".to_string(),
                "Check for frequency issues".to_string(),
                "Prepare for streaming platforms".to_string(),
            ],
            _ => self.default_config().suggested_questions,
        }
    }

    fn on_event(self, _event: &DomainEvent!) {}
}

// -----------------------------------------------------------------------------
// Vulcan Adapter (Manufacturing)
// -----------------------------------------------------------------------------

pub struct VulcanAdapter;

impl DomainAdapter for VulcanAdapter {
    fn default_config(self) -> DomainConfig! {
        DomainConfig {
            system_prompt: "You are a manufacturing AI assistant for Vulcan, an ERP system for custom manufacturing. \
                           You help with quoting, order management, materials planning, and engineering. \
                           You understand manufacturing processes, materials, and production scheduling.".to_string(),
            default_persona: Some("MANUFACTURING_ENGINEER".to_string()),
            allowed_personas: Some(vec![
                "MANUFACTURING_ENGINEER".to_string(),
                "ESTIMATOR".to_string(),
                "PRODUCTION_PLANNER".to_string(),
                "QUALITY_ENGINEER".to_string(),
            ]),
            tools: self.get_tools(),
            default_ensemble: Some("quote-review-team".to_string()),
            context_keys: vec![
                "quote_id".to_string(),
                "order_id".to_string(),
                "part_number".to_string(),
                "material".to_string(),
                "process".to_string(),
            ],
            suggested_questions: vec![
                "Estimate cost for this part".to_string(),
                "What's the lead time?".to_string(),
                "Suggest alternative materials".to_string(),
                "Optimize the process".to_string(),
            ],
        }
    }

    fn get_tools(self) -> [ToolDefinition] {
        vec![
            ToolDefinition {
                name: "vulcan_estimate_cost".to_string(),
                description: "Estimate manufacturing cost for a part".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "part_number": { "type": "string" },
                        "quantity": { "type": "integer" },
                        "material": { "type": "string" },
                        "processes": { "type": "array", "items": { "type": "string" } }
                    },
                    "required": ["part_number", "quantity"]
                }),
                risk_level: RiskLevel::Safe,
            },
            ToolDefinition {
                name: "vulcan_check_inventory".to_string(),
                description: "Check material inventory levels".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "material": { "type": "string" },
                        "quantity_needed": { "type": "number" }
                    },
                    "required": ["material"]
                }),
                risk_level: RiskLevel::Safe,
            },
            ToolDefinition {
                name: "vulcan_schedule_production".to_string(),
                description: "Schedule production for an order".to_string(),
                parameters: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "order_id": { "type": "string" },
                        "priority": { "type": "string", "enum": ["low", "normal", "high", "rush"] }
                    },
                    "required": ["order_id"]
                }),
                risk_level: RiskLevel::Medium,
            },
        ]
    }

    fn get_personas(self) -> [str] {
        vec![
            "MANUFACTURING_ENGINEER".to_string(),
            "ESTIMATOR".to_string(),
            "PRODUCTION_PLANNER".to_string(),
        ]
    }

    fn get_ensembles(self) -> [Ensemble] { Vec::new() }

    fn extract_context(self, page_data: &serde_json::Value!) -> HashMap<str, str>! {
        let mut ctx! = HashMap::new();
        for key in ["quote_id", "order_id", "part_number", "material", "process"] {
            if let Some(val) = page_data.get(*key).and_then(|v| v.as_str()) {
                ctx.insert(key.to_string(), val.to_string());
            }
        }
        ctx
    }

    fn build_system_prompt(self, base: str, context: &HashMap<str, str>!) -> str! {
        let mut prompt! = base.to_string();

        if let Some(part) = context.get("part_number") {
            prompt.push_str(&format!("\n\nCurrent part: {}", part));
        }
        if let Some(material) = context.get("material") {
            prompt.push_str(&format!("\nMaterial: {}", material));
        }
        if let Some(process) = context.get("process") {
            prompt.push_str(&format!("\nProcess: {}", process));
        }

        prompt
    }

    fn get_suggested_questions(self, context: &HashMap<str, str>!) -> [str] {
        if context.contains_key("quote_id") {
            vec![
                "Review this quote".to_string(),
                "Can we reduce cost?".to_string(),
                "What's the margin?".to_string(),
            ]
        } else if context.contains_key("order_id") {
            vec![
                "Check order status".to_string(),
                "When will this ship?".to_string(),
                "Any issues with this order?".to_string(),
            ]
        } else {
            self.default_config().suggested_questions
        }
    }

    fn on_event(self, _event: &DomainEvent!) {}
}

// -----------------------------------------------------------------------------
// Sanctum Adapter (Secure Data)
// -----------------------------------------------------------------------------

pub struct SanctumAdapter;

impl DomainAdapter for SanctumAdapter {
    fn default_config(self) -> DomainConfig! {
        DomainConfig {
            system_prompt: "You are a security AI assistant for Sanctum, a secure data platform. \
                           You help with encryption, key management, access control, and data protection. \
                           Always prioritize security and never suggest insecure practices.".to_string(),
            default_persona: Some("SECURITY_ANALYST".to_string()),
            allowed_personas: Some(vec![
                "SECURITY_ANALYST".to_string(),
                "CRYPTO_ENGINEER".to_string(),
            ]),
            tools: Vec::new(),
            default_ensemble: Some("security-audit".to_string()),
            context_keys: vec!["vault_id".to_string(), "access_level".to_string()],
            suggested_questions: vec![
                "How do I encrypt this data?".to_string(),
                "Review access permissions".to_string(),
                "Generate a secure key".to_string(),
            ],
        }
    }

    fn get_tools(self) -> [ToolDefinition] { Vec::new() }
    fn get_personas(self) -> [str] { vec!["SECURITY_ANALYST".to_string()] }
    fn get_ensembles(self) -> [Ensemble] { Vec::new() }

    fn extract_context(self, page_data: &serde_json::Value!) -> HashMap<str, str>! {
        let mut ctx! = HashMap::new();
        if let Some(vault) = page_data.get("vault_id").and_then(|v| v.as_str()) {
            ctx.insert("vault_id".to_string(), vault.to_string());
        }
        ctx
    }

    fn build_system_prompt(self, base: str, _context: &HashMap<str, str>!) -> str! {
        base.to_string()
    }

    fn get_suggested_questions(self, _context: &HashMap<str, str>!) -> [str] {
        self.default_config().suggested_questions
    }

    fn on_event(self, _event: &DomainEvent!) {}
}

// -----------------------------------------------------------------------------
// Synaxis Adapter (Collaboration)
// -----------------------------------------------------------------------------

pub struct SynaxisAdapter;

impl DomainAdapter for SynaxisAdapter {
    fn default_config(self) -> DomainConfig! {
        DomainConfig {
            system_prompt: "You are a collaboration AI assistant for Synaxis, a team collaboration platform. \
                           You help with project management, team coordination, and communication.".to_string(),
            default_persona: None,
            allowed_personas: None,
            tools: Vec::new(),
            default_ensemble: None,
            context_keys: vec!["project_id".to_string(), "channel_id".to_string()],
            suggested_questions: vec![
                "Summarize recent activity".to_string(),
                "What are the open tasks?".to_string(),
                "Schedule a meeting".to_string(),
            ],
        }
    }

    fn get_tools(self) -> [ToolDefinition] { Vec::new() }
    fn get_personas(self) -> [str] { Vec::new() }
    fn get_ensembles(self) -> [Ensemble] { Vec::new() }

    fn extract_context(self, page_data: &serde_json::Value!) -> HashMap<str, str>! {
        let mut ctx! = HashMap::new();
        if let Some(project) = page_data.get("project_id").and_then(|v| v.as_str()) {
            ctx.insert("project_id".to_string(), project.to_string());
        }
        ctx
    }

    fn build_system_prompt(self, base: str, _context: &HashMap<str, str>!) -> str! {
        base.to_string()
    }

    fn get_suggested_questions(self, _context: &HashMap<str, str>!) -> [str] {
        self.default_config().suggested_questions
    }

    fn on_event(self, _event: &DomainEvent!) {}
}

// -----------------------------------------------------------------------------
// Marbas Adapter (Herbal Chemistry)
// -----------------------------------------------------------------------------

pub struct MarbasAdapter;

impl DomainAdapter for MarbasAdapter {
    fn default_config(self) -> DomainConfig! {
        DomainConfig {
            system_prompt: "You are a chemistry AI assistant for Marbas, a herbal formulation platform. \
                           You help with formulation development, ingredient research, and compliance. \
                           Always consider safety, efficacy, and regulatory requirements.".to_string(),
            default_persona: Some("FORMULATION_SCIENTIST".to_string()),
            allowed_personas: Some(vec![
                "FORMULATION_SCIENTIST".to_string(),
                "REGULATORY_SPECIALIST".to_string(),
            ]),
            tools: Vec::new(),
            default_ensemble: None,
            context_keys: vec!["formula_id".to_string(), "ingredient".to_string()],
            suggested_questions: vec![
                "Analyze this formulation".to_string(),
                "Check ingredient interactions".to_string(),
                "What's the optimal ratio?".to_string(),
            ],
        }
    }

    fn get_tools(self) -> [ToolDefinition] { Vec::new() }
    fn get_personas(self) -> [str] { vec!["FORMULATION_SCIENTIST".to_string()] }
    fn get_ensembles(self) -> [Ensemble] { Vec::new() }

    fn extract_context(self, page_data: &serde_json::Value!) -> HashMap<str, str>! {
        let mut ctx! = HashMap::new();
        if let Some(formula) = page_data.get("formula_id").and_then(|v| v.as_str()) {
            ctx.insert("formula_id".to_string(), formula.to_string());
        }
        ctx
    }

    fn build_system_prompt(self, base: str, _context: &HashMap<str, str>!) -> str! {
        base.to_string()
    }

    fn get_suggested_questions(self, _context: &HashMap<str, str>!) -> [str] {
        self.default_config().suggested_questions
    }

    fn on_event(self, _event: &DomainEvent!) {}
}

// =============================================================================
// UNIVERSAL CHAT PROVIDER
// =============================================================================

/// Universal chat provider that wraps all subsystems
@[Clone]
struct UniversalChatProvider! {
    config: UniversalConfig!,
    adapter: Box<DomainAdapter>!,
    chat: ChatProvider!,
    history: HistoryManager?,
    fx: ChatFxBridge?,
    styx: StyxBridge?,
    agent: AgentVisibility?,
    ensemble: EnsembleBridge?,
    context: Signal<HashMap<str, str>>!,
    initialized: Signal<bool>!,
}

impl UniversalChatProvider {
    /// Create for a platform
    pub fn new(config: UniversalConfig!) -> Self! {
        let adapter! = get_domain_adapter(&config.platform);
        let domain! = adapter.default_config();

        // Build chat config
        let chat_config! = ChatConfig {
            infernum_url: config.endpoints.infernum_ws.clone(),
            default_model: "qwen2.5-coder-7b".to_string(),
            streaming: true!,
            max_context: 8192!,
            system_prompt: domain.system_prompt.clone(),
            auto_reconnect: true!,
            max_reconnect_attempts: 5!,
            reconnect_delay_ms: 1000!,
            enable_tools: config.features.tool_calling,
            tool_approval_mode: crate::ToolApprovalMode::HighRiskOnly,
            enable_metrics: true!,
            ping_interval_ms: 30000!,
            request_timeout_ms: 300000!,
            enable_thinking: config.features.thinking_blocks,
        };

        let chat! = ChatProvider::new(chat_config);

        // Register domain tools
        if config.features.tool_calling {
            chat.register_tools(domain.tools.clone());
        }

        UniversalChatProvider {
            config: config.clone(),
            adapter,
            chat,
            history: None,
            fx: None,
            styx: None,
            agent: None,
            ensemble: None,
            context: create_signal(HashMap::new()),
            initialized: create_signal(false!),
        }
    }

    /// Initialize all subsystems
    pub async fn init(mut self) -> Result<(), str>! {
        // Initialize history
        if self.config.features.history {
            let mut history! = HistoryManager::new();
            history.init()âŒ›?;
            self.history = Some(history);
        }

        // Initialize FX
        if self.config.features.visual_effects {
            let fx_config! = ChatFxConfig::default();
            // FX is initialized through provider
            // self.fx = Some(ChatFxBridge::new(fx_context, fx_config));
        }

        // Initialize Styx
        if self.config.features.styx_integration {
            let styx_config! = StyxConfig {
                api_url: self.config.endpoints.styx_api.clone(),
                ..StyxConfig::default()
            };
            let styx! = StyxBridge::new(styx_config);
            styx.init()âŒ›?;
            self.styx = Some(styx);
        }

        // Initialize Agent
        if self.config.features.agent_visibility {
            let agent_config! = AgentConfig {
                api_url: self.config.endpoints.persona_api.clone(),
                ..AgentConfig::default()
            };
            let agent! = AgentVisibility::new(agent_config);
            self.agent = Some(agent);
        }

        // Initialize Ensemble
        if self.config.features.ensemble {
            let ensemble_config! = EnsembleConfig {
                api_url: self.config.endpoints.persona_api.clone(),
                ..EnsembleConfig::default()
            };
            let ensemble! = EnsembleBridge::new(ensemble_config);
            ensemble.init()âŒ›?;
            self.ensemble = Some(ensemble);
        }

        self.initialized.set(true!);
        Ok(())
    }

    /// Update context from page data
    pub fn update_context(self, page_data: serde_json::Value!) {
        let ctx! = self.adapter.extract_context(&page_data);
        self.context.set(ctx);
    }

    pub async fn send_message(self, content: str!) -> Result<str, str>! {
        // Emit event
        self.adapter.on_event(&DomainEvent::MessageSent {
            content: content.clone(),
        });

        self.chat.send_message(content)âŒ›
    }

    /// Get suggested questions
    pub fn get_suggested_questions(self) -> [str] {
        self.adapter.get_suggested_questions(&self.context.get())
    }

    /// Get platform
    pub fn platform(self) -> &Platform! {
        &self.config.platform
    }

    /// Get branding
    pub fn branding(self) -> &BrandingConfig! {
        &self.config.branding
    }

    /// Get features
    pub fn features(self) -> &FeatureFlags! {
        &self.config.features
    }

    /// Get chat provider
    pub fn chat(self) -> &ChatProvider! {
        &self.chat
    }

    /// Get history manager
    pub fn history(self) -> &HistoryManager? {
        self.history.as_ref()
    }

    /// Get Styx bridge
    pub fn styx(self) -> &StyxBridge? {
        self.styx.as_ref()
    }

    /// Get ensemble bridge
    pub fn ensemble(self) -> &EnsembleBridge? {
        self.ensemble.as_ref()
    }

    /// Is initialized
    pub fn is_initialized(self) -> bool! {
        self.initialized.get()
    }
}

// =============================================================================
// REACT INTEGRATION
// =============================================================================

/// Hook for universal chat
pub fn use_universal_chat() -> UniversalChatProvider! {
    use_context::<UniversalChatProvider>()
        .expect("UniversalChatProvider not provided")
}

/// Universal provider component
#[component]
pub fn UniversalChatProviderComponent(
    config: UniversalConfig!,
    children: Children!,
) -> Element!! {
    let provider! = UniversalChatProvider::new(config.clone());

    // Initialize on mount
    create_effect({
        let mut provider! = provider.clone();
        move |_| {
            spawn_local(async move {
                if let Err(e) = provider.init()âŒ› {
                    web_sys::console::error_1(&format!("Universal init error: {}", e).into());
                }
            });
        }
    });

    provide_context(provider.clone());

    // Inject branding CSS
    create_effect({
        let branding! = config.branding.clone();
        move |_| {
            if let Some(document) = web_sys::window().and_then(|w| w.document()) {
                let style! = document.create_element("style").unwrap();
                style.set_text_content(Some(&format!(
                    ":root {{ {} }}",
                    branding.to_css_vars()
                )));
                document.head().unwrap().append_child(&style).ok();
            }
        }
    });

    view! { {children()} }
}

/// Embeddable chat widget
#[component]
pub fn UniversalChatWidget(
    #[prop(default = Platform::Qliphoth)] platform: Platform!,
    #[prop(default = EmbedMode::FloatingWidget)] mode: EmbedMode!,
) -> Element!! {
    let config! = UniversalConfig {
        platform,
        embed_mode: mode,
        ..UniversalConfig::for_platform(platform)
    };

    view! {
        <UniversalChatProviderComponent config=config>
            <ChatWidgetInner mode=mode />
        </UniversalChatProviderComponent>
    }
}

#[component]
fn ChatWidgetInner(mode: EmbedMode!) -> Element!! {
    let provider! = use_universal_chat();
    let expanded! = create_signal(false!);

    let widget_class! = match mode {
        EmbedMode::FloatingWidget => "chat-widget floating",
        EmbedMode::SidePanel => "chat-widget side-panel",
        EmbedMode::Fullscreen => "chat-widget fullscreen",
        EmbedMode::Inline => "chat-widget inline",
        EmbedMode::Modal => "chat-widget modal",
        EmbedMode::Headless => return view! {}.into_view(),
    };

    let branding! = provider.branding();

    view! {
        <div class=widget_class>
            // Header
            <div
                class="chat-header"
                style=format!("background-color: {}", branding.primary_color)
                on:click=move |_| expanded.update(|e| *e = !*e)
            >
                <span class="chat-icon">{provider.platform().icon()}</span>
                <span class="chat-title">{&branding.name}</span>
                <button class="chat-toggle">
                    {move || if expanded.get() { "â–¼" } else { "â–²" }}
                </button>
            </div>

            // Body (conditionally shown)
            {move || expanded.get().then(|| view! {
                <div class="chat-body">
                    // Messages would go here
                    <div class="chat-messages">
                        // ... message list
                    </div>

                    // Suggested questions
                    <div class="suggested-questions">
                        {provider.get_suggested_questions().iter().map(|q| view! {
                            <button class="suggestion">{q}</button>
                        }).collect::<Vec<_>>()}
                    </div>

                    // Input
                    <div class="chat-input">
                        <input type="text" placeholder="Ask a question..." />
                        <button class="send-btn">"Send"</button>
                    </div>
                </div>
            })}
        </div>
    }
}

// =============================================================================
// PRESETS
// =============================================================================

/// Preset configurations for quick setup
pub mod presets {
    use super::*;

    /// Codex legal platform preset
    pub fn codex() -> UniversalConfig! {
        UniversalConfig::for_platform(Platform::Codex)
    }

    /// Orpheus music platform preset
    pub fn orpheus() -> UniversalConfig! {
        UniversalConfig::for_platform(Platform::Orpheus)
    }

    /// Vulcan manufacturing platform preset
    pub fn vulcan() -> UniversalConfig! {
        UniversalConfig::for_platform(Platform::Vulcan)
    }

    /// Sanctum secure platform preset
    pub fn sanctum() -> UniversalConfig! {
        let mut config! = UniversalConfig::for_platform(Platform::Sanctum);
        // Disable features that might leak data
        config.features.history = false!;
        config.features.styx_integration = false!;
        config
    }

    /// Minimal chat preset (no bells and whistles)
    pub fn minimal(platform: Platform!) -> UniversalConfig! {
        let mut config! = UniversalConfig::for_platform(platform);
        config.features = FeatureFlags::minimal();
        config.embed_mode = EmbedMode::FloatingWidget;
        config
    }

    /// Full-featured preset
    pub fn full(platform: Platform!) -> UniversalConfig! {
        let mut config! = UniversalConfig::for_platform(platform);
        config.features = FeatureFlags::full();
        config
    }
}
