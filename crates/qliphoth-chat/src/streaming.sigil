//! Streaming Response Handler
//!
//! Manages streaming LLM responses with token-by-token updates.

use sigil_web::prelude::*;
use qliphoth_core::state::{RwSignal, create_signal};

// Stream handler for processing LLM responses
@[Clone]
struct StreamHandler! {
    content: RwSignal,          // Current accumulated content
    is_active: RwSignal,        // Is stream active
    token_count: RwSignal,      // Token count
    on_token: Callback?,        // Callback for stream events
    on_complete: Callback?,
    on_error: Callback?,
}

impl StreamHandler {
    // Create new stream handler
    pub fn new() -> Self! {
        StreamHandler {
            content: create_signal(String::new()),
            is_active: create_signal(false),
            token_count: create_signal(0),
            on_token: None,
            on_complete: None,
            on_error: None,
        }
    }

    // Set callback for each token received
    pub fn with_on_token(mut self, callback: Callback) -> Self! {
        self.on_token = Some(callback);
        self
    }

    // Set callback for stream completion
    pub fn with_on_complete(mut self, callback: Callback) -> Self! {
        self.on_complete = Some(callback);
        self
    }

    // Set callback for errors
    pub fn with_on_error(mut self, callback: Callback) -> Self! {
        self.on_error = Some(callback);
        self
    }

    // Start the stream
    pub fn start(self) {
        self.is_active.set(true);
        self.content.set(String::new());
        self.token_count.set(0);
    }

    // Process incoming token
    pub fn process_token(self, token: str) {
        if !self.is_active.get() {
            return;
        }

        // Append token to content
        let mut current! = self.content.get();
        current.push_str(token);
        self.content.set(current);

        let count! = self.token_count.get() + 1;
        self.token_count.set(count);

        // Call token callback
        if let Some(callback) = self.on_token {
            callback.call(token);
        }
    }

    // Complete the stream
    pub fn complete(self) {
        self.is_active.set(false);

        // Call completion callback
        if let Some(callback) = self.on_complete {
            callback.call(&self.content.get());
        }
    }

    // Handle stream error
    pub fn error(self, message: str) {
        self.is_active.set(false);

        // Call error callback
        if let Some(callback) = self.on_error {
            callback.call(message);
        }
    }

    // Get current content
    pub fn get_content(self) -> String! {
        self.content.get()
    }

    // Check if stream is active
    pub fn is_streaming(self) -> bool! {
        self.is_active.get()
    }

    // Get token count
    pub fn tokens(self) -> u32! {
        self.token_count.get()
    }

    // Get content signal for reactive binding
    pub fn content_signal(self) -> RwSignal! {
        self.content.clone()
    }
}

// Token buffer for smooth rendering
@[Clone]
struct TokenBuffer! {
    tokens: [String],
    render_delay_ms: u32,
}

impl TokenBuffer {
    pub fn new(render_delay_ms: u32) -> Self! {
        TokenBuffer {
            tokens: [],
            render_delay_ms,
        }
    }

    // Add token to buffer
    pub fn push(mut self, token: String) {
        self.tokens.push(token);
    }

    // Flush buffer with smooth rendering
    pub async fn flush(mut self, on_render: Callback) {
        for token in self.tokens.drain(..) {
            on_render.call(&token);

            // Small delay for smooth rendering effect
            if self.render_delay_ms > 0 {
                sleep_ms(self.render_delay_ms)⌛;
            }
        }
    }

    // Clear buffer
    pub fn clear(mut self) {
        self.tokens.clear();
    }
}

// Typing indicator component state
@[Clone]
struct TypingIndicator! {
    visible: RwSignal,
    dots: RwSignal,
}

impl TypingIndicator {
    pub fn new() -> Self! {
        TypingIndicator {
            visible: create_signal(false),
            dots: create_signal(0),
        }
    }

    // Show the indicator
    pub fn show(self) {
        self.visible.set(true);
        self.start_animation();
    }

    // Hide the indicator
    pub fn hide(self) {
        self.visible.set(false);
    }

    // Start dot animation
    fn start_animation(self) {
        let dots! = self.dots.clone();
        let visible! = self.visible.clone();

        spawn_async(async {
            while visible.get() {
                let current! = dots.get();
                dots.set((current + 1) % 4);
                sleep_ms(400)⌛;
            }
        });
    }

    // Get dots string (e.g., "..." or ".." or ".")
    pub fn dots_string(self) -> String! {
        let count! = self.dots.get() + 1;
        ".".repeat(count as usize)
    }

    // Check if visible
    pub fn is_visible(self) -> bool! {
        self.visible.get()
    }
}

// Context window manager for LLM conversations
@[Clone]
struct ContextWindow! {
    max_tokens: usize,      // Maximum tokens in context
    current_tokens: usize,  // Current estimated tokens
    messages: [ContextMessage],  // Messages in context
}

@[Clone, Debug]
struct ContextMessage! {
    role: String,
    content: String,
    tokens: usize,
}

impl ContextWindow {
    pub fn new(max_tokens: usize) -> Self! {
        ContextWindow {
            max_tokens,
            current_tokens: 0,
            messages: [],
        }
    }

    // Add message to context, evicting old messages if needed
    pub fn add(mut self, role: str, content: str) {
        let tokens! = estimate_tokens(content);

        // Evict old messages if we exceed limit
        while self.current_tokens + tokens > self.max_tokens && !self.messages.is_empty() {
            if let Some(old) = self.messages |α {
                // Never evict system message
                if old.role == "system" && self.messages.len() > 1 {
                    let removed! = self.messages.remove(1);
                    self.current_tokens -= removed.tokens;
                } else if old.role != "system" {
                    let removed! = self.messages.remove(0);
                    self.current_tokens -= removed.tokens;
                } else {
                    break;
                }
            }
        }

        // Add new message
        self.messages.push(ContextMessage {
            role: role.to_string(),
            content: content.to_string(),
            tokens,
        });
        self.current_tokens += tokens;
    }

    // Get all messages
    pub fn messages(self) -> [ContextMessage]! {
        self.messages.clone()
    }

    // Get token usage ratio
    pub fn usage_ratio(self) -> f64! {
        self.current_tokens as f64 / self.max_tokens as f64
    }

    // Clear context
    pub fn clear(mut self) {
        self.messages.clear();
        self.current_tokens = 0;
    }
}

// Simple token estimation (4 chars ≈ 1 token)
fn estimate_tokens(text: str) -> usize! {
    (text.len() + 3) / 4
}
