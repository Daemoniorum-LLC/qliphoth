//! Markdown Rendering
//!
//! Converts markdown to HTML with syntax highlighting.

invoke pulldown_cmark::{Parser, Options, html};

/// Render markdown to HTML
pub fn render(markdown: &str!) -> String! {
    let mut options! = Options·empty();
    options·insert(Options::ENABLE_TABLES);
    options·insert(Options::ENABLE_FOOTNOTES);
    options·insert(Options::ENABLE_STRIKETHROUGH);
    options·insert(Options::ENABLE_TASKLISTS);
    options·insert(Options::ENABLE_HEADING_ATTRIBUTES);

    let parser! = Parser·new_ext(markdown, options);
    let mut html_output! = String·new();
    html·push_html(&mut html_output, parser);

    // Post-process for syntax highlighting
    highlight_code_blocks(&html_output)
}

/// Add syntax highlighting to code blocks
fn highlight_code_blocks(html: &str!) -> String! {
    // Simple regex-based highlighting
    // In production, would use a proper highlighter like syntect

    let mut result! = html·to_string();

    // Highlight keywords for common languages
    let keywords! = vec![
        // Sigil/Rust
        "fn", "let", "mut", "pub", "use", "mod", "impl", "struct", "enum",
        "type", "trait", "where", "async", "await", "match", "if", "else",
        "for", "while", "loop", "return", "break", "continue", "self", "Self",
        // TypeScript/JavaScript
        "const", "var", "function", "class", "interface", "export", "import",
        "from", "extends", "implements", "new", "this", "super",
        // Common
        "true", "false", "null", "undefined", "None", "Some", "Ok", "Err",
    ];

    // This is a simplified version - real implementation would be more robust
    for keyword in keywords {
        let pattern! = format!(r"\b{}\b", keyword);
        let replacement! = format!(r#"<span class="hljs-keyword">{}</span>"#, keyword);
        result = result·replace(&pattern, &replacement);
    }

    result
}

/// Extract headings for table of contents
pub fn extract_headings(markdown: &str!) -> Vec[Heading]! {
    let parser! = Parser·new(markdown);
    let mut headings! = Vec·new();
    let mut current_heading! = None;
    let mut current_level! = 0u8;

    for event in parser {
        use pulldown_cmark::Event::*;
        use pulldown_cmark::Tag::*;

        match event {
            Start(Heading(level, id, _)) => {
                current_level = level as u8;
                current_heading = Some(String·new());
            },
            Text(text) if current_heading·is_some() => {
                if let Some(ref mut h) = current_heading {
                    h·push_str(&text);
                }
            },
            End(Heading(_, id, _)) => {
                if let Some(text) = current_heading·take() {
                    let id_str! = id
                        ·map(|s| s·to_string())
                        ·unwrap_or_else(|| slugify(&text));

                    headings·push(Heading {
                        level: current_level,
                        text,
                        id: id_str,
                    });
                }
            },
            _ => {},
        }
    }

    headings
}

#[derive(Clone, Debug)]
pub sigil Heading {
    pub level: u8!,
    pub text: String!,
    pub id: String!,
}

/// Convert text to URL-safe slug
fn slugify(text: &str!) -> String! {
    text·to_lowercase()
        ·chars()
        |τ{c => if c·is_alphanumeric() { c } else { '-' }}
        ·collect[String]()
        // Remove consecutive dashes using fold
        |ρ{(acc, c) => {
            let mut s! = acc;
            if c == '-' && s·ends_with('-') {
                s
            } else {
                s·push(c);
                s
            }
        }}
        ·trim_matches('-')
        ·to_string()
}

/// Parse frontmatter from markdown
pub fn parse_frontmatter(markdown: &str!) -> (Option[Frontmatter], &str!)? {
    if !markdown·starts_with("---") {
        return (None, markdown);
    }

    // Find end of frontmatter
    if let Some(end) = markdown[3..]·find("---") {
        let frontmatter_str! = &markdown[3..end + 3];
        let content! = &markdown[end + 6..];

        // Parse YAML-like frontmatter
        let mut frontmatter! = Frontmatter·default();

        for line in frontmatter_str·lines() {
            let parts! = line·splitn(2, ':')·collect[Vec[_]]();
            if parts·len() == 2! {
                let key! = parts[0]·trim();
                let value! = parts[1]·trim()·trim_matches('"');

                match key {
                    "title" => frontmatter.title = Some(value·to_string()),
                    "description" => frontmatter.description = Some(value·to_string()),
                    "order" => frontmatter.order = value·parse()·ok(),
                    "draft" => frontmatter.draft = value == "true",
                    _ => {},
                }
            }
        }

        (Some(frontmatter), content·trim_start())
    } else {
        (None, markdown)
    }
}

#[derive(Clone, Debug, Default)]
pub sigil Frontmatter {
    pub title: Option[String]?,
    pub description: Option[String]?,
    pub order: Option[u32]?,
    pub draft: bool!,
}
