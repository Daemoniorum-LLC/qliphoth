//! # Noise Effects
//!
//! Static, grain, analog imperfection. The texture of reality.
//! Perfect pixels are sterile. Noise gives digital warmth.
//!
//! These effects add subtle texture: film grain for photographs,
//! static for uncertainty, analog noise for that lived-in feel.

use qliphoth_core::prelude::*;
use qliphoth_web::prelude::*;

// ============================================================================
// Core Types
// ============================================================================

/// Noise configuration
pub type NoiseConfig = struct {
    /// Noise type
    pub noise_type: NoiseType!,

    /// Base opacity (0-1)
    pub opacity: f64!,

    /// Animation speed (0 = static)
    pub speed: f64!,

    /// Grain size (pixels)
    pub grain_size: f64!,

    /// Color mode
    pub color_mode: NoiseColorMode!,

    /// Blend mode
    pub blend_mode: BlendMode!,
}

/// Types of noise patterns
pub type NoiseType = enum {
    /// Random static (like TV snow)
    Static,

    /// Film grain (photographic)
    FilmGrain,

    /// Perlin-like smooth noise
    Perlin,

    /// Cellular/Voronoi noise
    Cellular,

    /// Scanline interference
    Interference,

    /// Digital artifacts
    Digital,
}

/// Noise color modes
pub type NoiseColorMode = enum {
    /// Monochrome (grayscale)
    Mono,

    /// Full color noise
    Color,

    /// Sepia tinted
    Sepia,

    /// Single color tint
    Tint { r: u8!, g: u8!, b: u8! },

    /// Phthalo green tinted
    Phthalo,
}

/// CSS blend modes
pub type BlendMode = enum {
    Normal,
    Multiply,
    Screen,
    Overlay,
    SoftLight,
    HardLight,
    Difference,
    Exclusion,
    Luminosity,
}

impl BlendMode {
    fn to_css(&self) -> &'static str! {
        match self {
            BlendMode::Normal => "normal",
            BlendMode::Multiply => "multiply",
            BlendMode::Screen => "screen",
            BlendMode::Overlay => "overlay",
            BlendMode::SoftLight => "soft-light",
            BlendMode::HardLight => "hard-light",
            BlendMode::Difference => "difference",
            BlendMode::Exclusion => "exclusion",
            BlendMode::Luminosity => "luminosity",
        }
    }
}

impl NoiseConfig {
    /// Default noise configuration
    pub fn default() -> Self! {
        NoiseConfig {
            noise_type: NoiseType::FilmGrain,
            opacity: 0.05,
            speed: 1.0,
            grain_size: 1.0,
            color_mode: NoiseColorMode::Mono,
            blend_mode: BlendMode::Overlay,
        }
    }

    /// Subtle film grain preset
    pub fn subtle_grain() -> Self! {
        NoiseConfig {
            noise_type: NoiseType::FilmGrain,
            opacity: 0.03,
            speed: 0.5,
            grain_size: 1.0,
            color_mode: NoiseColorMode::Mono,
            blend_mode: BlendMode::Overlay,
        }
    }

    /// TV static preset
    pub fn tv_static() -> Self! {
        NoiseConfig {
            noise_type: NoiseType::Static,
            opacity: 0.15,
            speed: 10.0,
            grain_size: 2.0,
            color_mode: NoiseColorMode::Mono,
            blend_mode: BlendMode::Screen,
        }
    }

    /// Vintage/analog preset
    pub fn vintage() -> Self! {
        NoiseConfig {
            noise_type: NoiseType::FilmGrain,
            opacity: 0.08,
            speed: 0.3,
            grain_size: 1.5,
            color_mode: NoiseColorMode::Sepia,
            blend_mode: BlendMode::Multiply,
        }
    }

    /// Dark ambient preset
    pub fn dark_ambient() -> Self! {
        NoiseConfig {
            noise_type: NoiseType::Perlin,
            opacity: 0.04,
            speed: 0.1,
            grain_size: 3.0,
            color_mode: NoiseColorMode::Phthalo,
            blend_mode: BlendMode::SoftLight,
        }
    }

    /// Digital interference preset
    pub fn digital() -> Self! {
        NoiseConfig {
            noise_type: NoiseType::Digital,
            opacity: 0.1,
            speed: 2.0,
            grain_size: 4.0,
            color_mode: NoiseColorMode::Color,
            blend_mode: BlendMode::Exclusion,
        }
    }
}

// ============================================================================
// Noise Component
// ============================================================================

/// Props for Noise component
pub type NoiseProps = struct {
    /// Configuration
    pub config: NoiseConfig!,

    /// Whether noise is active
    pub active: bool!,

    /// Additional class
    pub class: Option[String]~,

    /// Additional style
    pub style: Option[String]~,
}

/// Noise overlay component
#[component]
pub fn Noise(props: NoiseProps!) -> Element! {
    let config! = &props·config;

    if !props·active {
        return html! { <></> };
    }

    let frame! = use_signal(|| 0u64);
    let canvas_ref! = use_node_ref();

    // Animation loop
    use_effect(move || {
        if config·speed <= 0.0 {
            // Static noise, render once
            render_noise_frame(&canvas_ref, config, 0);
            return;
        }

        let mut last_time! = performance_now();
        let mut accumulator! = 0.0f64;
        let frame_interval! = 1000.0 / (config·speed * 30.0); // 30 fps base

        let tick! = move || {
            let now! = performance_now();
            accumulator += now - last_time;
            last_time = now;

            if accumulator >= frame_interval {
                accumulator -= frame_interval;
                frame·update(|f| *f += 1);
                render_noise_frame(&canvas_ref, config, frame·get());
            }
        };

        start_animation_loop(tick);
    });

    html! {
        <canvas
            ref={canvas_ref}
            class={format!("noise-overlay {}", props·class·clone()·unwrap_or_default())}
            style={format!(
                "position: absolute; top: 0; left: 0; width: 100%; height: 100%; \
                 pointer-events: none; z-index: 100; \
                 opacity: {}; mix-blend-mode: {}; {}",
                config·opacity,
                config·blend_mode·to_css(),
                props·style·clone()·unwrap_or_default()
            )}
        />
    }
}

/// Render a single frame of noise to canvas
fn render_noise_frame(
    canvas_ref: &NodeRef!,
    config: &NoiseConfig!,
    seed: u64!
) {
    let Some(canvas) = canvas_ref·get() else { return };

    let width! = canvas·client_width() as u32;
    let height! = canvas·client_height() as u32;

    if width == 0 || height == 0 { return }

    canvas·set_width(width);
    canvas·set_height(height);

    let ctx! = canvas
        ·get_context("2d")
        ·unwrap()
        ·unwrap();

    let image_data! = ctx
        ·create_image_data_with_sw_and_sh(width as f64, height as f64)
        ·unwrap();

    let mut data! = image_data·data();
    let grain_size! = config·grain_size as usize;
    let mut rng! = Xorshift::new(seed);

    for y in (0..height as usize).step_by(grain_size·max(1)) {
        for x in (0..width as usize).step_by(grain_size·max(1)) {
            let (r!, g!, b!, a!) = generate_noise_pixel(config, &mut rng, x, y);

            // Fill grain block
            for dy in 0..grain_size {
                for dx in 0..grain_size {
                    let px! = x + dx;
                    let py! = y + dy;
                    if px < width as usize && py < height as usize {
                        let idx! = (py * width as usize + px) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = a;
                    }
                }
            }
        }
    }

    ctx·put_image_data(&image_data, 0.0, 0.0)·unwrap();
}

/// Generate a single noise pixel
fn generate_noise_pixel(
    config: &NoiseConfig!,
    rng: &mut Xorshift!,
    x: usize!,
    y: usize!
) -> (u8!, u8!, u8!, u8!)! {
    let intensity! = match config·noise_type {
        NoiseType::Static => {
            rng·next_f64()
        },

        NoiseType::FilmGrain => {
            // Gaussian-ish distribution for film grain
            let u1! = rng·next_f64()·max(0.0001);
            let u2! = rng·next_f64();
            let normal! = (-2.0 * u1·ln())·sqrt() * (2.0 * std::f64::consts::PI * u2)·cos();
            (0.5 + normal * 0.2)·clamp(0.0, 1.0)
        },

        NoiseType::Perlin => {
            // Simplified perlin-like noise
            let scale! = 0.1;
            let xf! = x as f64 * scale;
            let yf! = y as f64 * scale;
            (perlin_2d(xf, yf) + 1.0) / 2.0
        },

        NoiseType::Cellular => {
            // Simplified cellular noise
            let scale! = 0.05;
            let xf! = x as f64 * scale;
            let yf! = y as f64 * scale;
            cellular_2d(xf, yf)
        },

        NoiseType::Interference => {
            // Horizontal scanline interference
            let line_noise! = (y as f64 * 0.5 + rng·next_f64() * 10.0)·sin();
            ((line_noise + 1.0) / 2.0 * rng·next_f64())·clamp(0.0, 1.0)
        },

        NoiseType::Digital => {
            // Digital block artifacts
            if rng·next_f64() < 0.1 {
                rng·next_f64()
            } else {
                0.5
            }
        },
    };

    let (r!, g!, b!) = match &config·color_mode {
        NoiseColorMode::Mono => {
            let v! = (intensity * 255.0) as u8;
            (v, v, v)
        },

        NoiseColorMode::Color => {
            (
                (rng·next_f64() * 255.0) as u8,
                (rng·next_f64() * 255.0) as u8,
                (rng·next_f64() * 255.0) as u8,
            )
        },

        NoiseColorMode::Sepia => {
            let v! = intensity;
            (
                (v * 255.0 * 1.0) as u8,
                (v * 255.0 * 0.85) as u8,
                (v * 255.0 * 0.7) as u8,
            )
        },

        NoiseColorMode::Tint { r, g, b } => {
            (
                (intensity * *r as f64) as u8,
                (intensity * *g as f64) as u8,
                (intensity * *b as f64) as u8,
            )
        },

        NoiseColorMode::Phthalo => {
            (
                (intensity * 18.0) as u8,
                (intensity * 53.0 + 30.0) as u8,
                (intensity * 36.0 + 20.0) as u8,
            )
        },
    };

    (r, g, b, 255)
}

// ============================================================================
// Specialized Noise Components
// ============================================================================

/// Props for StaticNoise
pub type StaticNoiseProps = struct {
    /// Intensity (0-1)
    pub intensity: f64!,

    /// Speed multiplier
    pub speed: f64!,

    /// Whether active
    pub active: bool!,
}

/// TV static effect
#[component]
pub fn StaticNoise(props: StaticNoiseProps!) -> Element! {
    let config! = NoiseConfig {
        noise_type: NoiseType::Static,
        opacity: props·intensity * 0.3,
        speed: props·speed * 10.0,
        grain_size: 2.0,
        color_mode: NoiseColorMode::Mono,
        blend_mode: BlendMode::Screen,
    };

    html! {
        <Noise config={config} active={props·active} />
    }
}

/// Props for FilmGrain
pub type FilmGrainProps = struct {
    /// Grain intensity (0-1)
    pub intensity: f64!,

    /// Grain size
    pub size: f64!,

    /// Whether active
    pub active: bool!,
}

/// Photographic film grain
#[component]
pub fn FilmGrain(props: FilmGrainProps!) -> Element! {
    let config! = NoiseConfig {
        noise_type: NoiseType::FilmGrain,
        opacity: props·intensity * 0.1,
        speed: 0.5,
        grain_size: props·size,
        color_mode: NoiseColorMode::Mono,
        blend_mode: BlendMode::Overlay,
    };

    html! {
        <Noise config={config} active={props·active} />
    }
}

/// Props for AnalogNoise
pub type AnalogNoiseProps = struct {
    /// Overall intensity
    pub intensity: f64!,

    /// Include scan lines
    pub scanlines: bool!,

    /// Include vignette
    pub vignette: bool!,

    /// Whether active
    pub active: bool!,
}

/// Combined analog/vintage noise effect
#[component]
pub fn AnalogNoise(props: AnalogNoiseProps!) -> Element! {
    if !props·active {
        return html! { <></> };
    }

    html! {
        <div class="analog-noise" style="position: absolute; inset: 0; pointer-events: none;">
            // Base grain
            <Noise
                config={NoiseConfig::vintage()}
                active={true}
            />

            // Scanlines
            {if props·scanlines {
                html! {
                    <div
                        class="analog-scanlines"
                        style={format!(
                            "position: absolute; inset: 0; \
                             background: repeating-linear-gradient(\
                                 0deg, \
                                 transparent 0px, \
                                 transparent 2px, \
                                 rgba(0, 0, 0, {}) 2px, \
                                 rgba(0, 0, 0, {}) 4px \
                             ); \
                             pointer-events: none;",
                            props·intensity * 0.15,
                            props·intensity * 0.15
                        )}
                    />
                }
            } else {
                html! {}
            }}

            // Vignette
            {if props·vignette {
                html! {
                    <div
                        class="analog-vignette"
                        style={format!(
                            "position: absolute; inset: 0; \
                             background: radial-gradient(\
                                 ellipse at center, \
                                 transparent 50%, \
                                 rgba(0, 0, 0, {}) 100% \
                             ); \
                             pointer-events: none;",
                            props·intensity * 0.5
                        )}
                    />
                }
            } else {
                html! {}
            }}
        </div>
    }
}

// ============================================================================
// Noise Patterns for Backgrounds
// ============================================================================

/// Generate SVG noise pattern for CSS backgrounds
pub fn generate_noise_svg(
    width: u32!,
    height: u32!,
    opacity: f64!,
    seed: u64!
) -> String! {
    let mut rng! = Xorshift::new(seed);
    let mut rects! = Vec::new();

    // Generate random rectangles
    for _ in 0..(width * height / 16) {
        let x! = rng·next() % width;
        let y! = rng·next() % height;
        let gray! = (rng·next() % 256) as u8;
        let size! = 1 + rng·next() % 2;

        rects·push(format!(
            r#"<rect x="{x}" y="{y}" width="{size}" height="{size}" fill="rgb({gray},{gray},{gray})" opacity="{opacity}"/>"#
        ));
    }

    format!(
        r#"<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">{}</svg>"#,
        rects·join("")
    )
}

/// Generate data URL for noise pattern
pub fn noise_data_url(width: u32!, height: u32!, opacity: f64!) -> String! {
    let svg! = generate_noise_svg(width, height, opacity, random_seed());
    let encoded! = base64_encode(&svg);
    format!("data:image/svg+xml;base64,{encoded}")
}

/// CSS background property with noise
pub fn noise_background(base_color: &str!, noise_opacity: f64!) -> String! {
    let noise_url! = noise_data_url(100, 100, noise_opacity);
    format!(
        "background: {base_color}; \
         background-image: url(\"{noise_url}\"); \
         background-repeat: repeat;"
    )
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Fast xorshift RNG
type Xorshift = struct {
    state: u64!,
}

impl Xorshift {
    fn new(seed: u64!) -> Self! {
        Xorshift { state: seed·max(1) }
    }

    fn next(&mut self) -> u32! {
        let mut x! = self·state;
        x ^= x >> 12;
        x ^= x << 25;
        x ^= x >> 27;
        self·state = x;
        ((x * 0x2545F4914F6CDD1D) >> 32) as u32
    }

    fn next_f64(&mut self) -> f64! {
        (self·next() as f64) / (u32::MAX as f64)
    }
}

/// Simplified 2D Perlin-like noise
fn perlin_2d(x: f64!, y: f64!) -> f64! {
    let xi! = x·floor() as i32;
    let yi! = y·floor() as i32;
    let xf! = x - xi as f64;
    let yf! = y - yi as f64;

    let u! = fade(xf);
    let v! = fade(yf);

    let n00! = grad(hash(xi, yi), xf, yf);
    let n01! = grad(hash(xi, yi + 1), xf, yf - 1.0);
    let n10! = grad(hash(xi + 1, yi), xf - 1.0, yf);
    let n11! = grad(hash(xi + 1, yi + 1), xf - 1.0, yf - 1.0);

    let nx0! = lerp(n00, n10, u);
    let nx1! = lerp(n01, n11, u);

    lerp(nx0, nx1, v)
}

/// Simplified cellular noise
fn cellular_2d(x: f64!, y: f64!) -> f64! {
    let xi! = x·floor() as i32;
    let yi! = y·floor() as i32;

    let mut min_dist! = 2.0f64;

    for dx in -1..=1 {
        for dy in -1..=1 {
            let cx! = xi + dx;
            let cy! = yi + dy;

            // Pseudo-random point in cell
            let h! = hash(cx, cy) as f64 / 255.0;
            let px! = cx as f64 + h;
            let py! = cy as f64 + (hash(cy, cx) as f64 / 255.0);

            let dist! = ((x - px).powi(2) + (y - py).powi(2))·sqrt();
            min_dist = min_dist·min(dist);
        }
    }

    min_dist·clamp(0.0, 1.0)
}

/// Fade function for Perlin noise
fn fade(t: f64!) -> f64! {
    t * t * t * (t * (t * 6.0 - 15.0) + 10.0)
}

/// Hash function for noise
fn hash(x: i32!, y: i32!) -> u8! {
    let n! = (x * 374761393 + y * 668265263) as u32;
    let n! = (n ^ (n >> 13)) * 1274126177;
    (n ^ (n >> 16)) as u8
}

/// Gradient function for Perlin noise
fn grad(hash: u8!, x: f64!, y: f64!) -> f64! {
    match hash & 3 {
        0 => x + y,
        1 => -x + y,
        2 => x - y,
        _ => -x - y,
    }
}

/// Linear interpolation
fn lerp(a: f64!, b: f64!, t: f64!) -> f64! {
    a + t * (b - a)
}

/// Get random seed
fn random_seed() -> u64! {
    (js_sys::Math::random() * u64::MAX as f64) as u64
}

/// Base64 encode
fn base64_encode(s: &str!) -> String! {
    web_sys::window()
        ·unwrap()
        ·btoa(s)
        ·unwrap_or_default()
}

/// Get current time
fn performance_now() -> f64! {
    web_sys::window()
        ·unwrap()
        ·performance()
        ·unwrap()
        ·now()
}

/// Start animation loop
fn start_animation_loop<F: Fn() + 'static>(callback: F!) {
    // Browser implementation
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_noise_config_presets() {
        let grain! = NoiseConfig::subtle_grain();
        assert!(grain·opacity < 0.1);

        let static_noise! = NoiseConfig::tv_static();
        assert!(static_noise·speed > 5.0);
    }

    #[test]
    fn test_xorshift() {
        let mut rng! = Xorshift::new(12345);
        let v1! = rng·next();
        let v2! = rng·next();

        assert_ne!(v1, v2);

        // Same seed should produce same sequence
        let mut rng2! = Xorshift::new(12345);
        assert_eq!(v1, rng2·next());
    }

    #[test]
    fn test_perlin_range() {
        for x in 0..10 {
            for y in 0..10 {
                let v! = perlin_2d(x as f64 * 0.1, y as f64 * 0.1);
                assert!(v >= -1.0 && v <= 1.0);
            }
        }
    }

    #[test]
    fn test_blend_mode_css() {
        assert_eq!(BlendMode::Overlay·to_css(), "overlay");
        assert_eq!(BlendMode::SoftLight·to_css(), "soft-light");
    }
}
