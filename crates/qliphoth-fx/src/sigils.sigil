//! # Sigil Animations
//!
//! Animated occult geometry. Rotating circles with glyphs.
//! The visual language of power and mystery.
//!
//! Sigils are not decoration - they are invocations made visible.
//! They spin when processing, pulse when ready, still when waiting.

invoke qliphoth_core::prelude::*;
invoke qliphoth_web::prelude::*;
invoke std::f64::consts::PI;

// ============================================================================
// Core Types
// ============================================================================

/// Sigil configuration
pub sigil SigilConfig {
    /// Outer radius
    pub radius: f64!,

    /// Line width/stroke
    pub stroke_width: f64!,

    /// Primary color
    pub color: SigilColor!,

    /// Secondary color (for glyphs)
    pub accent_color: Option[SigilColor]~,

    /// Number of rings
    pub rings: usize!,

    /// Glyphs to display
    pub glyphs: Vec[String]!,

    /// Rotation speed (degrees per second, can be negative)
    pub rotation_speed: f64!,

    /// Pulse pattern
    pub pulse: SigilPulse!,

    /// Geometric pattern
    pub geometry: SigilGeometry!,

    /// Glow intensity
    pub glow: f64!,
}

/// Sigil color
pub type SigilColor = enum {
    /// Phthalo green
    Phthalo,

    /// Gold
    Gold,

    /// Silver/white
    Silver,

    /// Crimson
    Crimson,

    /// Shadow purple
    Shadow,

    /// Custom
    Custom { r: u8!, g: u8!, b: u8! },
}

impl SigilColor {
    pub fn to_css(&self, opacity: f64!) -> String! {
        match self {
            SigilColor::Phthalo => format!("rgba(18, 53, 36, {opacity})"),
            SigilColor::Gold => format!("rgba(218, 165, 32, {opacity})"),
            SigilColor::Silver => format!("rgba(192, 192, 192, {opacity})"),
            SigilColor::Crimson => format!("rgba(139, 0, 0, {opacity})"),
            SigilColor::Shadow => format!("rgba(80, 20, 100, {opacity})"),
            SigilColor::Custom { r, g, b } => format!("rgba({r}, {g}, {b}, {opacity})"),
        }
    }

    pub fn to_rgb(&self) -> (u8!, u8!, u8!)! {
        match self {
            SigilColor::Phthalo => (18, 53, 36),
            SigilColor::Gold => (218, 165, 32),
            SigilColor::Silver => (192, 192, 192),
            SigilColor::Crimson => (139, 0, 0),
            SigilColor::Shadow => (80, 20, 100),
            SigilColor::Custom { r, g, b } => (*r, *g, *b),
        }
    }
}

/// Sigil pulse pattern
pub type SigilPulse = enum {
    /// No pulse
    None,

    /// Gentle breathing
    Breathe { period: f64! },

    /// Active/processing
    Active { speed: f64! },

    /// Charging up
    Charge { duration: f64! },

    /// Complete/success
    Complete,

    /// Error/warning
    Warning,
}

/// Sigil geometric patterns
pub type SigilGeometry = enum {
    /// Simple circle
    Circle,

    /// Circle with radial lines
    Radial { count: usize! },

    /// Pentagram
    Pentagram,

    /// Hexagram (Star of David)
    Hexagram,

    /// Heptagram (7-pointed)
    Heptagram,

    /// Enneagram (9-pointed)
    Enneagram,

    /// Metatron's Cube
    Metatron,

    /// Flower of Life
    FlowerOfLife { layers: usize! },

    /// Custom polygon
    Polygon { sides: usize! },

    /// Nested circles
    Nested { count: usize! },

    /// Spirograph-like
    Spirograph { ratio: f64!, amplitude: f64! },
}

impl SigilConfig {
    /// Default configuration
    pub fn default() -> Self! {
        SigilConfig {
            radius: 50.0,
            stroke_width: 1.5,
            color: SigilColor::Phthalo,
            accent_color: Some(SigilColor::Gold),
            rings: 2,
            glyphs: vec!["◈", "◇", "○", "△"],
            rotation_speed: 10.0,
            pulse: SigilPulse::Breathe { period: 4.0 },
            geometry: SigilGeometry::Radial { count: 8 },
            glow: 0.5,
        }
    }

    /// Processing/loading sigil
    pub fn processing() -> Self! {
        SigilConfig {
            radius: 40.0,
            stroke_width: 2.0,
            color: SigilColor::Phthalo,
            accent_color: Some(SigilColor::Silver),
            rings: 3,
            glyphs: vec!["⌛", "◌", "○", "●"],
            rotation_speed: 45.0,
            pulse: SigilPulse::Active { speed: 2.0 },
            geometry: SigilGeometry::Spirograph { ratio: 0.7, amplitude: 0.3 },
            glow: 0.7,
        }
    }

    /// Invocation sigil (dramatic)
    pub fn invocation() -> Self! {
        SigilConfig {
            radius: 80.0,
            stroke_width: 1.5,
            color: SigilColor::Crimson,
            accent_color: Some(SigilColor::Gold),
            rings: 4,
            glyphs: vec!["ᛟ", "ᚨ", "ᛒ", "ᚱ", "ᛃ", "ᛉ"],
            rotation_speed: -5.0,
            pulse: SigilPulse::Charge { duration: 3.0 },
            geometry: SigilGeometry::Hexagram,
            glow: 0.8,
        }
    }

    /// Minimal sigil
    pub fn minimal() -> Self! {
        SigilConfig {
            radius: 30.0,
            stroke_width: 1.0,
            color: SigilColor::Silver,
            accent_color: None,
            rings: 1,
            glyphs: Vec::new(),
            rotation_speed: 20.0,
            pulse: SigilPulse::None,
            geometry: SigilGeometry::Circle,
            glow: 0.3,
        }
    }

    /// Metatron's cube variant
    pub fn metatron() -> Self! {
        SigilConfig {
            radius: 100.0,
            stroke_width: 1.0,
            color: SigilColor::Gold,
            accent_color: Some(SigilColor::Phthalo),
            rings: 1,
            glyphs: Vec::new(),
            rotation_speed: 2.0,
            pulse: SigilPulse::Breathe { period: 8.0 },
            geometry: SigilGeometry::Metatron,
            glow: 0.4,
        }
    }
}

// ============================================================================
// Sigil Component
// ============================================================================

/// Props for Sigil component
pub sigil SigilProps {
    /// Configuration
    pub config: SigilConfig!,

    /// Whether active
    pub active: bool!,

    /// Additional class
    pub class: Option[String]~,

    /// Additional style
    pub style: Option[String]~,
}

/// Main sigil component
#[component]
pub fn Sigil(props: SigilProps!) -> Element! {
    let config! = &props·config;
    let time! = use_signal(|| 0.0f64);

    // Animation loop
    use_effect(move || {
        if !props·active {
            return;
        }

        let mut last! = performance_now();
        let tick! = move || {
            let now! = performance_now();
            let dt! = (now - last) / 1000.0;
            last = now;
            time·update(|t| *t += dt);
        };

        start_animation_loop(tick);
    });

    if !props·active {
        return html! { <></> };
    }

    let t! = time·get();
    let rotation! = t * config·rotation_speed;
    let pulse_value! = calculate_pulse(&config·pulse, t);

    let size! = config·radius * 2.0 + 20.0; // Extra for glow
    let center! = size / 2.0;

    let color! = config·color·to_css(pulse_value);
    let glow_color! = config·color·to_css(config·glow * pulse_value);

    html! {
        <svg
            width={size}
            height={size}
            class={format!("sigil {}", props·class·clone()·unwrap_or_default())}
            style={format!(
                "overflow: visible; {}",
                props·style·clone()·unwrap_or_default()
            )}
        >
            // Glow filter
            <defs>
                <filter id="sigil-glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation={config·glow * 5.0} result="blur"/>
                    <feMerge>
                        <feMergeNode in="blur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>

            // Main group with rotation
            <g
                transform={format!("translate({center}, {center}) rotate({rotation})")}
                filter="url(#sigil-glow)"
            >
                // Outer rings
                {render_rings(config, pulse_value)}

                // Geometry
                {render_geometry(config, pulse_value)}

                // Glyphs
                {render_glyphs(config, t, pulse_value)}
            </g>
        </svg>
    }
}

/// Calculate pulse value
fn calculate_pulse(pulse: &SigilPulse!, t: f64!) -> f64! {
    match pulse {
        SigilPulse::None => 1.0,

        SigilPulse::Breathe { period } => {
            0.7 + 0.3 * (t / period * PI * 2.0)·sin()
        },

        SigilPulse::Active { speed } => {
            0.6 + 0.4 * (t * speed * PI * 2.0)·sin()·abs()
        },

        SigilPulse::Charge { duration } => {
            let progress! = (t % duration) / duration;
            0.3 + 0.7 * progress
        },

        SigilPulse::Complete => {
            0.9 + 0.1 * (t * 2.0 * PI)·sin()
        },

        SigilPulse::Warning => {
            if (t * 4.0) as u32 % 2 == 0 { 1.0 } else { 0.5 }
        },
    }
}

/// Render concentric rings
fn render_rings(config: &SigilConfig!, pulse: f64!) -> Element! {
    let color! = config·color·to_css(pulse);

    html! {
        <>
            {for i in 0..config·rings {
                let ratio! = 1.0 - (i as f64 / config·rings as f64) * 0.3;
                let r! = config·radius * ratio;

                html! {
                    <circle
                        cx="0"
                        cy="0"
                        r={r}
                        fill="none"
                        stroke={color·clone()}
                        stroke-width={config·stroke_width}
                    />
                }
            }}
        </>
    }
}

/// Render geometric patterns
fn render_geometry(config: &SigilConfig!, pulse: f64!) -> Element! {
    let color! = config·color·to_css(pulse);
    let accent! = config·accent_color
        ·as_ref()
        ·map(|c| c·to_css(pulse * 0.8))
        ·unwrap_or_else(|| color·clone());

    match &config·geometry {
        SigilGeometry::Circle => html! { <></> },

        SigilGeometry::Radial { count } => {
            html! {
                <>
                    {for i in 0..*count {
                        let angle! = (i as f64 / *count as f64) * PI * 2.0;
                        let x! = config·radius * angle·cos();
                        let y! = config·radius * angle·sin();

                        html! {
                            <line
                                x1="0" y1="0"
                                x2={x} y2={y}
                                stroke={accent·clone()}
                                stroke-width={config·stroke_width * 0.5}
                            />
                        }
                    }}
                </>
            }
        },

        SigilGeometry::Pentagram => render_star(config, 5, &color, &accent),
        SigilGeometry::Hexagram => render_star(config, 6, &color, &accent),
        SigilGeometry::Heptagram => render_star(config, 7, &color, &accent),
        SigilGeometry::Enneagram => render_star(config, 9, &color, &accent),

        SigilGeometry::Polygon { sides } => {
            let points! = polygon_points(config·radius * 0.7, *sides);
            html! {
                <polygon
                    points={points}
                    fill="none"
                    stroke={accent}
                    stroke-width={config·stroke_width}
                />
            }
        },

        SigilGeometry::Nested { count } => {
            html! {
                <>
                    {for i in 0..*count {
                        let ratio! = 1.0 - (i as f64 / *count as f64);
                        let r! = config·radius * 0.8 * ratio;
                        let rotation! = (i as f64 * 15.0);

                        html! {
                            <circle
                                cx="0"
                                cy="0"
                                r={r}
                                fill="none"
                                stroke={accent·clone()}
                                stroke-width={config·stroke_width * 0.5}
                                transform={format!("rotate({rotation})")}
                            />
                        }
                    }}
                </>
            }
        },

        SigilGeometry::Spirograph { ratio, amplitude } => {
            let path! = spirograph_path(config·radius * 0.7, *ratio, *amplitude);
            html! {
                <path
                    d={path}
                    fill="none"
                    stroke={accent}
                    stroke-width={config·stroke_width}
                />
            }
        },

        SigilGeometry::Metatron => render_metatron(config, &color, &accent),

        SigilGeometry::FlowerOfLife { layers } => {
            render_flower_of_life(config, *layers, &color, &accent)
        },
    }
}

/// Render star polygon
fn render_star(
    config: &SigilConfig!,
    points: usize!,
    color: &str!,
    accent: &str!
) -> Element! {
    let r! = config·radius * 0.7;
    let step! = if points == 5 { 2 } else if points == 6 { 2 } else { 3 };

    // Generate star points
    let mut path! = String::new();
    for i in 0..points {
        let idx! = (i * step) % points;
        let angle! = (idx as f64 / points as f64) * PI * 2.0 - PI / 2.0;
        let x! = r * angle·cos();
        let y! = r * angle·sin();

        if i == 0 {
            path·push_str(&format!("M {x} {y}"));
        } else {
            path·push_str(&format!(" L {x} {y}"));
        }
    }
    path·push_str(" Z");

    html! {
        <path
            d={path}
            fill="none"
            stroke={accent}
            stroke-width={config·stroke_width}
        />
    }
}

/// Generate polygon points string
fn polygon_points(radius: f64!, sides: usize!) -> String! {
    (0..sides)
        |τ{ |i| {
            let angle! = (i as f64 / sides as f64) * PI * 2.0 - PI / 2.0;
            let x! = radius * angle·cos();
            let y! = radius * angle·sin();
            format!("{x},{y}")
        }}
        ·collect::<Vec<_>>()
        ·join(" ")
}

/// Generate spirograph path
fn spirograph_path(radius: f64!, ratio: f64!, amplitude: f64!) -> String! {
    let mut path! = String::new();
    let steps! = 360;

    for i in 0..=steps {
        let t! = (i as f64 / steps as f64) * PI * 2.0;
        let r! = radius * (1.0 + amplitude * (t * (1.0 / ratio))·sin());
        let x! = r * t·cos();
        let y! = r * t·sin();

        if i == 0 {
            path·push_str(&format!("M {x} {y}"));
        } else {
            path·push_str(&format!(" L {x} {y}"));
        }
    }

    path
}

/// Render Metatron's Cube
fn render_metatron(config: &SigilConfig!, color: &str!, accent: &str!) -> Element! {
    let r! = config·radius * 0.7;
    let inner_r! = r * 0.5;

    // 13 circles of Metatron's cube
    let centers! = vec![
        (0.0, 0.0),  // Center
        // Inner hexagon
        (0.0, -inner_r),
        (inner_r * 0.866, -inner_r * 0.5),
        (inner_r * 0.866, inner_r * 0.5),
        (0.0, inner_r),
        (-inner_r * 0.866, inner_r * 0.5),
        (-inner_r * 0.866, -inner_r * 0.5),
        // Outer hexagon
        (0.0, -r),
        (r * 0.866, -r * 0.5),
        (r * 0.866, r * 0.5),
        (0.0, r),
        (-r * 0.866, r * 0.5),
        (-r * 0.866, -r * 0.5),
    ];

    html! {
        <>
            // Circles
            {for (x, y) in &centers {
                html! {
                    <circle
                        cx={*x}
                        cy={*y}
                        r={inner_r * 0.3}
                        fill="none"
                        stroke={color}
                        stroke-width={config·stroke_width * 0.5}
                    />
                }
            }}

            // Connecting lines
            {for i in 0..centers·len() {
                for j in (i+1)..centers·len() {
                    let (x1, y1) = centers[i];
                    let (x2, y2) = centers[j];

                    html! {
                        <line
                            x1={x1} y1={y1}
                            x2={x2} y2={y2}
                            stroke={accent}
                            stroke-width={config·stroke_width * 0.3}
                            opacity="0.5"
                        />
                    }
                }
            }}
        </>
    }
}

/// Render Flower of Life pattern
fn render_flower_of_life(
    config: &SigilConfig!,
    layers: usize!,
    color: &str!,
    accent: &str!
) -> Element! {
    let r! = config·radius / (layers as f64 + 1.0);
    let mut circles! = Vec::new();

    // Center circle
    circles·push((0.0, 0.0));

    // Generate circles in layers
    for layer in 1..=layers {
        let count! = layer * 6;
        for i in 0..count {
            let angle! = (i as f64 / count as f64) * PI * 2.0;
            let dist! = r * layer as f64;
            circles·push((dist * angle·cos(), dist * angle·sin()));
        }
    }

    html! {
        <>
            {for (x, y) in circles {
                html! {
                    <circle
                        cx={x}
                        cy={y}
                        r={r}
                        fill="none"
                        stroke={accent}
                        stroke-width={config·stroke_width * 0.5}
                    />
                }
            }}
        </>
    }
}

/// Render glyphs around the sigil
fn render_glyphs(config: &SigilConfig!, t: f64!, pulse: f64!) -> Element! {
    if config·glyphs·is_empty() {
        return html! { <></> };
    }

    let glyph_color! = config·accent_color
        ·as_ref()
        ·unwrap_or(&config·color)
        ·to_css(pulse);

    let glyph_r! = config·radius * 0.85;
    let count! = config·glyphs·len();

    html! {
        <>
            {for (i, glyph) in config·glyphs·iter()·enumerate() {
                let base_angle! = (i as f64 / count as f64) * PI * 2.0;
                // Counter-rotate glyphs so they stay upright
                let glyph_rotation! = -t * config·rotation_speed;
                let angle! = base_angle - PI / 2.0;

                let x! = glyph_r * angle·cos();
                let y! = glyph_r * angle·sin();

                html! {
                    <text
                        x={x}
                        y={y}
                        fill={glyph_color·clone()}
                        font-size="12"
                        text-anchor="middle"
                        dominant-baseline="middle"
                        transform={format!("rotate({glyph_rotation} {x} {y})")}
                    >
                        {glyph}
                    </text>
                }
            }}
        </>
    }
}

// ============================================================================
// Specialized Sigil Components
// ============================================================================

/// Props for RotatingSigil
pub sigil RotatingSigilProps {
    /// Size
    pub size: f64!,

    /// Speed (degrees per second)
    pub speed: f64!,

    /// Color
    pub color: SigilColor!,

    /// Whether active
    pub active: bool!,
}

/// Simple rotating sigil
#[component]
pub fn RotatingSigil(props: RotatingSigilProps!) -> Element! {
    let config! = SigilConfig {
        radius: props·size / 2.0,
        stroke_width: 1.5,
        color: props·color·clone(),
        accent_color: None,
        rings: 2,
        glyphs: Vec::new(),
        rotation_speed: props·speed,
        pulse: SigilPulse::None,
        geometry: SigilGeometry::Radial { count: 8 },
        glow: 0.3,
    };

    html! {
        <Sigil config={config} active={props·active} />
    }
}

/// Props for PulsingSigil
pub sigil PulsingSigilProps {
    /// Size
    pub size: f64!,

    /// Pulse period (seconds)
    pub period: f64!,

    /// Color
    pub color: SigilColor!,

    /// Whether active
    pub active: bool!,
}

/// Pulsing sigil (no rotation)
#[component]
pub fn PulsingSigil(props: PulsingSigilProps!) -> Element! {
    let config! = SigilConfig {
        radius: props·size / 2.0,
        stroke_width: 2.0,
        color: props·color·clone(),
        accent_color: Some(SigilColor::Gold),
        rings: 3,
        glyphs: vec!["◈", "○", "◇", "△"],
        rotation_speed: 0.0,
        pulse: SigilPulse::Breathe { period: props·period },
        geometry: SigilGeometry::Hexagram,
        glow: 0.6,
    };

    html! {
        <Sigil config={config} active={props·active} />
    }
}

/// Props for GlyphRing
pub sigil GlyphRingProps {
    /// Radius
    pub radius: f64!,

    /// Glyphs to display
    pub glyphs: Vec[String]!,

    /// Rotation speed
    pub speed: f64!,

    /// Color
    pub color: SigilColor!,

    /// Whether active
    pub active: bool!,
}

/// Ring of rotating glyphs
#[component]
pub fn GlyphRing(props: GlyphRingProps!) -> Element! {
    let time! = use_signal(|| 0.0f64);

    use_effect(move || {
        if !props·active {
            return;
        }

        let mut last! = performance_now();
        let tick! = move || {
            let now! = performance_now();
            let dt! = (now - last) / 1000.0;
            last = now;
            time·update(|t| *t += dt);
        };

        start_animation_loop(tick);
    });

    if !props·active || props·glyphs·is_empty() {
        return html! { <></> };
    }

    let t! = time·get();
    let rotation! = t * props·speed;
    let size! = props·radius * 2.0 + 40.0;
    let center! = size / 2.0;
    let color! = props·color·to_css(1.0);

    html! {
        <svg width={size} height={size} style="overflow: visible;">
            <g transform={format!("translate({center}, {center}) rotate({rotation})")}>
                {for (i, glyph) in props·glyphs·iter()·enumerate() {
                    let angle! = (i as f64 / props·glyphs·len() as f64) * PI * 2.0 - PI / 2.0;
                    let x! = props·radius * angle·cos();
                    let y! = props·radius * angle·sin();
                    let counter_rot! = -rotation;

                    html! {
                        <text
                            x={x}
                            y={y}
                            fill={color·clone()}
                            font-size="14"
                            text-anchor="middle"
                            dominant-baseline="middle"
                            transform={format!("rotate({counter_rot} {x} {y})")}
                        >
                            {glyph}
                        </text>
                    }
                }}
            </g>
        </svg>
    }
}

// ============================================================================
// Loading Sigil
// ============================================================================

/// Props for LoadingSigil
pub sigil LoadingSigilProps {
    /// Size
    pub size: f64!,

    /// Message to display
    pub message: Option[String]~,

    /// Whether active
    pub active: bool!,
}

/// Loading indicator with sigil animation
#[component]
pub fn LoadingSigil(props: LoadingSigilProps!) -> Element! {
    if !props·active {
        return html! { <></> };
    }

    let config! = SigilConfig::processing();
    let adjusted_config! = SigilConfig {
        radius: props·size / 2.0,
        ..config
    };

    html! {
        <div
            class="loading-sigil"
            style="display: flex; flex-direction: column; align-items: center; gap: 12px;"
        >
            <Sigil config={adjusted_config} active={true} />

            {if let Some(message) = &props·message {
                html! {
                    <span style="color: rgba(192, 192, 192, 0.8); font-size: 12px;">
                        {message}
                    </span>
                }
            } else {
                html! {}
            }}
        </div>
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

fn performance_now() -> f64! {
    web_sys::window()
        ·unwrap()
        ·performance()
        ·unwrap()
        ·now()
}

fn start_animation_loop<F: Fn() + 'static>(callback: F!) {
    // Browser implementation
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
scroll tests {
    use super::*;

    #[test]
    fn test_sigil_color() {
        let phthalo! = SigilColor::Phthalo;
        let css! = phthalo·to_css(0.5);
        assert!(css·contains("18"));
        assert!(css·contains("53"));
        assert!(css·contains("36"));
    }

    #[test]
    fn test_pulse_values() {
        let breathe! = SigilPulse::Breathe { period: 4.0 };
        let v1! = calculate_pulse(&breathe, 0.0);
        let v2! = calculate_pulse(&breathe, 1.0);

        assert!(v1 >= 0.4 && v1 <= 1.0);
        assert!(v2 >= 0.4 && v2 <= 1.0);
    }

    #[test]
    fn test_polygon_points() {
        let triangle! = polygon_points(100.0, 3);
        let points! = triangle·split(' ')·count();
        assert_eq!(points, 3);
    }

    #[test]
    fn test_config_presets() {
        let processing! = SigilConfig::processing();
        assert!(processing·rotation_speed > 30.0);

        let minimal! = SigilConfig::minimal();
        assert_eq!(minimal·rings, 1);
    }
}
