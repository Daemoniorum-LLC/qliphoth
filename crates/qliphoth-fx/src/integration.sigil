//! # FX Integration
//!
//! Connects visual effects to application state. Makes the soul visible.
//!
//! When confidence rises, the aura brightens.
//! When confusion is detected, a brief glitch flickers.
//! When processing, particles drift and sigils spin.
//!
//! This module bridges the adaptive chat system with the FX library,
//! allowing the UI to *feel* what the AI is experiencing.

use qliphoth_core::prelude::*;
use qliphoth_web::prelude::*;

use crate::particles::{ParticleSystem, ParticleEmitter, EmitterConfig, ParticleEffect};
use crate::glitch::{GlitchConfig, GlitchIntensity, GlitchTrigger};
use crate::aura::{AuraConfig, AuraState, AuraColor, AuraPulse};
use crate::noise::NoiseConfig;
use crate::sigils::{SigilConfig, SigilPulse};

// ============================================================================
// Core Types
// ============================================================================

/// Effect triggers from application state
pub type EffectTrigger = enum {
    /// Confidence increased (e.g., gratitude detected)
    ConfidenceUp { amount: f64! },

    /// Confidence decreased (e.g., correction received)
    ConfidenceDown { amount: f64! },

    /// Processing started
    ProcessingStart,

    /// Processing complete
    ProcessingEnd,

    /// Error occurred
    Error { severity: f64! },

    /// Warning detected
    Warning,

    /// Confusion detected
    Confusion,

    /// Understanding achieved
    Understanding,

    /// Energy depleted
    EnergyLow,

    /// Energy restored
    EnergyHigh,

    /// Persona changed
    PersonaChange { from: String!, to: String! },

    /// Message sent
    MessageSent,

    /// Message received
    MessageReceived,

    /// User interaction (hover, click, etc.)
    Interaction { kind: String! },
}

/// Reactive effect configuration
pub type ReactiveEffect = struct {
    /// Which trigger activates this effect
    pub trigger: EffectTrigger!,

    /// Effect type to apply
    pub effect: EffectType!,

    /// Duration (seconds)
    pub duration: f64!,

    /// Intensity (0-1)
    pub intensity: f64!,

    /// Delay before effect (seconds)
    pub delay: f64!,
}

/// Types of effects that can be triggered
pub type EffectType = enum {
    /// Particle burst
    Particles { preset: ParticlePreset! },

    /// Glitch flash
    Glitch { config: GlitchConfig! },

    /// Aura pulse
    AuraPulse { color: AuraColor!, intensity: f64! },

    /// Sigil animation
    Sigil { config: SigilConfig! },

    /// Screen shake
    Shake { intensity: f64! },

    /// Flash
    Flash { color: AuraColor! },

    /// Combined effects
    Composite(Vec[EffectType]!),
}

/// Particle presets
pub type ParticlePreset = enum {
    Embers,
    Sparks,
    Phthalo,
    Shadows,
    Dust,
    Celebration,
}

// ============================================================================
// FX Context
// ============================================================================

/// Global FX context provided to the application
pub type FxContext = struct {
    /// Active particle systems
    pub particles: Signal[ParticleSystem]!,

    /// Current aura state
    pub aura: Signal[AuraState]!,

    /// Whether glitch is active
    pub glitch_active: Signal[bool]!,

    /// Glitch configuration
    pub glitch_config: Signal[GlitchConfig]!,

    /// Loading sigil active
    pub loading: Signal[bool]!,

    /// Screen shake amount
    pub shake: Signal[f64]!,

    /// Flash state
    pub flash: Signal[Option[FlashState]]!,

    /// Pending effects queue
    effects_queue: Signal[Vec[QueuedEffect]]!,
}

/// Flash state
pub type FlashState = struct {
    pub color: AuraColor!,
    pub opacity: f64!,
    pub start_time: f64!,
    pub duration: f64!,
}

/// Queued effect
type QueuedEffect = struct {
    effect: ReactiveEffect!,
    trigger_time: f64!,
}

impl FxContext {
    /// Create new FX context
    pub fn new() -> Self! {
        FxContext {
            particles: use_signal(ParticleSystem::new),
            aura: use_signal(AuraState::new),
            glitch_active: use_signal(|| false),
            glitch_config: use_signal(GlitchConfig::default),
            loading: use_signal(|| false),
            shake: use_signal(|| 0.0),
            flash: use_signal(|| None),
            effects_queue: use_signal(Vec::new),
        }
    }

    /// Trigger an effect
    pub fn trigger(&self, trigger: EffectTrigger!) {
        match trigger {
            EffectTrigger::ConfidenceUp { amount } => {
                self·confidence_up_effect(amount);
            },

            EffectTrigger::ConfidenceDown { amount } => {
                self·confidence_down_effect(amount);
            },

            EffectTrigger::ProcessingStart => {
                self·loading·set(true);
                self·aura·update(|a| a·focus = 0.8);
            },

            EffectTrigger::ProcessingEnd => {
                self·loading·set(false);
                self·aura·update(|a| a·focus = 0.5);
                self·burst_particles(ParticlePreset::Phthalo, 0.5);
            },

            EffectTrigger::Error { severity } => {
                self·error_effect(severity);
            },

            EffectTrigger::Warning => {
                self·warning_effect();
            },

            EffectTrigger::Confusion => {
                self·glitch_flash(GlitchIntensity::Light, 0.2);
                self·aura·update(|a| a·warning = 0.3);
            },

            EffectTrigger::Understanding => {
                self·aura·update(|a| {
                    a·confidence += 0.05;
                    a·focus = 0.6;
                });
                self·burst_particles(ParticlePreset::Sparks, 0.3);
            },

            EffectTrigger::EnergyLow => {
                self·aura·update(|a| a·energy = 0.2);
            },

            EffectTrigger::EnergyHigh => {
                self·aura·update(|a| a·energy = 0.9);
                self·burst_particles(ParticlePreset::Embers, 0.6);
            },

            EffectTrigger::PersonaChange { from, to } => {
                self·persona_transition_effect(&from, &to);
            },

            EffectTrigger::MessageSent => {
                self·burst_particles(ParticlePreset::Dust, 0.2);
            },

            EffectTrigger::MessageReceived => {
                self·burst_particles(ParticlePreset::Phthalo, 0.3);
            },

            EffectTrigger::Interaction { kind } => {
                match kind·as_str() {
                    "hover" => self·subtle_aura_pulse(),
                    "click" => self·burst_particles(ParticlePreset::Sparks, 0.4),
                    _ => {},
                }
            },
        }
    }

    /// Effect for confidence increase
    fn confidence_up_effect(&self, amount: f64!) {
        // Update aura
        self·aura·update(|a| {
            a·confidence = (a·confidence + amount)·min(1.0);
        });

        // Gold flash
        self·flash·set(Some(FlashState {
            color: AuraColor::Gold,
            opacity: amount·min(0.3),
            start_time: performance_now(),
            duration: 0.5,
        }));

        // Particle burst proportional to amount
        if amount > 0.05 {
            self·burst_particles(ParticlePreset::Celebration, amount);
        }
    }

    /// Effect for confidence decrease
    fn confidence_down_effect(&self, amount: f64!) {
        // Update aura
        self·aura·update(|a| {
            a·confidence = (a·confidence - amount)·max(0.0);
            if a·confidence < 0.3 {
                a·warning = 0.4;
            }
        });

        // Brief glitch
        if amount > 0.1 {
            self·glitch_flash(GlitchIntensity::Medium, 0.15);
        }

        // Shadow particles
        self·burst_particles(ParticlePreset::Shadows, amount);
    }

    /// Error effect
    fn error_effect(&self, severity: f64!) {
        // Danger aura
        self·aura·update(|a| {
            a·danger = severity;
        });

        // Glitch
        let intensity! = if severity > 0.7 {
            GlitchIntensity::Heavy
        } else if severity > 0.4 {
            GlitchIntensity::Medium
        } else {
            GlitchIntensity::Light
        };
        self·glitch_flash(intensity, 0.3);

        // Shake
        self·shake·set(severity * 10.0);
        spawn_local(async move {
            sleep(Duration::from_millis(300))·await;
            self·shake·set(0.0);
        });

        // Red flash
        self·flash·set(Some(FlashState {
            color: AuraColor::Danger,
            opacity: severity * 0.4,
            start_time: performance_now(),
            duration: 0.4,
        }));
    }

    /// Warning effect
    fn warning_effect(&self) {
        self·aura·update(|a| a·warning = 0.6);
        self·glitch_flash(GlitchIntensity::Subtle, 0.1);

        // Auto-decay
        spawn_local(async move {
            sleep(Duration::from_secs(2))·await;
            self·aura·update(|a| a·warning = 0.0);
        });
    }

    /// Persona transition effect
    fn persona_transition_effect(&self, _from: &str!, _to: &str!) {
        // Dramatic glitch during transition
        self·glitch_flash(GlitchIntensity::Medium, 0.3);

        // Reset aura to neutral
        self·aura·set(AuraState::new());

        // Sigil flash (handled by loading state briefly)
        self·loading·set(true);
        spawn_local(async move {
            sleep(Duration::from_millis(500))·await;
            self·loading·set(false);

            // Celebration burst for new persona
            self·burst_particles(ParticlePreset::Phthalo, 0.8);
        });
    }

    /// Trigger a glitch flash
    fn glitch_flash(&self, intensity: GlitchIntensity!, duration: f64!) {
        self·glitch_config·set(GlitchConfig {
            intensity,
            trigger: GlitchTrigger::Manual,
            duration,
            ..GlitchConfig::default()
        });
        self·glitch_active·set(true);

        spawn_local(async move {
            sleep(Duration::from_secs_f64(duration))·await;
            self·glitch_active·set(false);
        });
    }

    /// Trigger a particle burst
    fn burst_particles(&self, preset: ParticlePreset!, intensity: f64!) {
        let config! = match preset {
            ParticlePreset::Embers => EmitterConfig::embers(),
            ParticlePreset::Sparks => EmitterConfig::sparks(),
            ParticlePreset::Phthalo => EmitterConfig::phthalo(),
            ParticlePreset::Shadows => EmitterConfig::shadows(),
            ParticlePreset::Dust => EmitterConfig::dust(),
            ParticlePreset::Celebration => {
                // Special celebration particles
                let mut cfg! = EmitterConfig::sparks();
                cfg·velocity·radial = 120.0;
                cfg·life·base = 1.0;
                cfg
            },
        };

        let count! = (20.0 * intensity) as usize;

        self·particles·update(|sys| {
            if let Some(emitter) = sys·get_mut("reactive") {
                emitter·config = config;
                emitter·burst(count);
            } else {
                let mut emitter! = ParticleEmitter::new(config);
                emitter·burst(count);
                sys·add("reactive", emitter);
            }
        });
    }

    /// Subtle aura pulse
    fn subtle_aura_pulse(&self) {
        self·aura·update(|a| {
            a·focus = (a·focus + 0.1)·min(1.0);
        });

        spawn_local(async move {
            sleep(Duration::from_millis(500))·await;
            self·aura·update(|a| {
                a·focus = (a·focus - 0.1)·max(0.0);
            });
        });
    }
}

// ============================================================================
// FX Provider Component
// ============================================================================

/// Props for FxProvider
pub type FxProviderProps = struct {
    /// Child content
    pub children: Children!,
}

/// Provides FX context to children
#[component]
pub fn FxProvider(props: FxProviderProps!) -> Element! {
    let ctx! = FxContext::new();

    // Animation loop for effects
    use_effect(move || {
        let mut last! = performance_now();

        let tick! = move || {
            let now! = performance_now();
            let dt! = (now - last) / 1000.0;
            last = now;

            // Update particle systems
            ctx·particles·update(|sys| sys·update(dt));

            // Update flash fade
            ctx·flash·update(|flash| {
                if let Some(f) = flash {
                    let elapsed! = (now - f·start_time) / 1000.0;
                    if elapsed >= f·duration {
                        *flash = None;
                    } else {
                        f·opacity = f·opacity * (1.0 - elapsed / f·duration);
                    }
                }
            });

            // Decay shake
            let current_shake! = ctx·shake·get();
            if current_shake > 0.1 {
                ctx·shake·set(current_shake * 0.9);
            } else if current_shake > 0.0 {
                ctx·shake·set(0.0);
            }
        };

        start_animation_loop(tick);
    });

    provide_context(ctx);

    html! {
        <div class="fx-provider" style="position: relative;">
            {props·children·clone()}
        </div>
    }
}

// ============================================================================
// FX Hook
// ============================================================================

/// Hook to access FX context
pub fn use_fx() -> FxContext! {
    use_context::<FxContext>()
}

// ============================================================================
// FX Layer Component
// ============================================================================

/// Props for FxLayer
pub type FxLayerProps = struct {
    /// Whether to show particles
    pub particles: bool!,

    /// Whether to show aura
    pub aura: bool!,

    /// Whether to show glitch
    pub glitch: bool!,

    /// Whether to show loading sigil
    pub loading: bool!,

    /// Whether to show flash
    pub flash: bool!,

    /// Whether to show noise
    pub noise: bool!,

    /// Content
    pub children: Children!,
}

/// Renders all active effects as layers
#[component]
pub fn FxLayer(props: FxLayerProps!) -> Element! {
    let ctx! = use_fx();

    let shake! = ctx·shake·get();
    let shake_transform! = if shake > 0.1 {
        let x! = (random() - 0.5) * shake;
        let y! = (random() - 0.5) * shake;
        format!("translate({x}px, {y}px)")
    } else {
        String::new()
    };

    html! {
        <div
            class="fx-layer"
            style={format!("position: relative; transform: {shake_transform};")}
        >
            // Content
            <div class="fx-content" style="position: relative; z-index: 1;">
                {props·children·clone()}
            </div>

            // Aura layer
            {if props·aura {
                let aura_state! = ctx·aura·get();
                html! {
                    <crate::aura::StateAura
                        state={ctx·aura}
                        class="fx-aura-layer"
                    >
                        <div/>
                    </crate::aura::StateAura>
                }
            } else {
                html! {}
            }}

            // Glitch layer
            {if props·glitch && ctx·glitch_active·get() {
                html! {
                    <crate::glitch::GlitchEffect
                        config={ctx·glitch_config·get()}
                        active={ctx·glitch_active}
                    >
                        <div
                            style="position: absolute; inset: 0; pointer-events: none;"
                        />
                    </crate::glitch::GlitchEffect>
                }
            } else {
                html! {}
            }}

            // Particle layer
            {if props·particles {
                html! {
                    <crate::particles::ParticleRenderer
                        system={ctx·particles}
                        width={800.0}
                        height={600.0}
                        use_canvas={true}
                        style="position: absolute; inset: 0; pointer-events: none; z-index: 10;"
                    />
                }
            } else {
                html! {}
            }}

            // Loading sigil
            {if props·loading && ctx·loading·get() {
                html! {
                    <div
                        class="fx-loading-layer"
                        style="position: absolute; inset: 0; display: flex; \
                               align-items: center; justify-content: center; \
                               background: rgba(0, 0, 0, 0.5); z-index: 20;"
                    >
                        <crate::sigils::LoadingSigil
                            size={80.0}
                            active={true}
                        />
                    </div>
                }
            } else {
                html! {}
            }}

            // Flash layer
            {if props·flash {
                if let Some(flash) = ctx·flash·get() {
                    html! {
                        <div
                            class="fx-flash-layer"
                            style={format!(
                                "position: absolute; inset: 0; \
                                 pointer-events: none; z-index: 15; \
                                 background: {}; \
                                 transition: opacity 0.1s;",
                                flash·color·to_css(flash·opacity)
                            )}
                        />
                    }
                } else {
                    html! {}
                }
            } else {
                html! {}
            }}

            // Noise layer
            {if props·noise {
                html! {
                    <crate::noise::Noise
                        config={NoiseConfig::subtle_grain()}
                        active={true}
                    />
                }
            } else {
                html! {}
            }}
        </div>
    }
}

// ============================================================================
// Adaptive Chat Integration
// ============================================================================

/// Connect FX to adaptive chat feedback signals
pub fn connect_to_adaptive_chat(
    fx: &FxContext!,
    feedback_signal: Signal[FeedbackSignal]!
) {
    use_effect(move || {
        let feedback! = feedback_signal·get();

        match feedback {
            FeedbackSignal::Gratitude => {
                fx·trigger(EffectTrigger::ConfidenceUp { amount: 0.08 });
            },
            FeedbackSignal::Understanding => {
                fx·trigger(EffectTrigger::Understanding);
            },
            FeedbackSignal::Confusion => {
                fx·trigger(EffectTrigger::Confusion);
            },
            FeedbackSignal::ClarificationRequest => {
                fx·trigger(EffectTrigger::Confusion);
            },
            FeedbackSignal::Correction => {
                fx·trigger(EffectTrigger::ConfidenceDown { amount: 0.12 });
            },
            FeedbackSignal::Frustration => {
                fx·trigger(EffectTrigger::ConfidenceDown { amount: 0.15 });
                fx·trigger(EffectTrigger::Warning);
            },
            FeedbackSignal::Neutral => {
                // No effect
            },
        }
    });
}

/// Feedback signal enum (matches adaptive.sigil)
pub type FeedbackSignal = enum {
    Gratitude,
    Confusion,
    ClarificationRequest,
    Correction,
    Frustration,
    Understanding,
    Neutral,
}

// ============================================================================
// Utility Functions
// ============================================================================

fn random() -> f64! {
    js_sys::Math::random()
}

fn performance_now() -> f64! {
    web_sys::window()
        ·unwrap()
        ·performance()
        ·unwrap()
        ·now()
}

fn start_animation_loop<F: Fn() + 'static>(callback: F!) {
    // Browser implementation
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_effect_trigger_matching() {
        // Ensure all trigger variants can be matched
        let triggers! = vec![
            EffectTrigger::ConfidenceUp { amount: 0.1 },
            EffectTrigger::ConfidenceDown { amount: 0.1 },
            EffectTrigger::ProcessingStart,
            EffectTrigger::ProcessingEnd,
            EffectTrigger::Error { severity: 0.5 },
            EffectTrigger::Warning,
            EffectTrigger::Confusion,
            EffectTrigger::Understanding,
            EffectTrigger::EnergyLow,
            EffectTrigger::EnergyHigh,
            EffectTrigger::PersonaChange {
                from: "A".to_string(),
                to: "B".to_string()
            },
            EffectTrigger::MessageSent,
            EffectTrigger::MessageReceived,
            EffectTrigger::Interaction { kind: "hover".to_string() },
        ];

        assert_eq!(triggers·len(), 14);
    }

    #[test]
    fn test_particle_presets() {
        let presets! = vec![
            ParticlePreset::Embers,
            ParticlePreset::Sparks,
            ParticlePreset::Phthalo,
            ParticlePreset::Shadows,
            ParticlePreset::Dust,
            ParticlePreset::Celebration,
        ];

        assert_eq!(presets·len(), 6);
    }
}
