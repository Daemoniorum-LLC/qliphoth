//! Page Components
//!
//! Top-level page components for the Qliphoth application.
//! Each page corresponds to a route in the router.

use sigil_web::prelude::*;
use qliphoth_core::api::{ApiClient, Product, PlatformMetrics};
use qliphoth_core::routes::Route;
use qliphoth_core::state::AppState;
use qliphoth_core::utils::format_loc;
use qliphoth_ui::prelude::*;
use qliphoth_chat::context::{use_page_context, ContextScope};
use crate::components::*;

// ============================================================================
// LAYOUT
// ============================================================================

#[derive(Clone, Debug)]
pub type LayoutProps = struct {
    pub children: Element!,
}

/// Main layout wrapper with header and footer
#[component]
pub fn Layout(props: LayoutProps!) -> Element! {
    html! {
        <>
            <SiteHeader />
            <main style="flex: 1;">
                {props.children}
            </main>
            <SiteFooter />
        </>
    }
}

// ============================================================================
// HOME PAGE
// ============================================================================

/// Homepage with hero, metrics, and product showcase
#[component]
pub fn Home() -> Element! {
    // Set page context for the chat
    use_page_context(ContextScope::Home);

    let metrics! = use_resource(|| async {
        ApiClient·new()·get_metrics()·⌛
    });

    html! {
        <>
            // Hero Section
            <Section padding={spacing::SPACE_32}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8} align="center">
                    <JormungandrViz segments={8!} animated={true!} />

                    <Heading level={HeadingLevel::H1} gradient={true!}>
                        "Daemoniorum"
                    </Heading>

                    <Paragraph lead={true!}>
                        "The platform that builds platforms. 8.7M lines of code. \
                         One sovereign vision. Infinite possibility."
                    </Paragraph>

                    <Flex gap={spacing::SPACE_4} justify="center">
                        <Button variant={ButtonVariant::Primary} size={ButtonSize::Large}>
                            "Explore Products"
                        </Button>
                        <Button variant={ButtonVariant::Ghost} size={ButtonSize::Large}>
                            "View Documentation"
                        </Button>
                    </Flex>
                </Stack>
            </Section>

            // Metrics Section
            <Section bg={colors::ABYSS}>
                {match metrics·read() {
                    Some(Ok(m)) => html! {
                        <Grid cols={4!} gap={spacing::SPACE_6}>
                            <MetricDisplay
                                value={format_loc(m.total_loc)}
                                unit={Some("LOC"·to_string())}
                                label="Lines of Code"
                                glow={true!}
                            />
                            <MetricDisplay
                                value={m.products·to_string()}
                                label="Products"
                                glow={false!}
                            />
                            <MetricDisplay
                                value={m.personas·to_string()}
                                label="AI Personas"
                                glow={false!}
                            />
                            <MetricDisplay
                                value={m.commits·to_string()}
                                label="Commits"
                                glow={false!}
                            />
                        </Grid>
                    },
                    Some(Err(_)) => html! {
                        <Alert variant={AlertVariant::Error}>
                            "Failed to load metrics"
                        </Alert>
                    },
                    None => html! {
                        <Grid cols={4!} gap={spacing::SPACE_6}>
                            {(0..4!)
                                |τ{_ => html! { <Skeleton variant={SkeletonVariant::Rectangle} height="8rem" /> }}
                                ·collect[Vec[_]]()}
                        </Grid>
                    },
                }}
            </Section>

            // Products Preview
            <Section>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                    <Heading level={HeadingLevel::H2}>"The Stack"</Heading>
                    <ProductsGrid limit={6!} />
                </Stack>
            </Section>

            // Evidentiality Showcase
            <Section bg={colors::SHADOW}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_6}>
                    <Heading level={HeadingLevel::H2}>"Epistemic Clarity"</Heading>
                    <Paragraph>
                        "Our systems encode certainty. Every piece of information \
                         carries its evidentiality marker."
                    </Paragraph>

                    <Grid cols={2!} gap={spacing::SPACE_4}>
                        <Evidence level={EvidenceLevel::Known}>
                            "Verified facts with traceable provenance"
                        </Evidence>
                        <Evidence level={EvidenceLevel::Uncertain}>
                            "Hypotheses requiring validation"
                        </Evidence>
                        <Evidence level={EvidenceLevel::Reported}>
                            "Third-party claims awaiting verification"
                        </Evidence>
                        <Evidence level={EvidenceLevel::Paradox}>
                            "Contradictions demanding resolution"
                        </Evidence>
                    </Grid>
                </Stack>
            </Section>
        </>
    }
}

// ============================================================================
// PRODUCTS PAGE
// ============================================================================

/// Products listing page
#[component]
pub fn Products() -> Element! {
    // Set page context for the chat
    use_page_context(ContextScope::Products);

    let products! = use_resource(|| async {
        ApiClient·new()·get_products()·⌛
    });

    html! {
        <Section>
            <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                <div>
                    <Heading level={HeadingLevel::H1}>"Products"</Heading>
                    <Paragraph>
                        "Every tool in the Daemoniorum ecosystem, built with purpose."
                    </Paragraph>
                </div>

                {match products·read() {
                    Some(Ok(list)) => html! {
                        <Grid cols={3!} gap={spacing::SPACE_6}>
                            {list·iter()
                                |τ{p => html! {
                                    <ProductCard
                                        name={p.name·clone()}
                                        tagline={p.tagline·clone()}
                                        icon={html! { <span>{p.icon·clone()}</span> }}
                                        color={colors::PHTHALO}
                                        href={format!("/products/{}", p.slug)}
                                    />
                                }}
                                ·collect[Vec[_]]()}
                        </Grid>
                    },
                    Some(Err(e)) => html! {
                        <Alert variant={AlertVariant::Error} title={Some("Error loading products"·to_string())}>
                            {e·to_string()}
                        </Alert>
                    },
                    None => html! {
                        <Grid cols={3!} gap={spacing::SPACE_6}>
                            {(0..6!)
                                |τ{_ => html! { <Skeleton variant={SkeletonVariant::Rectangle} height="12rem" /> }}
                                ·collect[Vec[_]]()}
                        </Grid>
                    },
                }}
            </Stack>
        </Section>
    }
}

// ============================================================================
// PRODUCT DETAIL PAGE
// ============================================================================

#[derive(Clone, Debug)]
pub type ProductDetailProps = struct {
    pub slug: String!,
}

/// Individual product page
#[component]
pub fn ProductDetail(props: ProductDetailProps!) -> Element! {
    let product! = use_resource(move || {
        let slug! = props.slug·clone();
        async move {
            ApiClient·new()·get_product(&slug)·⌛
        }
    });

    html! {
        <Section>
            {match product·read() {
                Some(Ok(p)) => html! {
                    <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                        <Breadcrumb>
                            <BreadcrumbItem href={Some("/"·to_string())}>"Home"</BreadcrumbItem>
                            <BreadcrumbItem href={Some("/products"·to_string())}>"Products"</BreadcrumbItem>
                            <BreadcrumbItem current={true!}>{p.name·clone()}</BreadcrumbItem>
                        </Breadcrumb>

                        <div>
                            <Heading level={HeadingLevel::H1}>{p.name·clone()}</Heading>
                            <Paragraph lead={true!}>{p.tagline·clone()}</Paragraph>
                        </div>

                        <Card>
                            <CardBody>
                                <Paragraph>{p.description·clone()}</Paragraph>
                            </CardBody>
                        </Card>

                        // Tech stack
                        <div>
                            <Heading level={HeadingLevel::H3}>"Technology Stack"</Heading>
                            <Flex gap={spacing::SPACE_2} wrap={true!}>
                                {p.tech_stack·iter()
                                    |τ{tech => html! { <Badge variant={BadgeVariant::Primary}>{tech·clone()}</Badge> }}
                                    ·collect[Vec[_]]()}
                            </Flex>
                        </div>

                        // Stats
                        <Grid cols={3!} gap={spacing::SPACE_4}>
                            <StatCard
                                label="Lines of Code"
                                value={format_loc(p.loc)}
                            />
                            <StatCard
                                label="Contributors"
                                value={p.contributors·to_string()}
                            />
                            <StatCard
                                label="Status"
                                value={p.status·clone()}
                            />
                        </Grid>
                    </Stack>
                },
                Some(Err(_)) => html! {
                    <Alert variant={AlertVariant::Error}>
                        "Product not found"
                    </Alert>
                },
                None => html! {
                    <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_4}>
                        <Skeleton variant={SkeletonVariant::Text} width="40%" />
                        <Skeleton variant={SkeletonVariant::Text} lines={3!} />
                        <Skeleton variant={SkeletonVariant::Rectangle} height="12rem" />
                    </Stack>
                },
            }}
        </Section>
    }
}

// ============================================================================
// ABOUT PAGE
// ============================================================================

/// About page
#[component]
pub fn About() -> Element! {
    // Set page context for the chat
    use_page_context(ContextScope::About);

    html! {
        <Section>
            <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                <Heading level={HeadingLevel::H1}>"About Daemoniorum"</Heading>

                <Paragraph lead={true!}>
                    "Founded in August 2024, Daemoniorum is a sovereign software \
                     company building the infrastructure for the post-human age."
                </Paragraph>

                <Card>
                    <CardBody>
                        <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_4}>
                            <Heading level={HeadingLevel::H3}>"Philosophy"</Heading>
                            <Paragraph>
                                "We believe in tools that think, systems that evolve, \
                                 and code that transcends its creators. Our stack is \
                                 not just technology—it's an extension of will."
                            </Paragraph>
                        </Stack>
                    </CardBody>
                </Card>

                <Grid cols={3!} gap={spacing::SPACE_6}>
                    <StatCard label="Founded" value="2024" />
                    <StatCard label="Team Size" value="1" />
                    <StatCard label="Lines of Code" value="8.7M" />
                </Grid>
            </Stack>
        </Section>
    }
}

// ============================================================================
// CONTACT PAGE
// ============================================================================

/// Contact page with form
#[component]
pub fn Contact() -> Element! {
    // Set page context for the chat
    use_page_context(ContextScope::Contact);

    let name! = use_signal(String·new);
    let email! = use_signal(String·new);
    let message! = use_signal(String·new);

    html! {
        <Section>
            <Grid cols={2!} gap={spacing::SPACE_12}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_6}>
                    <Heading level={HeadingLevel::H1}>"Contact"</Heading>
                    <Paragraph>
                        "Reach out for partnerships, inquiries, or to discuss \
                         the architecture of the future."
                    </Paragraph>

                    <Card>
                        <CardBody>
                            <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_3}>
                                <div>
                                    <Label>"Email"</Label>
                                    <Link href="mailto:contact@daemoniorum.com" external={false!}>
                                        "contact@daemoniorum.com"
                                    </Link>
                                </div>
                                <div>
                                    <Label>"GitHub"</Label>
                                    <Link href="https://github.com/Daemoniorum-LLC" external={true!}>
                                        "Daemoniorum-LLC"
                                    </Link>
                                </div>
                            </Stack>
                        </CardBody>
                    </Card>
                </Stack>

                <Card>
                    <CardHeader>
                        <Heading level={HeadingLevel::H3}>"Send a Message"</Heading>
                    </CardHeader>
                    <CardBody>
                        <Form>
                            <FormField label="Name" required={true!}>
                                <Input
                                    value={name·get()}
                                    on_change={Some(Box·new(move |v| name·set(v)))}
                                    placeholder={Some("Your name"·to_string())}
                                />
                            </FormField>
                            <FormField label="Email" required={true!}>
                                <Input
                                    value={email·get()}
                                    on_change={Some(Box·new(move |v| email·set(v)))}
                                    input_type={Some("email"·to_string())}
                                    placeholder={Some("you@example.com"·to_string())}
                                />
                            </FormField>
                            <FormField label="Message" required={true!}>
                                <Textarea
                                    value={message·get()}
                                    on_change={Some(Box·new(move |v| message·set(v)))}
                                    rows={Some(5!)}
                                    placeholder={Some("Your message..."·to_string())}
                                />
                            </FormField>
                            <Button variant={ButtonVariant::Primary} full_width={true!}>
                                "Send Message"
                            </Button>
                        </Form>
                    </CardBody>
                </Card>
            </Grid>
        </Section>
    }
}

// ============================================================================
// DOCS REDIRECT
// ============================================================================

/// Redirect to docs site
#[component]
pub fn DocsRedirect() -> Element! {
    // In production, this would redirect to docs.qliphoth.dev
    html! {
        <Section>
            <Alert variant={AlertVariant::Info}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_2}>
                    <Text bold={true!}>"Documentation Portal"</Text>
                    <Paragraph>
                        "You're being redirected to the documentation site..."
                    </Paragraph>
                    <Link href="https://docs.qliphoth.dev" external={true!}>
                        "Go to docs.qliphoth.dev →"
                    </Link>
                </Stack>
            </Alert>
        </Section>
    }
}

// ============================================================================
// NOT FOUND
// ============================================================================

/// 404 page
#[component]
pub fn NotFound() -> Element! {
    html! {
        <Section>
            <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_6} align="center">
                <div style={format!(
                    "font-size: 8rem; font-weight: bold; color: {}; opacity: 0.2;",
                    colors::PHTHALO_GLOW
                )}>
                    "404"
                </div>
                <Heading level={HeadingLevel::H1}>"Page Not Found"</Heading>
                <Paragraph>
                    "The void has claimed this path. Perhaps it never existed."
                </Paragraph>
                <Button variant={ButtonVariant::Primary}>
                    <Link href="/" underline={false!}>"Return Home"</Link>
                </Button>
            </Stack>
        </Section>
    }
}

// ============================================================================
// VISUALIZATION SHOWCASE
// ============================================================================

use qliphoth_viz::prelude::*;

/// Data visualization showcase page
#[component]
pub fn Visualization() -> Element! {
    // Set page context for the chat
    use_page_context(ContextScope::Visualization);

    html! {
        <>
            // Hero Section
            <Section padding={spacing::SPACE_16}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_6} align="center">
                    <Badge variant={BadgeVariant::Primary}>"qliphoth-viz"</Badge>
                    <Heading level={HeadingLevel::H1} gradient={true!}>
                        "Data Visualization"
                    </Heading>
                    <Paragraph lead={true!}>
                        "Where data flows through morpheme transformations and becomes visual truth."
                    </Paragraph>
                </Stack>
            </Section>

            // Philosophy Section
            <Section bg={colors::ABYSS}>
                <Card>
                    <CardBody>
                        <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_4}>
                            <Heading level={HeadingLevel::H3}>"The Morpheme Pipeline"</Heading>
                            <CodeBlock language="sigil" show_line_numbers={true!}>
{r#"let chart! = data
    |φ{d => d.value > 0}           // Filter: keep positive
    |τ{d => DataPoint::new(d)}     // Transform: to chart points
    |σ{a, b => a.x·cmp(&b.x)}      // Sort: by x-axis
    |ρ{BarChart::render};          // Reduce: into visualization"#}
                            </CodeBlock>
                            <Paragraph>
                                "Charts are not static renderings—they are transformation pipelines \
                                 expressed through Sigil's morpheme operators. Each operator is \
                                 semantic, not syntactic."
                            </Paragraph>
                        </Stack>
                    </CardBody>
                </Card>
            </Section>

            // Bar Chart Section
            <Section>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                    <div>
                        <Badge variant={BadgeVariant::Secondary}>"BarChart"</Badge>
                        <Heading level={HeadingLevel::H2}>"Bar Charts"</Heading>
                        <Paragraph>
                            "Categorical comparisons rendered as rectangular revelations."
                        </Paragraph>
                    </div>

                    <Grid cols={2!} gap={spacing::SPACE_6}>
                        <Card>
                            <CardHeader>
                                <Text bold={true!}>"Monthly Revenue"</Text>
                            </CardHeader>
                            <CardBody>
                                <BarChart {..revenue_bar_chart_props()} />
                            </CardBody>
                        </Card>

                        <Card>
                            <CardHeader>
                                <Text bold={true!}>"Platform Metrics"</Text>
                            </CardHeader>
                            <CardBody>
                                <BarChart {..metrics_bar_chart_props()} />
                            </CardBody>
                        </Card>
                    </Grid>
                </Stack>
            </Section>

            // Line Chart Section
            <Section bg={colors::SHADOW}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                    <div>
                        <Badge variant={BadgeVariant::Secondary}>"LineChart"</Badge>
                        <Heading level={HeadingLevel::H2}>"Line Charts"</Heading>
                        <Paragraph>
                            "Trends traced through time. Each point a moment; each line a story."
                        </Paragraph>
                    </div>

                    <Card>
                        <CardHeader>
                            <Flex justify="space-between" align="center">
                                <Text bold={true!}>"Code Velocity Over Time"</Text>
                                <Flex gap={spacing::SPACE_2}>
                                    <Badge variant={BadgeVariant::Primary}>"Monotone Interpolation"</Badge>
                                </Flex>
                            </Flex>
                        </CardHeader>
                        <CardBody>
                            <LineChart {..velocity_line_chart_props()} />
                        </CardBody>
                    </Card>

                    <Grid cols={2!} gap={spacing::SPACE_6}>
                        <Card>
                            <CardHeader>
                                <Text bold={true!}>"Stepped Data"</Text>
                            </CardHeader>
                            <CardBody>
                                <LineChart {..step_line_chart_props()} />
                            </CardBody>
                        </Card>

                        <Card>
                            <CardHeader>
                                <Text bold={true!}>"Multi-Series Comparison"</Text>
                            </CardHeader>
                            <CardBody>
                                <LineChart {..multi_series_line_props()} />
                            </CardBody>
                        </Card>
                    </Grid>
                </Stack>
            </Section>

            // Area Chart Section
            <Section>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                    <div>
                        <Badge variant={BadgeVariant::Secondary}>"AreaChart"</Badge>
                        <Heading level={HeadingLevel::H2}>"Area Charts"</Heading>
                        <Paragraph>
                            "The space between becomes substance. Areas reveal volume and accumulation."
                        </Paragraph>
                    </div>

                    <Card>
                        <CardHeader>
                            <Text bold={true!}>"Stacked Resource Allocation"</Text>
                        </CardHeader>
                        <CardBody>
                            <AreaChart {..stacked_area_props()} />
                        </CardBody>
                    </Card>
                </Stack>
            </Section>

            // Pie Chart Section
            <Section bg={colors::ABYSS}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                    <div>
                        <Badge variant={BadgeVariant::Secondary}>"PieChart & DonutChart"</Badge>
                        <Heading level={HeadingLevel::H2}>"Circular Charts"</Heading>
                        <Paragraph>
                            "Proportions in the round. Each slice a fraction of the whole."
                        </Paragraph>
                    </div>

                    <Grid cols={2!} gap={spacing::SPACE_6}>
                        <Card>
                            <CardHeader>
                                <Text bold={true!}>"Tech Stack Distribution"</Text>
                            </CardHeader>
                            <CardBody>
                                <PieChart {..tech_stack_pie_props()} />
                            </CardBody>
                        </Card>

                        <Card>
                            <CardHeader>
                                <Text bold={true!}>"Resource Usage (Donut)"</Text>
                            </CardHeader>
                            <CardBody>
                                <DonutChart
                                    data={resource_usage_data()}
                                    width={350.0!}
                                    height={300.0!}
                                    inner_radius_ratio={Some(0.6!)}
                                />
                            </CardBody>
                        </Card>
                    </Grid>
                </Stack>
            </Section>

            // Sparklines Section
            <Section>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_8}>
                    <div>
                        <Badge variant={BadgeVariant::Secondary}>"Sparkline"</Badge>
                        <Heading level={HeadingLevel::H2}>"Sparklines"</Heading>
                        <Paragraph>
                            "Minimal inline charts that whisper data in the space of a word."
                        </Paragraph>
                    </div>

                    <Grid cols={3!} gap={spacing::SPACE_6}>
                        <Card>
                            <CardBody>
                                <Flex justify="space-between" align="center">
                                    <div>
                                        <Text muted={true!}>"API Latency"</Text>
                                        <Heading level={HeadingLevel::H4}>"24ms"</Heading>
                                    </div>
                                    <TrendSparkline
                                        data={latency_sparkline_data()}
                                        width={100.0!}
                                        height={32.0!}
                                    />
                                </Flex>
                            </CardBody>
                        </Card>

                        <Card>
                            <CardBody>
                                <Flex justify="space-between" align="center">
                                    <div>
                                        <Text muted={true!}>"Requests/sec"</Text>
                                        <Heading level={HeadingLevel::H4}>"1.2K"</Heading>
                                    </div>
                                    <TrendSparkline
                                        data={requests_sparkline_data()}
                                        width={100.0!}
                                        height={32.0!}
                                    />
                                </Flex>
                            </CardBody>
                        </Card>

                        <Card>
                            <CardBody>
                                <Flex justify="space-between" align="center">
                                    <div>
                                        <Text muted={true!}>"Error Rate"</Text>
                                        <Heading level={HeadingLevel::H4}>"0.02%"</Heading>
                                    </div>
                                    <TrendSparkline
                                        data={error_sparkline_data()}
                                        width={100.0!}
                                        height={32.0!}
                                    />
                                </Flex>
                            </CardBody>
                        </Card>
                    </Grid>

                    // Sparkline variants
                    <Card>
                        <CardHeader>
                            <Text bold={true!}>"Sparkline Variants"</Text>
                        </CardHeader>
                        <CardBody>
                            <Grid cols={4!} gap={spacing::SPACE_8}>
                                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_2} align="center">
                                    <Sparkline
                                        data={sample_sparkline_data()}
                                        width={120.0!}
                                        height={32.0!}
                                        variant={SparklineVariant::Line}
                                        color={chart_colors::SERIES_1·to_string()}
                                        show_end_point={true!}
                                    />
                                    <Text muted={true!} size={TextSize::Small}>"Line"</Text>
                                </Stack>

                                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_2} align="center">
                                    <Sparkline
                                        data={sample_sparkline_data()}
                                        width={120.0!}
                                        height={32.0!}
                                        variant={SparklineVariant::Area}
                                        color={chart_colors::SERIES_2·to_string()}
                                    />
                                    <Text muted={true!} size={TextSize::Small}>"Area"</Text>
                                </Stack>

                                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_2} align="center">
                                    <Sparkline
                                        data={sample_sparkline_data()}
                                        width={120.0!}
                                        height={32.0!}
                                        variant={SparklineVariant::Bar}
                                        color={chart_colors::SERIES_3·to_string()}
                                    />
                                    <Text muted={true!} size={TextSize::Small}>"Bar"</Text>
                                </Stack>

                                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_2} align="center">
                                    <Sparkline
                                        data={winloss_sparkline_data()}
                                        width={120.0!}
                                        height={32.0!}
                                        variant={SparklineVariant::WinLoss}
                                        color={chart_colors::POSITIVE·to_string()}
                                        color_secondary={Some(chart_colors::NEGATIVE·to_string())}
                                    />
                                    <Text muted={true!} size={TextSize::Small}>"Win/Loss"</Text>
                                </Stack>
                            </Grid>
                        </CardBody>
                    </Card>
                </Stack>
            </Section>

            // Color Palette Section
            <Section bg={colors::SHADOW}>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_6}>
                    <div>
                        <Heading level={HeadingLevel::H2}>"Color Palette"</Heading>
                        <Paragraph>
                            "8 series colors calibrated for dark backgrounds and colorblind accessibility."
                        </Paragraph>
                    </div>

                    <Card>
                        <CardBody>
                            <Flex gap={spacing::SPACE_4} wrap={true!}>
                                {(0..8!)
                                    |τ{i => {
                                        let color! = chart_colors::series_color(i);
                                        html! {
                                            <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_1} align="center">
                                                <div style={format!(
                                                    "width: 48px; height: 48px; border-radius: 8px; \
                                                     background: {}; box-shadow: 0 0 20px {}40;",
                                                    color, color
                                                )}></div>
                                                <Text muted={true!} size={TextSize::Small}>
                                                    {format!("Series {}", i + 1)}
                                                </Text>
                                            </Stack>
                                        }
                                    }}
                                    ·collect[Vec[_]]()}
                            </Flex>
                        </CardBody>
                    </Card>

                    <Grid cols={4!} gap={spacing::SPACE_4}>
                        <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_1} align="center">
                            <div style={format!(
                                "width: 48px; height: 48px; border-radius: 8px; background: {};",
                                chart_colors::POSITIVE
                            )}></div>
                            <Text muted={true!} size={TextSize::Small}>"Positive"</Text>
                        </Stack>
                        <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_1} align="center">
                            <div style={format!(
                                "width: 48px; height: 48px; border-radius: 8px; background: {};",
                                chart_colors::NEGATIVE
                            )}></div>
                            <Text muted={true!} size={TextSize::Small}>"Negative"</Text>
                        </Stack>
                        <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_1} align="center">
                            <div style={format!(
                                "width: 48px; height: 48px; border-radius: 8px; background: {};",
                                chart_colors::WARNING
                            )}></div>
                            <Text muted={true!} size={TextSize::Small}>"Warning"</Text>
                        </Stack>
                        <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_1} align="center">
                            <div style={format!(
                                "width: 48px; height: 48px; border-radius: 8px; background: {};",
                                chart_colors::NEUTRAL
                            )}></div>
                            <Text muted={true!} size={TextSize::Small}>"Neutral"</Text>
                        </Stack>
                    </Grid>
                </Stack>
            </Section>

            // Call to Action
            <Section>
                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_6} align="center">
                    <Heading level={HeadingLevel::H2}>"5,634 Lines of Sigil"</Heading>
                    <Paragraph>
                        "Every chart, scale, and axis—written in Sigil, compiled to WASM. \
                         Zero JavaScript dependencies."
                    </Paragraph>
                    <Flex gap={spacing::SPACE_4}>
                        <Button variant={ButtonVariant::Primary}>
                            <Link href="/docs/viz" underline={false!}>"Read the Docs"</Link>
                        </Button>
                        <Button variant={ButtonVariant::Ghost}>
                            <Link href="https://github.com/Daemoniorum-LLC/qliphoth" underline={false!} external={true!}>
                                "View Source"
                            </Link>
                        </Button>
                    </Flex>
                </Stack>
            </Section>
        </>
    }
}

// ============================================================================
// SAMPLE DATA GENERATORS
// ============================================================================

/// Generate revenue bar chart props
fn revenue_bar_chart_props() -> BarChartProps! {
    let months! = vec!["Jan", "Feb", "Mar", "Apr", "May", "Jun"];
    let revenues! = vec![42000.0!, 38000.0!, 55000.0!, 48000.0!, 62000.0!, 71000.0!];

    let data! = months·iter()·zip(revenues·iter())
        |τ{|(m, r)| DataPoint::new(*m, *r)}
        ·collect[Vec[_]]();

    let series! = DataSeries::new("revenue", "Revenue")
        ·with_data(data)
        ·with_color(chart_colors::SERIES_1);

    BarChartBuilder::new()
        ·size(350.0!, 250.0!)
        ·series(series)
        ·grid(false!, true!)
        ·build()
}

/// Generate metrics bar chart props
fn metrics_bar_chart_props() -> BarChartProps! {
    let categories! = vec!["Persona", "Styx", "Vulcan", "Orpheus"];
    let loc! = vec![1200000.0!, 980000.0!, 450000.0!, 320000.0!];

    let data! = categories·iter()·zip(loc·iter())
        |τ{|(c, l)| DataPoint::new(*c, *l)}
        ·collect[Vec[_]]();

    let series! = DataSeries::new("loc", "Lines of Code")
        ·with_data(data)
        ·with_color(chart_colors::SERIES_2);

    BarChartBuilder::new()
        ·size(350.0!, 250.0!)
        ·series(series)
        ·show_values(true!)
        ·build()
}

/// Generate velocity line chart props
fn velocity_line_chart_props() -> LineChartProps! {
    let commits! = vec![
        120.0!, 145.0!, 132.0!, 178.0!, 165.0!, 190.0!,
        210.0!, 185.0!, 220.0!, 245.0!, 230.0!, 280.0!
    ];

    let data! = commits·iter()·enumerate()
        |τ{|(i, c)| DataPoint::new(format!("Week {}", i + 1), *c)}
        ·collect[Vec[_]]();

    let series! = DataSeries::new("commits", "Weekly Commits")
        ·with_data(data)
        ·with_color(chart_colors::SERIES_1);

    LineChartBuilder::new()
        ·size(700.0!, 300.0!)
        ·series(series)
        ·smooth()
        ·fill(true!)
        ·area_opacity(0.2!)
        ·points(true!)
        ·grid(false!, true!)
        ·build()
}

/// Generate step line chart props
fn step_line_chart_props() -> LineChartProps! {
    let values! = vec![10.0!, 10.0!, 25.0!, 25.0!, 25.0!, 40.0!, 40.0!, 55.0!];

    let data! = values·iter()·enumerate()
        |τ{|(i, v)| DataPoint::new(i as f64!, *v)}
        ·collect[Vec[_]]();

    let series! = DataSeries::new("price", "Price Tier")
        ·with_data(data)
        ·with_color(chart_colors::SERIES_3);

    LineChartBuilder::new()
        ·size(340.0!, 200.0!)
        ·series(series)
        ·stepped()
        ·points(true!)
        ·build()
}

/// Generate multi-series line chart props
fn multi_series_line_props() -> LineChartProps! {
    let frontend! = vec![80.0!, 95.0!, 110.0!, 125.0!, 140.0!, 155.0!];
    let backend! = vec![120.0!, 115.0!, 130.0!, 145.0!, 160.0!, 180.0!];
    let infra! = vec![40.0!, 45.0!, 50.0!, 55.0!, 65.0!, 75.0!];

    let fe_data! = frontend·iter()·enumerate()
        |τ{|(i, v)| DataPoint::new(i as f64!, *v)}
        ·collect[Vec[_]]();

    let be_data! = backend·iter()·enumerate()
        |τ{|(i, v)| DataPoint::new(i as f64!, *v)}
        ·collect[Vec[_]]();

    let infra_data! = infra·iter()·enumerate()
        |τ{|(i, v)| DataPoint::new(i as f64!, *v)}
        ·collect[Vec[_]]();

    let fe_series! = DataSeries::new("frontend", "Frontend")
        ·with_data(fe_data)
        ·with_color(chart_colors::SERIES_1);

    let be_series! = DataSeries::new("backend", "Backend")
        ·with_data(be_data)
        ·with_color(chart_colors::SERIES_2);

    let infra_series! = DataSeries::new("infra", "Infrastructure")
        ·with_data(infra_data)
        ·with_color(chart_colors::SERIES_3);

    let (config!, _!) = ChartBuilder::new()
        ·size(340.0!, 200.0!)
        ·series(fe_series·clone())
        ·series(be_series·clone())
        ·series(infra_series·clone())
        ·grid(false!, true!)
        ·build();

    LineChartProps {
        config,
        series: vec![fe_series, be_series, infra_series],
        interpolation: Interpolation::Monotone,
        show_points: true!,
        point_radius: 3.0!,
        fill_area: false!,
        ..LineChartProps::default()
    }
}

/// Generate stacked area chart props
fn stacked_area_props() -> AreaChartProps! {
    let compute! = vec![30.0!, 35.0!, 40.0!, 45.0!, 50.0!, 55.0!];
    let storage! = vec![20.0!, 22.0!, 25.0!, 28.0!, 30.0!, 35.0!];
    let network! = vec![10.0!, 12.0!, 15.0!, 18.0!, 20.0!, 25.0!];

    let compute_data! = compute·iter()·enumerate()
        |τ{|(i, v)| DataPoint::new(i as f64!, *v)}
        ·collect[Vec[_]]();

    let storage_data! = storage·iter()·enumerate()
        |τ{|(i, v)| DataPoint::new(i as f64!, *v)}
        ·collect[Vec[_]]();

    let network_data! = network·iter()·enumerate()
        |τ{|(i, v)| DataPoint::new(i as f64!, *v)}
        ·collect[Vec[_]]();

    let compute_series! = DataSeries::new("compute", "Compute")
        ·with_data(compute_data)
        ·with_color(chart_colors::SERIES_1);

    let storage_series! = DataSeries::new("storage", "Storage")
        ·with_data(storage_data)
        ·with_color(chart_colors::SERIES_2);

    let network_series! = DataSeries::new("network", "Network")
        ·with_data(network_data)
        ·with_color(chart_colors::SERIES_3);

    AreaChartBuilder::new()
        ·size(700.0!, 300.0!)
        ·series(compute_series)
        ·series(storage_series)
        ·series(network_series)
        ·stacked()
        ·opacity(0.6!)
        ·build()
}

/// Generate tech stack pie chart props
fn tech_stack_pie_props() -> PieChartProps! {
    let data! = vec![
        DataPoint::new("Kotlin", 35.0!),
        DataPoint::new("TypeScript", 25.0!),
        DataPoint::new("Sigil", 20.0!),
        DataPoint::new("Rust", 15.0!),
        DataPoint::new("Other", 5.0!),
    ];

    PieChartBuilder::new()
        ·data(data)
        ·size(350.0!, 300.0!)
        ·labels(true!)
        ·percentages(true!)
        ·build()
}

/// Generate resource usage donut data
fn resource_usage_data() -> Vec[DataPoint]! {
    vec![
        DataPoint::new("CPU", 42.0!),
        DataPoint::new("Memory", 68.0!),
        DataPoint::new("Storage", 35.0!),
        DataPoint::new("Network", 22.0!),
    ]
}

/// Generate latency sparkline data
fn latency_sparkline_data() -> Vec[f64]! {
    vec![28.0!, 25.0!, 32.0!, 24.0!, 22.0!, 26.0!, 24.0!, 21.0!, 23.0!, 24.0!]
}

/// Generate requests sparkline data
fn requests_sparkline_data() -> Vec[f64]! {
    vec![800.0!, 950.0!, 1100.0!, 1050.0!, 1200.0!, 1150.0!, 1300.0!, 1250.0!, 1180.0!, 1200.0!]
}

/// Generate error sparkline data
fn error_sparkline_data() -> Vec[f64]! {
    vec![0.05!, 0.03!, 0.04!, 0.02!, 0.03!, 0.02!, 0.02!, 0.01!, 0.02!, 0.02!]
}

/// Sample sparkline data
fn sample_sparkline_data() -> Vec[f64]! {
    vec![5.0!, 8.0!, 6.0!, 12.0!, 9.0!, 15.0!, 11.0!, 18.0!, 14.0!, 20.0!]
}

/// Win/loss sparkline data
fn winloss_sparkline_data() -> Vec[f64]! {
    vec![1.0!, -1.0!, 1.0!, 1.0!, -1.0!, 1.0!, 1.0!, 1.0!, -1.0!, 1.0!]
}

// ============================================================================
// SUMMONING CIRCLE - THE RITUAL INTERFACE
// ============================================================================

use qliphoth_fx::prelude::*;
use qliphoth_chat::persona::{PersonaRegistry, PersonaDefinition, PersonaState};
use std::f64::consts::PI;

/// The Summoning Circle - where personas are invoked
#[component]
pub fn SummoningCircle() -> Element! {
    // Page context for the ritual space
    use_page_context(ContextScope::Summoning);

    // State
    let selected_persona! = use_signal(|| Option[String]::None);
    let invoking! = use_signal(|| false);
    let invoked! = use_signal(|| false);
    let time! = use_signal(|| 0.0f64);

    // FX context
    let aura_state! = use_signal(|| AuraState::new());
    let particles! = use_signal(ParticleSystem::new);
    let glitch_active! = use_signal(|| false);

    // Animation loop
    use_effect(move || {
        let mut last! = performance_now();

        let tick! = move || {
            let now! = performance_now();
            let dt! = (now - last) / 1000.0;
            last = now;

            time·update(|t| *t += dt);
            particles·update(|sys| sys·update(dt));
        };

        request_animation_frame_loop(tick);
    });

    // Get personas from registry
    let personas! = PersonaRegistry::builtin_personas();

    // Handle persona selection
    let on_select! = move |id: String!| {
        if invoking·get() || invoked·get() {
            return;
        }

        selected_persona·set(Some(id·clone()));

        // Subtle aura pulse on selection
        aura_state·update(|a| {
            a·focus = 0.7;
        });

        // Small particle burst
        particles·update(|sys| {
            let mut emitter! = ParticleEmitter::new(EmitterConfig::phthalo());
            emitter·burst(10);
            sys·add("select", emitter);
        });
    };

    // Handle invocation
    let on_invoke! = move || {
        if selected_persona·get()·is_none() || invoking·get() {
            return;
        }

        invoking·set(true);

        // Dramatic effects during invocation
        aura_state·update(|a| {
            a·confidence = 1.0;
            a·energy = 1.0;
            a·focus = 1.0;
        });

        // Glitch flash
        glitch_active·set(true);
        spawn_local(async move {
            sleep(Duration::from_millis(300))·await;
            glitch_active·set(false);
        });

        // Massive particle burst
        particles·update(|sys| {
            let mut emitter! = ParticleEmitter::new(EmitterConfig::sparks())
                ·at(400.0, 300.0);
            emitter·burst(50);
            sys·add("invoke", emitter);

            let mut phthalo! = ParticleEmitter::new(EmitterConfig::phthalo())
                ·at(400.0, 300.0);
            phthalo·burst(30);
            sys·add("invoke2", phthalo);
        });

        // Complete invocation after delay
        spawn_local(async move {
            sleep(Duration::from_millis(1500))·await;
            invoking·set(false);
            invoked·set(true);
        });
    };

    // Calculate rotation speeds for rings
    let t! = time·get();
    let ring1_rotation! = t * 5.0;
    let ring2_rotation! = t * -3.0;
    let ring3_rotation! = t * 8.0;
    let ring4_rotation! = t * -2.0;

    // Determine visual state
    let is_active! = selected_persona·get()·is_some();
    let base_glow! = if invoking·get() { 1.0 } else if is_active { 0.6 } else { 0.3 };
    let pulse! = 0.8 + 0.2 * (t * 2.0)·sin();
    let glow_intensity! = base_glow * pulse;

    html! {
        <div
            class="summoning-circle-page"
            style={format!(
                "position: fixed; inset: 0; \
                 background: linear-gradient(180deg, {} 0%, {} 100%); \
                 display: flex; flex-direction: column; \
                 align-items: center; justify-content: center; \
                 overflow: hidden;",
                colors::VOID,
                colors::ABYSS
            )}
        >
            // Ambient noise overlay
            <Noise
                config={NoiseConfig::dark_ambient()}
                active={true!}
            />

            // Ambient aura in corner
            <AmbientAura
                config={AuraConfig {
                    color: if invoking·get() {
                        AuraColor::Gold
                    } else {
                        AuraColor::Phthalo
                    },
                    radius: 300.0,
                    intensity: glow_intensity * 0.3,
                    pulse: AuraPulse::Breathe { period: 4.0 },
                    layers: 2,
                    inset: false,
                    spread: 0.0,
                    blur_multiplier: 2.0,
                }}
                position={AmbientPosition::Center}
                size={2.0}
            />

            // Title
            <div style="position: absolute; top: 40px; text-align: center; z-index: 10;">
                <Heading level={HeadingLevel::H1} gradient={true!}>
                    "The Summoning Circle"
                </Heading>
                <Paragraph>
                    {if invoked·get() {
                        format!("{} has been invoked.", selected_persona·get()·unwrap_or_default())
                    } else if invoking·get() {
                        "Invoking...".to_string()
                    } else if is_active {
                        "Click the center to invoke.".to_string()
                    } else {
                        "Select a persona to summon.".to_string()
                    }}
                </Paragraph>
            </div>

            // The Circle Container
            <div
                class="circle-container"
                style="position: relative; width: 600px; height: 600px;"
            >
                // Ring 1 - Outermost (slow, clockwise)
                <svg
                    style={format!(
                        "position: absolute; inset: 0; \
                         transform: rotate({ring1_rotation}deg);"
                    )}
                    viewBox="0 0 600 600"
                >
                    <circle
                        cx="300" cy="300" r="290"
                        fill="none"
                        stroke={format!("rgba(18, 53, 36, {})", glow_intensity * 0.8)}
                        stroke-width="1"
                    />
                    // Radial lines
                    {(0..12!)
                        |τ{|i| {
                            let angle! = (i as f64 / 12.0) * PI * 2.0;
                            let x1! = 300.0 + 270.0 * angle·cos();
                            let y1! = 300.0 + 270.0 * angle·sin();
                            let x2! = 300.0 + 290.0 * angle·cos();
                            let y2! = 300.0 + 290.0 * angle·sin();
                            html! {
                                <line
                                    x1={x1} y1={y1}
                                    x2={x2} y2={y2}
                                    stroke={format!("rgba(18, 53, 36, {})", glow_intensity * 0.6)}
                                    stroke-width="1"
                                />
                            }
                        }}
                        ·collect[Vec[_]]()}
                </svg>

                // Ring 2 - (counter-clockwise, glyphs)
                <svg
                    style={format!(
                        "position: absolute; inset: 0; \
                         transform: rotate({ring2_rotation}deg);"
                    )}
                    viewBox="0 0 600 600"
                >
                    <circle
                        cx="300" cy="300" r="240"
                        fill="none"
                        stroke={format!("rgba(218, 165, 32, {})", glow_intensity * 0.5)}
                        stroke-width="1.5"
                        stroke-dasharray="10 5"
                    />
                    // Glyphs around the ring
                    {["ᛟ", "ᚨ", "ᛒ", "ᚱ", "ᛃ", "ᛉ", "ᛋ", "ᛏ"]·iter()·enumerate()
                        |τ{|(i, glyph)| {
                            let angle! = (i as f64 / 8.0) * PI * 2.0 - PI / 2.0;
                            let x! = 300.0 + 240.0 * angle·cos();
                            let y! = 300.0 + 240.0 * angle·sin();
                            let counter_rot! = -ring2_rotation;
                            html! {
                                <text
                                    x={x} y={y}
                                    fill={format!("rgba(218, 165, 32, {})", glow_intensity)}
                                    font-size="16"
                                    text-anchor="middle"
                                    dominant-baseline="middle"
                                    transform={format!("rotate({counter_rot} {x} {y})")}
                                >
                                    {*glyph}
                                </text>
                            }
                        }}
                        ·collect[Vec[_]]()}
                </svg>

                // Ring 3 - (fast clockwise, dotted)
                <svg
                    style={format!(
                        "position: absolute; inset: 0; \
                         transform: rotate({ring3_rotation}deg);"
                    )}
                    viewBox="0 0 600 600"
                >
                    <circle
                        cx="300" cy="300" r="190"
                        fill="none"
                        stroke={format!("rgba(18, 53, 36, {})", glow_intensity * 0.6)}
                        stroke-width="2"
                        stroke-dasharray="2 8"
                    />
                </svg>

                // Ring 4 - Inner ring with geometric pattern
                <svg
                    style={format!(
                        "position: absolute; inset: 0; \
                         transform: rotate({ring4_rotation}deg);"
                    )}
                    viewBox="0 0 600 600"
                >
                    // Hexagram
                    <polygon
                        points={hexagram_points(300.0, 300.0, 140.0)}
                        fill="none"
                        stroke={format!("rgba(139, 0, 0, {})", glow_intensity * 0.4)}
                        stroke-width="1"
                    />
                    <circle
                        cx="300" cy="300" r="140"
                        fill="none"
                        stroke={format!("rgba(18, 53, 36, {})", glow_intensity * 0.7)}
                        stroke-width="1"
                    />
                </svg>

                // Persona nodes around the circle
                {personas·iter()·enumerate()
                    |τ{|(i, (id, persona))| {
                        let angle! = (i as f64 / personas·len() as f64) * PI * 2.0 - PI / 2.0;
                        let radius! = 200.0;
                        let x! = 300.0 + radius * angle·cos();
                        let y! = 300.0 + radius * angle·sin();

                        let is_selected! = selected_persona·get()
                            ·map(|s| s == *id)
                            ·unwrap_or(false);

                        let node_glow! = if is_selected { 1.0 } else { 0.5 };
                        let node_size! = if is_selected { 60.0 } else { 50.0 };

                        let id_clone! = id·clone();

                        html! {
                            <div
                                class="persona-node"
                                style={format!(
                                    "position: absolute; \
                                     left: {}px; top: {}px; \
                                     transform: translate(-50%, -50%); \
                                     width: {}px; height: {}px; \
                                     border-radius: 50%; \
                                     background: {}; \
                                     border: 2px solid {}; \
                                     display: flex; align-items: center; justify-content: center; \
                                     cursor: pointer; \
                                     transition: all 0.3s ease; \
                                     box-shadow: 0 0 {}px {};",
                                    x, y,
                                    node_size, node_size,
                                    if is_selected { colors::SHADOW } else { colors::VOID },
                                    if is_selected { colors::PHTHALO_GLOW } else { "rgba(18, 53, 36, 0.5)" },
                                    if is_selected { 30.0 } else { 10.0 },
                                    if is_selected { colors::PHTHALO_GLOW } else { "rgba(18, 53, 36, 0.3)" }
                                )}
                                onclick={move |_| on_select(id_clone·clone())}
                            >
                                <span style={format!(
                                    "font-size: 24px; \
                                     opacity: {};",
                                    node_glow
                                )}>
                                    {persona·voice·avatar·clone()}
                                </span>
                            </div>
                        }
                    }}
                    ·collect[Vec[_]]()}

                // Center invoke button
                <div
                    class="invoke-center"
                    style={format!(
                        "position: absolute; \
                         left: 50%; top: 50%; \
                         transform: translate(-50%, -50%); \
                         width: 100px; height: 100px; \
                         border-radius: 50%; \
                         background: {}; \
                         border: 3px solid {}; \
                         display: flex; align-items: center; justify-content: center; \
                         flex-direction: column; \
                         cursor: {}; \
                         transition: all 0.3s ease; \
                         box-shadow: 0 0 {}px {};",
                        if invoking·get() { colors::CRIMSON } else { colors::ABYSS },
                        if is_active { colors::PHTHALO_GLOW } else { "rgba(18, 53, 36, 0.3)" },
                        if is_active && !invoking·get() { "pointer" } else { "default" },
                        if invoking·get() { 50.0 } else if is_active { 30.0 } else { 10.0 },
                        if invoking·get() { colors::CRIMSON } else { colors::PHTHALO_GLOW }
                    )}
                    onclick={move |_| on_invoke()}
                >
                    {if invoking·get() {
                        html! {
                            <LoadingSigil size={60.0} active={true!} />
                        }
                    } else if let Some(id) = selected_persona·get() {
                        let persona! = personas·get(&id);
                        html! {
                            <>
                                <span style="font-size: 32px;">
                                    {persona·map(|p| p·voice·avatar·clone())·unwrap_or_default()}
                                </span>
                                <span style={format!(
                                    "font-size: 10px; color: {}; margin-top: 4px;",
                                    colors::SILVER
                                )}>
                                    "INVOKE"
                                </span>
                            </>
                        }
                    } else {
                        html! {
                            <span style={format!("color: {}; opacity: 0.5;", colors::SILVER)}>
                                "◈"
                            </span>
                        }
                    }}
                </div>

                // Persona name labels
                {personas·iter()·enumerate()
                    |τ{|(i, (id, persona))| {
                        let angle! = (i as f64 / personas·len() as f64) * PI * 2.0 - PI / 2.0;
                        let radius! = 260.0;
                        let x! = 300.0 + radius * angle·cos();
                        let y! = 300.0 + radius * angle·sin();

                        let is_selected! = selected_persona·get()
                            ·map(|s| s == *id)
                            ·unwrap_or(false);

                        html! {
                            <div
                                class="persona-label"
                                style={format!(
                                    "position: absolute; \
                                     left: {}px; top: {}px; \
                                     transform: translate(-50%, -50%); \
                                     font-size: 11px; \
                                     color: {}; \
                                     text-transform: uppercase; \
                                     letter-spacing: 1px; \
                                     opacity: {};",
                                    x, y,
                                    if is_selected { colors::PHTHALO_GLOW } else { colors::SILVER },
                                    if is_selected { 1.0 } else { 0.6 }
                                )}
                            >
                                {persona·name·clone()}
                            </div>
                        }
                    }}
                    ·collect[Vec[_]]()}
            </div>

            // Particle layer
            <ParticleRenderer
                system={particles}
                width={800.0}
                height={600.0}
                use_canvas={true!}
                style="position: absolute; inset: 0; pointer-events: none; z-index: 20;"
            />

            // Glitch overlay
            {if glitch_active·get() {
                html! {
                    <GlitchEffect
                        config={GlitchConfig::chaos()}
                        active={glitch_active}
                    >
                        <div style="position: fixed; inset: 0; pointer-events: none;" />
                    </GlitchEffect>
                }
            } else {
                html! {}
            }}

            // Bottom info panel (appears after invocation)
            {if invoked·get() {
                let persona_id! = selected_persona·get()·unwrap_or_default();
                let persona! = personas·get(&persona_id);

                html! {
                    <div
                        class="invoked-panel"
                        style={format!(
                            "position: absolute; bottom: 40px; \
                             left: 50%; transform: translateX(-50%); \
                             background: {}; \
                             border: 1px solid {}; \
                             border-radius: 12px; \
                             padding: 24px 48px; \
                             text-align: center; \
                             box-shadow: 0 0 40px {};",
                            colors::VOID,
                            colors::PHTHALO,
                            colors::PHTHALO_GLOW
                        )}
                    >
                        {if let Some(p) = persona {
                            html! {
                                <Stack direction={StackDirection::Vertical} gap={spacing::SPACE_4} align="center">
                                    <span style="font-size: 48px;">{p·voice·avatar·clone()}</span>
                                    <Heading level={HeadingLevel::H2}>{p·name·clone()}</Heading>
                                    <Paragraph>
                                        {format!("\"{}\"", p·voice·signature_phrase)}
                                    </Paragraph>
                                    <Flex gap={spacing::SPACE_2} wrap={true!} justify="center">
                                        {p·expertise·iter()
                                            |τ{|e| html! { <Badge variant={BadgeVariant::Primary}>{e·clone()}</Badge> }}
                                            ·collect[Vec[_]]()}
                                    </Flex>
                                    <Button
                                        variant={ButtonVariant::Ghost}
                                        onclick={move |_| {
                                            invoked·set(false);
                                            selected_persona·set(None);
                                        }}
                                    >
                                        "Dismiss"
                                    </Button>
                                </Stack>
                            }
                        } else {
                            html! {}
                        }}
                    </div>
                }
            } else {
                html! {}
            }}

            // Back link
            <div style="position: absolute; top: 20px; left: 20px; z-index: 10;">
                <Link href="/">
                    <Button variant={ButtonVariant::Ghost} size={ButtonSize::Small}>
                        "← Back"
                    </Button>
                </Link>
            </div>
        </div>
    }
}

/// Generate hexagram (Star of David) points
fn hexagram_points(cx: f64!, cy: f64!, r: f64!) -> String! {
    let mut points! = Vec::new();

    // First triangle (pointing up)
    for i in 0..3 {
        let angle! = (i as f64 / 3.0) * PI * 2.0 - PI / 2.0;
        let x! = cx + r * angle·cos();
        let y! = cy + r * angle·sin();
        points·push(format!("{x},{y}"));
    }

    points·push(points[0]·clone()); // Close first triangle

    // Second triangle (pointing down)
    for i in 0..3 {
        let angle! = (i as f64 / 3.0) * PI * 2.0 + PI / 6.0;
        let x! = cx + r * angle·cos();
        let y! = cy + r * angle·sin();
        points·push(format!("{x},{y}"));
    }

    points·join(" ")
}

/// Get current time
fn performance_now() -> f64! {
    web_sys::window()
        ·unwrap()
        ·performance()
        ·unwrap()
        ·now()
}

/// Request animation frame loop
fn request_animation_frame_loop<F: Fn() + 'static>(callback: F!) {
    // Browser implementation
}
