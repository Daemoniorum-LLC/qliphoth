// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Product Catalog
// Daemoniorum product data for the documentation platform
// Native Sigil Syntax

invoke crate·layouts·TocItem;

/// Product information
☉ sigil Product {
    id: String!,
    name: String!,
    tagline: String!,
    description: String!,
    version: String!,
    icon: String!,
    category: ProductCategory!,
    features: [String]!,
    quick_start: String!,
    sections: [Section]!,
    api_description: String!,
    api_modules: [ApiModule]!,
    api_items_count: i64!,
}

/// Product categories
☉ ᛈ ProductCategory {
    Languages,
    Frameworks,
    Infrastructure,
    Tools,
}

∋ ProductCategory {
    ☉ rite to_string(this) → String! {
        ⌥ this {
            ProductCategory·Languages => "Languages",
            ProductCategory·Frameworks => "Frameworks",
            ProductCategory·Infrastructure => "Infrastructure",
            ProductCategory·Tools => "Tools"
        }
    }
}

/// Documentation section
☉ sigil Section {
    id: String!,
    title: String!,
    description: String!,
    content: String!,
    toc: [TocItem]!,
}

/// API module
☉ sigil ApiModule {
    id: String!,
    name: String!,
    description: String!,
}

/// The complete product catalog
☉ const PRODUCT_CATALOG: [Product] = Vec·from([
    // =========================================================================
    // SIGIL - The Polysynthetic Programming Language
    // =========================================================================
    Product {
        id: "sigil",
        name: "Sigil",
        tagline: "Polysynthetic systems programming with evidentiality types",
        description: "Sigil is a polysynthetic systems programming language designed to achieve Rust-level performance while offering superior expressiveness through morpheme composition and evidentiality tracking.",
        version: "0.1.0",
        icon: "code",
        category: ProductCategory·Languages,
        features: Vec·from([
            "Evidentiality type system for data provenance tracking",
            "Polysynthetic syntax with morpheme composition",
            "Pipe-based data transformation pipelines",
            "Actor-based concurrency model",
            "LLVM backend for native performance",
            "JIT compilation for rapid development",
            "Memory safety without garbage collection",
            "Zero-cost abstractions"
        ]),
        quick_start: "// Install Sigil
// curl -fsSL https://sigil-lang.org/install | sh

// Create a new project
// sigil new my-project && cd my-project

// hello.sigil
rite main() {
    ≔ greeting! = \"Hello, Sigil!\"
    println(greeting!)
}

// Run it
// sigil run",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Installation and first steps with Sigil",
                content: "Getting started content...",
                toc: Vec·new()
            },
            Section {
                id: "evidentiality",
                title: "Evidentiality System",
                description: "Understanding Sigil's evidentiality type markers",
                content: "Evidentiality content...",
                toc: Vec·new()
            },
            Section {
                id: "morphemes",
                title: "Morpheme Composition",
                description: "Using Greek letter operators and pipe transformations",
                content: "Morphemes content...",
                toc: Vec·new()
            },
            Section {
                id: "concurrency",
                title: "Concurrency",
                description: "Actor-based concurrency and async programming",
                content: "Concurrency content...",
                toc: Vec·new()
            },
            Section {
                id: "memory",
                title: "Memory Management",
                description: "Ownership, borrowing, and memory safety",
                content: "Memory content...",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for the Sigil standard library",
        api_modules: Vec·from([
            ApiModule { id: "std", name: "std", description: "Standard library core" },
            ApiModule { id: "collections", name: "collections", description: "Data structures" },
            ApiModule { id: "io", name: "io", description: "Input/output operations" },
            ApiModule { id: "net", name: "net", description: "Networking" },
            ApiModule { id: "async", name: "async", description: "Async runtime" }
        ]),
        api_items_count: 450
    },

    // =========================================================================
    // SIGIL WEB - React-Inspired Web Framework
    // =========================================================================
    Product {
        id: "qliphoth",
        name: "Sigil Web",
        tagline: "React-inspired web framework with evidentiality-driven state",
        description: "Sigil Web is a modern web application framework that leverages Sigil's unique features including evidentiality types, morpheme composition, and actor-based state management.",
        version: "0.1.0",
        icon: "globe",
        category: ProductCategory·Frameworks,
        features: Vec·from([
            "React-inspired component model",
            "Evidentiality-aware state management",
            "Virtual DOM with efficient reconciliation",
            "Hooks system (useState, useEffect, useMemo, etc.)",
            "Type-safe routing",
            "Server-side rendering support",
            "Actor-based global state (Redux-like)",
            "CSS-in-Sigil styling"
        ]),
        quick_start: "invoke qliphoth·prelude·*;

component Counter {
    state count: i64! = 0

    rite render(this) → VNode {
        div {
            h1 { \"Count: {this.count}\" }
            button[onclick: || this.count += 1] { \"+\" }
            button[onclick: || this.count -= 1] { \"-\" }
        }
    }
}

rite main() {
    App·mount(\"#root\", Counter·new())
}",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Create your first Sigil Web application",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "components",
                title: "Components",
                description: "Building with functional and stateful components",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "hooks",
                title: "Hooks",
                description: "Using hooks for state and side effects",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "routing",
                title: "Routing",
                description: "Client-side routing with type-safe parameters",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "state-management",
                title: "State Management",
                description: "Actor-based global state",
                content: "",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for Sigil Web",
        api_modules: Vec·from([
            ApiModule { id: "core", name: "core", description: "Core runtime" },
            ApiModule { id: "components", name: "components", description: "Component system" },
            ApiModule { id: "hooks", name: "hooks", description: "React-style hooks" },
            ApiModule { id: "router", name: "router", description: "Routing" },
            ApiModule { id: "state", name: "state", description: "State management" },
            ApiModule { id: "dom", name: "dom", description: "DOM elements" }
        ]),
        api_items_count: 280
    },

    // =========================================================================
    // LEVIATHAN - Backend Framework
    // =========================================================================
    Product {
        id: "leviathan",
        name: "Leviathan",
        tagline: "Enterprise-grade backend framework",
        description: "Leviathan is a comprehensive backend framework built on Spring Boot, providing GraphQL APIs, authentication, multi-tenancy, and seamless integration with the Daemoniorum ecosystem.",
        version: "2.4.0",
        icon: "server",
        category: ProductCategory·Frameworks,
        features: Vec·from([
            "GraphQL-first API design",
            "Multi-tenant architecture",
            "Built-in authentication and authorization",
            "Event sourcing with Moloch integration",
            "Real-time subscriptions",
            "Automatic schema generation",
            "Database migrations",
            "OpenTelemetry observability"
        ]),
        quick_start: "// build.gradle.kts
dependencies {
    implementation(\"llc.daemoniorum:leviathan-starter:2.4.0\")
}

// Application.kt
@SpringBootApplication
@EnableLeviathan
class Application

fun main(args: Array<String>) {
    runApplication<Application>(*args)
}

// UserResolver.kt
@Component
class UserResolver : GraphQLQueryResolver {
    @Query
    fun user(id: ID): User = userService.findById(id)
}",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Set up a new Leviathan project",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "graphql",
                title: "GraphQL",
                description: "Building GraphQL APIs",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "authentication",
                title: "Authentication",
                description: "User authentication and JWT",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "multi-tenancy",
                title: "Multi-Tenancy",
                description: "Multi-tenant architecture",
                content: "",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for Leviathan",
        api_modules: Vec·from([
            ApiModule { id: "core", name: "core", description: "Core framework" },
            ApiModule { id: "graphql", name: "graphql", description: "GraphQL support" },
            ApiModule { id: "auth", name: "auth", description: "Authentication" },
            ApiModule { id: "data", name: "data", description: "Data access" }
        ]),
        api_items_count: 320
    },

    // =========================================================================
    // NYX - AI Agent Framework
    // =========================================================================
    Product {
        id: "nyx",
        name: "Nyx",
        tagline: "Autonomous AI agent framework",
        description: "Nyx is an advanced AI agent framework for building autonomous systems with guardrails, memory, and multi-agent coordination capabilities.",
        version: "1.2.0",
        icon: "brain",
        category: ProductCategory·Frameworks,
        features: Vec·from([
            "Autonomous agent execution",
            "Guardian policy enforcement",
            "Long-term memory with vector stores",
            "Multi-agent coordination",
            "Tool use and function calling",
            "Streaming responses",
            "Multiple LLM provider support",
            "Observability and tracing"
        ]),
        quick_start: "invoke nyx·prelude·*;

#[agent]
sigil ResearchAgent {
    #[memory]
    context: VectorMemory,

    #[tools]
    tools: [WebSearch, FileReader, CodeExecutor]
}

∋ ResearchAgent {
    async rite research(this, topic: String) → Report~ {
        ≔ sources~ = this.tools.web_search(topic)|await;
        ≔ analysis! = this.analyze(sources~)|await;
        Report·from(analysis!)
    }
}

rite main() {
    ≔ agent = ResearchAgent·new();
    agent.run(\"quantum computing advances 2025\")|await
}",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Create your first Nyx agent",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "agents",
                title: "Agents",
                description: "Building autonomous agents",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "memory",
                title: "Memory",
                description: "Agent memory systems",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "guardian",
                title: "Guardian",
                description: "Policy enforcement and guardrails",
                content: "",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for Nyx",
        api_modules: Vec·from([
            ApiModule { id: "core", name: "core", description: "Core framework" },
            ApiModule { id: "agents", name: "agents", description: "Agent system" },
            ApiModule { id: "memory", name: "memory", description: "Memory systems" },
            ApiModule { id: "tools", name: "tools", description: "Built-in tools" }
        ]),
        api_items_count: 185
    },

    // =========================================================================
    // AETHER - Game Engine
    // =========================================================================
    Product {
        id: "aether",
        name: "Aether",
        tagline: "High-performance game engine",
        description: "Aether is a modern game engine with ECS architecture, GPU-accelerated rendering, and comprehensive tooling for 2D and 3D game development.",
        version: "0.8.0",
        icon: "gamepad",
        category: ProductCategory·Frameworks,
        features: Vec·from([
            "Entity Component System (ECS)",
            "Vulkan/Metal/DX12 rendering",
            "Physics with Rapier integration",
            "Audio system",
            "Asset pipeline",
            "Scene editor",
            "Hot reloading",
            "Cross-platform support"
        ]),
        quick_start: "invoke aether·prelude·*;

rite main() {
    App·new()
        ·add_plugins(DefaultPlugins)
        ·add_systems(Startup, setup)
        ·add_systems(Update, movement)
        ·run()
}

rite setup(vary commands: Commands) {
    commands·spawn(Camera2dBundle·default());
    commands·spawn(SpriteBundle {
        transform: Transform·from_xyz(0.0, 0.0, 0.0),
        ..default()
    })
}

rite movement(vary query: Query<vary Transform>, input: Res<Input>) {
    ∀ vary transform ∈ query·iter_mut() {
        ⎇ input·pressed(KeyCode·Right) {
            transform.translation.x += 1.0
        }
    }
}",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Create your first game",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "ecs",
                title: "ECS",
                description: "Entity Component System",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "rendering",
                title: "Rendering",
                description: "Graphics and rendering",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "physics",
                title: "Physics",
                description: "Physics simulation",
                content: "",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for Aether",
        api_modules: Vec·from([
            ApiModule { id: "core", name: "core", description: "Core engine" },
            ApiModule { id: "ecs", name: "ecs", description: "ECS system" },
            ApiModule { id: "render", name: "render", description: "Rendering" },
            ApiModule { id: "physics", name: "physics", description: "Physics" },
            ApiModule { id: "audio", name: "audio", description: "Audio" }
        ]),
        api_items_count: 520
    },

    // =========================================================================
    // BAEL - Admin UI
    // =========================================================================
    Product {
        id: "bael",
        name: "Bael",
        tagline: "Modern admin interface",
        description: "Bael is a React-based admin UI for managing Leviathan applications, featuring real-time updates, customizable dashboards, and comprehensive data management.",
        version: "1.5.0",
        icon: "layout",
        category: ProductCategory·Tools,
        features: Vec·from([
            "Real-time data updates",
            "Customizable dashboards",
            "CRUD operations",
            "Role-based access control",
            "GraphQL integration",
            "Dark/light theme",
            "Responsive design",
            "Plugin system"
        ]),
        quick_start: "// Install Bael
npm create bael@latest my-admin

// Configure Leviathan connection
// bael.config.ts
export default {
    leviathan: {
        endpoint: 'http://localhost:8080/graphql',
        wsEndpoint: 'ws://localhost:8080/subscriptions'
    }
}

// Start development server
npm run dev",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Set up Bael admin",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "customization",
                title: "Customization",
                description: "Customize the admin interface",
                content: "",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for Bael",
        api_modules: Vec·from([
            ApiModule { id: "core", name: "core", description: "Core components" },
            ApiModule { id: "hooks", name: "hooks", description: "React hooks" }
        ]),
        api_items_count: 95
    },

    // =========================================================================
    // MOLOCH - Event Streaming
    // =========================================================================
    Product {
        id: "moloch",
        name: "Moloch",
        tagline: "High-performance event streaming",
        description: "Moloch is an event streaming platform for building event-driven architectures with Kafka integration, exactly-once processing, and real-time analytics.",
        version: "0.6.0",
        icon: "activity",
        category: ProductCategory·Infrastructure,
        features: Vec·from([
            "Kafka integration",
            "Exactly-once processing",
            "Event sourcing",
            "Stream processing",
            "Dead letter queues",
            "Replay capabilities",
            "Schema registry",
            "Monitoring dashboard"
        ]),
        quick_start: "invoke moloch·prelude·*;

#[event]
sigil OrderPlaced {
    order_id: String!,
    customer_id: String!,
    total: Decimal!,
}

#[consumer]
async rite handle_order(event: OrderPlaced~) {
    // Process the order
    println(\"Order {} placed by {}\", event~.order_id, event~.customer_id)
}

rite main() {
    Moloch·new()
        ·topic(\"orders\")
        ·consumer(handle_order)
        ·run()
}",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Set up event streaming",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "producers",
                title: "Producers",
                description: "Publishing events",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "consumers",
                title: "Consumers",
                description: "Consuming events",
                content: "",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for Moloch",
        api_modules: Vec·from([
            ApiModule { id: "core", name: "core", description: "Core framework" },
            ApiModule { id: "producers", name: "producers", description: "Event producers" },
            ApiModule { id: "consumers", name: "consumers", description: "Event consumers" }
        ]),
        api_items_count: 145
    },

    // =========================================================================
    // ARCANUM - Cryptography
    // =========================================================================
    Product {
        id: "arcanum",
        name: "Arcanum",
        tagline: "Cryptographic primitives and protocols",
        description: "Arcanum provides secure cryptographic operations including encryption, hashing, key management, and secure communication protocols.",
        version: "0.4.0",
        icon: "lock",
        category: ProductCategory·Infrastructure,
        features: Vec·from([
            "AES-256-GCM encryption",
            "Ed25519 signatures",
            "X25519 key exchange",
            "Argon2id password hashing",
            "HKDF key derivation",
            "Secure random generation",
            "HSM integration",
            "Audit logging"
        ]),
        quick_start: "invoke arcanum·prelude·*;

rite main() {
    // Generate a key pair
    ≔ keypair! = Ed25519·generate();

    // Sign a message
    ≔ message! = b\"Hello, Arcanum!\";
    ≔ signature! = keypair·sign(message);

    // Verify
    assert(keypair·verify(message, signature));

    // Encrypt data
    ≔ key! = Aes256Gcm·generate_key();
    ≔ encrypted! = key·encrypt(message);
    ≔ decrypted! = key·decrypt(encrypted);
}",
        sections: Vec·from([
            Section {
                id: "getting-started",
                title: "Getting Started",
                description: "Cryptography basics",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "encryption",
                title: "Encryption",
                description: "Symmetric and asymmetric encryption",
                content: "",
                toc: Vec·new()
            },
            Section {
                id: "signatures",
                title: "Signatures",
                description: "Digital signatures",
                content: "",
                toc: Vec·new()
            }
        ]),
        api_description: "Complete API reference for Arcanum",
        api_modules: Vec·from([
            ApiModule { id: "symmetric", name: "symmetric", description: "Symmetric encryption" },
            ApiModule { id: "asymmetric", name: "asymmetric", description: "Asymmetric encryption" },
            ApiModule { id: "hash", name: "hash", description: "Hashing" },
            ApiModule { id: "kdf", name: "kdf", description: "Key derivation" }
        ]),
        api_items_count: 78
    }
]);

