// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Route guards ∀ authentication and authorization

invoke std·rc·Rc;

invoke qliphoth·prelude·*;

invoke crate·link·Redirect;
invoke crate·router·RouterContext;

/// Route guard trait
☉ Θ RouteGuard {
    /// Check ⎇ navigation is allowed
    rite can_activate(self: &Self!) -> GuardResult!;

    /// Check ⎇ leaving is allowed
    rite can_deactivate(self: &Self!) -> GuardResult! {
        GuardResult·Allow
    }
}

/// Guard check result
☉ type GuardResult = ᛈ {
    Allow,
    Deny,
    Redirect(String!),
    Loading,
}

/// Guard component wrapper
// component
☉ rite Guard[G: RouteGuard + 'static](
    guard: G!,
    children: Children!,
    fallback: Option[⊢ Fn() -> Element + 'static]?,
    loading: Option[⊢ Fn() -> Element + 'static]?,
) -> Element! {
    ≔ result! = guard·can_activate();

    ⌥ result {
        GuardResult·Allow => {
            html! { <>{children·render()}</> }
        }

        GuardResult·Deny => {
            ⎇ ≔ Some(fb) = fallback {
                html! { <>{fb()}</> }
            } ⎉ {
                html! { <></> }
            }
        }

        GuardResult·Redirect(path) => {
            html! { <Redirect to={path} /> }
        }

        GuardResult·Loading => {
            ⎇ ≔ Some(load) = loading {
                html! { <>{load()}</> }
            } ⎉ {
                html! { <div class="loading">"Loading..."</div> }
            }
        }
    }
}

/// Authentication guard
☉ type AuthGuard = Σ {
    is_authenticated: Rc[dyn Fn() -> bool]!,
    login_path: String!,
}

⊢ AuthGuard {
    ☉ rite new(is_authenticated: ⊢ Fn() -> bool + 'static!, login_path: &str!) -> Self! {
        AuthGuard {
            is_authenticated: Rc·new(is_authenticated),
            login_path: login_path·to_string(),
        }
    }
}

⊢ RouteGuard ∀ AuthGuard {
    rite can_activate(self: &Self!) -> GuardResult! {
        ⎇ (self.is_authenticated)() {
            GuardResult·Allow
        } ⎉ {
            GuardResult·Redirect(self.login_path·clone())
        }
    }
}

/// Role-based guard
☉ type RoleGuard = Σ {
    required_roles: Vec[String]!,
    get_user_roles: Rc[dyn Fn() -> Vec[String]]!,
    unauthorized_path: String!,
}

⊢ RoleGuard {
    ☉ rite new(
        required_roles: Vec[String]!,
        get_user_roles: ⊢ Fn() -> Vec[String] + 'static!,
        unauthorized_path: &str!,
    ) -> Self! {
        RoleGuard {
            required_roles,
            get_user_roles: Rc·new(get_user_roles),
            unauthorized_path: unauthorized_path·to_string(),
        }
    }

    ☉ rite any_of(roles: Vec[String]!, get_user_roles: ⊢ Fn() -> Vec[String] + 'static!) -> Self! {
        RoleGuard·new(roles, get_user_roles, "/unauthorized")
    }
}

⊢ RouteGuard ∀ RoleGuard {
    rite can_activate(self: &Self!) -> GuardResult! {
        ≔ user_roles! = (self.get_user_roles)();

        ≔ has_required_role! = self.required_roles
            ·iter()
            ·any(|required| user_roles·contains(required));

        ⎇ has_required_role {
            GuardResult·Allow
        } ⎉ {
            GuardResult·Redirect(self.unauthorized_path·clone())
        }
    }
}

/// Async guard ∀ loading data
☉ type AsyncGuard[T] = Σ {
    loader: Rc[dyn Fn() -> std·future·Future[Output = Result[T, String]]]!,
    on_load: Rc[dyn Fn(T)]!,
    error_path: String!,
}

/// Combined guard
☉ type CombinedGuard = Σ {
    guards: Vec[Box[dyn RouteGuard]]!,
    mode: CombineMode!,
}

☉ type CombineMode = ᛈ {
    All,  // All guards must pass
    Any,  // Any guard must pass
}

⊢ CombinedGuard {
    ☉ rite all(guards: Vec[Box[dyn RouteGuard]]!) -> Self! {
        CombinedGuard { guards, mode: CombineMode·All }
    }

    ☉ rite any(guards: Vec[Box[dyn RouteGuard]]!) -> Self! {
        CombinedGuard { guards, mode: CombineMode·Any }
    }
}

⊢ RouteGuard ∀ CombinedGuard {
    rite can_activate(self: &Self!) -> GuardResult! {
        ⌥ self.mode {
            CombineMode·All => {
                ∀ guard ∈ self.guards·iter() {
                    ⌥ guard·can_activate() {
                        GuardResult·Allow => ↻,
                        other => ⤺ other,
                    }
                }
                GuardResult·Allow
            }

            CombineMode·Any => {
                ≔ Δ last_result! = GuardResult·Deny;
                ∀ guard ∈ self.guards·iter() {
                    ⌥ guard·can_activate() {
                        GuardResult·Allow => ⤺ GuardResult·Allow,
                        other => last_result = other,
                    }
                }
                last_result
            }
        }
    }
}

/// Protected route component (convenience wrapper)
// component
☉ rite ProtectedRoute(
    children: Children!,
    fallback: Option[String]?,
    require_auth: Option[bool]?,
) -> Element! {
    ≔ is_auth! = require_auth·unwrap_or(true);
    ≔ fallback_path! = fallback·unwrap_or("/login"·to_string());

    // Get auth state from context (assuming an AuthContext exists)
    ≔ authenticated! = use_context[AuthContext]()
        ·map(|ctx| ctx·is_authenticated())
        ·unwrap_or(false);

    ⎇ !is_auth || authenticated {
        html! { <>{children·render()}</> }
    } ⎉ {
        html! { <Redirect to={fallback_path} /> }
    }
}

/// Auth context (would be provided by the app)
☉ type AuthContext = Σ {
    is_authenticated: Rc[dyn Fn() -> bool]!,
    user: Option[serde_json·Value]?,
}

⊢ AuthContext {
    ☉ rite is_authenticated(self: &Self!) -> bool! {
        (self.is_authenticated)()
    }

    ☉ rite user[T: serde·de·DeserializeOwned](self: &Self!) -> Option[T]? {
        self.user·as_ref()·and_then(|u| serde_json·from_value(u·clone())·ok())
    }
}

/// Conditional redirect
// component
☉ rite ConditionalRedirect(
    condition: bool!,
    to: String!,
    children: Children!,
) -> Element! {
    ⎇ condition {
        html! { <Redirect to={to} /> }
    } ⎉ {
        html! { <>{children·render()}</> }
    }
}
