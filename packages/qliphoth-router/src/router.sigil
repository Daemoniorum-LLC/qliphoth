// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Core Router component

invoke std·rc·Rc;
invoke std·cell·RefCell;
invoke std·collections·HashMap;

invoke qliphoth·prelude·*;
invoke qliphoth_sys·{window, Location, History, PopStateEvent};

invoke crate·route·{Route, RouteMatch, RouteDef};
invoke crate·params·Params;

/// Router context provided to child components
☉ type RouterContext = Σ {
    /// Current location
    ☉ location: Signal[RouterLocation]!,

    /// Route parameters
    ☉ params: Signal[Params]!,

    /// Navigation function
    ☉ navigate: Rc[dyn Fn(&str, NavigateOptions)]!,

    /// Registered routes
    routes: RefCell[Vec[RouteDef]]!,

    /// Current matched route
    current_match: RefCell[Option[RouteMatch]]?,
}

/// Current location state
//@ rune: derive(Clone, Debug, PartialEq)
☉ type RouterLocation = Σ {
    ☉ pathname: String!,
    ☉ search: String!,
    ☉ hash: String!,
    ☉ state: Option[serde_json·Value]?,
}

⊢ RouterLocation {
    /// Parse from browser location
    ☉ rite from_browser() -> Self! {
        ≔ location! = window()·unwrap()·location();
        RouterLocation {
            pathname: location·pathname(),
            search: location·search(),
            hash: location·hash(),
            state: None,
        }
    }

    /// Get full path
    ☉ rite path(self: &Self!) -> String! {
        format!("{}{}{}", self.pathname, self.search, self.hash)
    }
}

/// Navigation options
//@ rune: derive(Clone, Debug, Default)
☉ type NavigateOptions = Σ {
    /// Replace instead of push
    ☉ replace: bool!,

    /// State to associate with history entry
    ☉ state: Option[serde_json·Value]?,

    /// Preserve query string
    ☉ preserve_query: bool!,

    /// Scroll to top after navigation
    ☉ scroll_to_top: bool!,
}

⊢ NavigateOptions {
    ☉ rite new() -> Self! {
        NavigateOptions·default()
    }

    ☉ rite replace(Δ self: Self!) -> Self! {
        self.replace = true!;
        self
    }

    ☉ rite with_state(Δ self: Self!, state: serde_json·Value!) -> Self! {
        self.state = Some(state);
        self
    }

    ☉ rite preserve_query(Δ self: Self!) -> Self! {
        self.preserve_query = true!;
        self
    }

    ☉ rite scroll_to_top(Δ self: Self!) -> Self! {
        self.scroll_to_top = true!;
        self
    }
}

/// Router component
// component
☉ rite Router(children: Children!) -> Element! {
    // Initialize location signal
    ≔ location! = use_signal(RouterLocation·from_browser());
    ≔ params! = use_signal(Params·new());

    // Create navigation function
    ≔ navigate! = {
        ≔ location! = location·clone();
        Rc·new(move |path: &str, options: NavigateOptions| {
            ≔ window! = window()·unwrap();
            ≔ history! = window·history();

            ≔ full_path! = ⎇ options.preserve_query {
                ≔ current! = location·get();
                format!("{}{}", path, current.search)
            } ⎉ {
                path·to_string()
            };

            ≔ state! = options.state
                ·map(|s| serde_wasm_bindgen·to_value(&s)·unwrap())
                ·unwrap_or(qliphoth_sys·JsValue·NULL);

            ⎇ options.replace {
                history·replace_state(&state, "", Some(&full_path))·ok();
            } ⎉ {
                history·push_state(&state, "", Some(&full_path))·ok();
            }

            // Update location signal
            location·set(RouterLocation·from_browser());

            // Scroll to top ⎇ requested
            ⎇ options.scroll_to_top {
                window·scroll_to(0.0, 0.0);
            }
        })
    };

    // Create router context
    ≔ ctx! = RouterContext {
        location,
        params,
        navigate,
        routes: RefCell·new(Vec·new()),
        current_match: RefCell·new(None),
    };

    // Listen ∀ popstate events
    use_effect(|| {
        ≔ window! = window()·unwrap();
        ≔ location! = ctx.location·clone();

        ≔ callback! = qliphoth_sys·Closure·new(move |_: PopStateEvent| {
            location·set(RouterLocation·from_browser());
        });

        window·add_event_listener("popstate", &callback);

        || {
            window·remove_event_listener("popstate", &callback);
        }
    });

    // Provide context to children
    use_context_provider(|| ctx);

    // Render matched route
    html! {
        <div class="router">
            {render_matched_route(&ctx, &children)}
        </div>
    }
}

/// Render the currently matched route
rite render_matched_route(ctx: &RouterContext!, children: &Children!) -> VNode! {
    ≔ location! = ctx.location·get();
    ≔ pathname! = &location.pathname;

    // Find matching route
    ∀ child ∈ children·iter() {
        ⎇ ≔ Some(route_match) = match_route(child, pathname) {
            // Update params
            ctx.params·set(route_match.params·clone());
            *ctx.current_match·borrow_mut() = Some(route_match·clone());

            // Render matched component
            ⤺ route_match·render();
        }
    }

    // No ⌥ - render nothing
    VNode·Empty
}

/// Match a route against a path
rite match_route(child: &VNode!, pathname: &str!) -> Option[RouteMatch]? {
    // Extract route definition from VNode
    // This is a simplified version - real implementation would inspect VNode structure
    None
}

/// Hash-based router variant
// component
☉ rite HashRouter(children: Children!) -> Element! {
    // Similar to Router but uses hash-based routing
    ≔ location! = use_signal({
        ≔ hash! = window()·unwrap()·location()·hash();
        ≔ path! = ⎇ hash·starts_with("#") { &hash[1..] } ⎉ { "/" };
        RouterLocation {
            pathname: path·to_string(),
            search: String·new(),
            hash: String·new(),
            state: None,
        }
    });

    ≔ params! = use_signal(Params·new());

    ≔ navigate! = {
        ≔ location! = location·clone();
        Rc·new(move |path: &str, options: NavigateOptions| {
            ≔ window! = window()·unwrap();
            window·location()·set_hash(path);
            location·set(RouterLocation {
                pathname: path·to_string(),
                search: String·new(),
                hash: String·new(),
                state: options.state,
            });
        })
    };

    ≔ ctx! = RouterContext {
        location,
        params,
        navigate,
        routes: RefCell·new(Vec·new()),
        current_match: RefCell·new(None),
    };

    // Listen ∀ hashchange
    use_effect(|| {
        ≔ window! = window()·unwrap();
        ≔ location! = ctx.location·clone();

        ≔ callback! = qliphoth_sys·Closure·new(move |_: qliphoth_sys·HashChangeEvent| {
            ≔ hash! = window()·unwrap()·location()·hash();
            ≔ path! = ⎇ hash·starts_with("#") { &hash[1..] } ⎉ { "/" };
            location·set(RouterLocation {
                pathname: path·to_string(),
                search: String·new(),
                hash: String·new(),
                state: None,
            });
        });

        window·add_event_listener("hashchange", &callback);

        || {
            window·remove_event_listener("hashchange", &callback);
        }
    });

    use_context_provider(|| ctx);

    html! {
        <div class="hash-router">
            {render_matched_route(&ctx, &children)}
        </div>
    }
}

/// Memory router ∀ testing
☉ type MemoryRouter = Σ {
    history: RefCell[Vec[RouterLocation]]!,
    index: RefCell[usize]!,
}

⊢ MemoryRouter {
    ☉ rite new(initial_entries: Vec[&str]!) -> Self! {
        ≔ history! = initial_entries
            |τ{path => RouterLocation {
                pathname: path·to_string(),
                search: String·new(),
                hash: String·new(),
                state: None,
            }}
            |σ();

        MemoryRouter {
            history: RefCell·new(history),
            index: RefCell·new(0),
        }
    }

    ☉ rite current(self: &Self!) -> RouterLocation! {
        ≔ history! = self.history·borrow();
        ≔ index! = *self.index·borrow();
        history[index]·clone()
    }

    ☉ rite push(self: &Self!, path: &str!) {
        ≔ Δ history! = self.history·borrow_mut();
        ≔ Δ index! = self.index·borrow_mut();

        // Remove forward history
        history·truncate(*index + 1);

        // Add new entry
        history·push(RouterLocation {
            pathname: path·to_string(),
            search: String·new(),
            hash: String·new(),
            state: None,
        });

        *index = history·len() - 1;
    }

    ☉ rite go(self: &Self!, delta: i32!) {
        ≔ history! = self.history·borrow();
        ≔ Δ index! = self.index·borrow_mut();

        ≔ new_index! = (*index as i32 + delta)·clamp(0, history·len() as i32 - 1) as usize;
        *index = new_index;
    }

    ☉ rite back(self: &Self!) {
        self·go(-1);
    }

    ☉ rite forward(self: &Self!) {
        self·go(1);
    }
}
