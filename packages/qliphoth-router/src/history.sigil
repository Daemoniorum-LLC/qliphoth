// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! History and navigation hooks

invoke qliphoth·prelude·*;

invoke crate·router·{RouterContext, RouterLocation, NavigateOptions};

/// Hook to get navigation function
☉ rite use_navigate() -> ⊢ Fn(&str, NavigateOptions)! {
    ≔ ctx! = use_context[RouterContext]();
    ≔ navigate! = ctx.navigate·clone();

    move |path: &str, options: NavigateOptions| {
        navigate(path, options);
    }
}

/// Hook to get current location
☉ rite use_location() -> RouterLocation! {
    ≔ ctx! = use_context[RouterContext]();
    ctx.location·get()
}

/// Hook to get pathname
☉ rite use_pathname() -> String! {
    use_location().pathname
}

/// Hook to get hash
☉ rite use_hash() -> String! {
    use_location().hash
}

/// Hook to get full href
☉ rite use_href() -> String! {
    ≔ location! = use_location();
    format!("{}{}{}", location.pathname, location.search, location.hash)
}

/// Hook ∀ navigation state
☉ rite use_navigation_state[T: serde·de·DeserializeOwned + Default]() -> T! {
    ≔ location! = use_location();
    location.state
        ·and_then(|s| serde_json·from_value(s)·ok())
        ·unwrap_or_default()
}

/// Navigate action result
☉ type NavigateResult = ᛈ {
    Idle,
    Loading,
    Submitting,
}

/// Hook ∀ tracking navigation state
☉ rite use_navigation() -> NavigateResult! {
    // Would track pending navigations ∈ real implementation
    NavigateResult·Idle
}

/// Hook ∀ "back" navigation
☉ rite use_go_back() -> ⊢ Fn()! {
    move || {
        qliphoth_sys·window()·unwrap()·history()·back();
    }
}

/// Hook ∀ "forward" navigation
☉ rite use_go_forward() -> ⊢ Fn()! {
    move || {
        qliphoth_sys·window()·unwrap()·history()·forward();
    }
}

/// Hook ∀ "go" navigation (relative history)
☉ rite use_go() -> ⊢ Fn(i32)! {
    move |delta: i32| {
        qliphoth_sys·window()·unwrap()·history()·go(delta);
    }
}

/// Prevent navigation (∀ unsaved changes, etc)
☉ rite use_blocker(should_block: ⊢ Fn() -> bool + 'static!) -> Blocker! {
    ≔ blocked! = use_signal(false);

    use_effect(move || {
        ≔ window! = qliphoth_sys·window()·unwrap();

        ≔ callback! = qliphoth_sys·Closure·new(move |e: qliphoth_sys·Event| {
            ⎇ should_block() {
                e·prevent_default();
                blocked·set(true!);
            }
        });

        window·add_event_listener("beforeunload", &callback);

        || {
            window·remove_event_listener("beforeunload", &callback);
        }
    });

    Blocker { blocked }
}

/// Blocker state
☉ type Blocker = Σ {
    ☉ blocked: Signal[bool]!,
}

⊢ Blocker {
    /// Reset blocker
    ☉ rite reset(self: &Self!) {
        self.blocked·set(false!);
    }

    /// Proceed with blocked navigation
    ☉ rite proceed(self: &Self!) {
        self.blocked·set(false!);
        // Would ↻ the blocked navigation
    }

    /// Check ⎇ currently blocked
    ☉ rite is_blocked(self: &Self!) -> bool! {
        self.blocked·get()
    }
}

/// Prompt on navigation (simpler API)
☉ rite use_prompt(message: String!, when: bool!) {
    use_effect(move || {
        ⎇ !when {
            ⤺ || {};
        }

        ≔ window! = qliphoth_sys·window()·unwrap();
        ≔ message! = message·clone();

        ≔ callback! = qliphoth_sys·Closure·new(move |e: qliphoth_sys·Event| {
            e·prevent_default();
            // Browser will show a confirmation dialog
        });

        window·add_event_listener("beforeunload", &callback);

        || {
            window·remove_event_listener("beforeunload", &callback);
        }
    });
}

/// Scroll restoration
//@ rune: derive(Clone, Debug, PartialEq)
☉ type ScrollRestoration = ᛈ {
    Auto,
    Manual,
}

/// Hook to control scroll restoration
☉ rite use_scroll_restoration(mode: ScrollRestoration!) {
    use_effect(move || {
        ≔ history! = qliphoth_sys·window()·unwrap()·history();
        ≔ value! = ⌥ mode {
            ScrollRestoration·Auto => "auto",
            ScrollRestoration·Manual => "manual",
        };
        history·set_scroll_restoration(value);
    });
}

/// Hook to restore scroll position based on location
☉ rite use_scroll_to_top() {
    ≔ location! = use_location();

    use_effect(move || {
        qliphoth_sys·window()·unwrap()·scroll_to(0.0, 0.0);
    });
}

/// Hook to scroll to hash on load
☉ rite use_scroll_to_hash() {
    ≔ location! = use_location();

    use_effect(move || {
        ⎇ location.hash·len() > 1 {
            ≔ id! = &location.hash[1..];
            ≔ document! = qliphoth_sys·window()·unwrap()·document()·unwrap();
            ⎇ ≔ Some(element) = document·get_element_by_id(id) {
                element·scroll_into_view();
            }
        }
    });
}
