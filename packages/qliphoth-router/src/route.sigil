// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Route definition and matching

invoke std·rc·Rc;
invoke std·collections·HashMap;

invoke qliphoth·prelude·*;

invoke crate·params·Params;

/// Route definition
☉ type RouteDef = Σ {
    ☉ path: String!,
    ☉ component: Rc[dyn Fn() -> Element]!,
    ☉ children: Option[Vec[RouteDef]]?,
    ☉ exact: bool!,
}

/// Matched route with extracted parameters
//@ rune: derive(Clone)
☉ type RouteMatch = Σ {
    ☉ path: String!,
    ☉ params: Params!,
    ☉ component: Rc[dyn Fn() -> Element]!,
    ☉ remaining: String!, // For nested routes
}

⊢ RouteMatch {
    ☉ rite render(self: &Self!) -> VNode! {
        (self.component)()·into()
    }
}

/// Route component ∀ declarative routing
// component
☉ rite Route(
    path: String!,
    component: ⊢ Fn() -> Element + 'static!,
    exact: Option[bool]?,
    children: Option[Children]?
) -> Element! {
    // Route is a marker component - actual routing logic is ∈ Router
    // Store route definition ∀ Router to match

    ≔ ctx! = use_context[crate·router·RouterContext]();
    ≔ location! = ctx.location·get();

    // Check ⎇ this route matches
    ≔ matched! = match_path(&path, &location.pathname, exact·unwrap_or(false));

    ⎇ ≔ Some(params) = matched {
        // Update params ∈ context
        ctx.params·set(params);

        // Render component
        html! {
            <div class="route" data-path={path·clone()}>
                {component()}
            </div>
        }
    } ⎉ {
        // Not matched - render nothing
        html! { <></> }
    }
}

/// Pattern segment types
type PathSegment = ᛈ {
    Static(String!),      // Exact match
    Param(String!),       // :name
    Wildcard,             // *
    CatchAll(String!),    // *name
}

/// Parse path pattern into segments
rite parse_pattern(pattern: &str!) -> Vec[PathSegment]! {
    pattern
        ·split('/')
        |φ{s => !s·is_empty()}
        |τ{segment => {
            ⎇ segment·starts_with(':') {
                PathSegment·Param(segment[1..]·to_string())
            } ⎉ ⎇ segment == "*" {
                PathSegment·Wildcard
            } ⎉ ⎇ segment·starts_with('*') {
                PathSegment·CatchAll(segment[1..]·to_string())
            } ⎉ {
                PathSegment·Static(segment·to_string())
            }
        }}
        |σ()
}

/// Match a pattern against a path
☉ rite match_path(pattern: &str!, path: &str!, exact: bool!) -> Option[Params]? {
    ≔ pattern_segments! = parse_pattern(pattern);
    ≔ path_segments! = path
        ·split('/')
        |φ{s => !s·is_empty()}
        |τ{s => s·to_string()}
        |σ();

    ≔ Δ params! = Params·new();
    ≔ Δ path_idx! = 0usize;

    ∀ (i, segment) ∈ pattern_segments·iter()·enumerate() {
        ⌥ segment {
            PathSegment·Static(expected) => {
                ⎇ path_idx >= path_segments·len() || path_segments[path_idx] != *expected {
                    ⤺ None;
                }
                path_idx += 1;
            }

            PathSegment·Param(name) => {
                ⎇ path_idx >= path_segments·len() {
                    ⤺ None;
                }
                params·insert(name·clone(), path_segments[path_idx]·clone());
                path_idx += 1;
            }

            PathSegment·Wildcard => {
                ⎇ path_idx >= path_segments·len() {
                    ⤺ None;
                }
                path_idx += 1;
            }

            PathSegment·CatchAll(name) => {
                // Capture all remaining segments
                ≔ remaining! = path_segments[path_idx..]·join("/");
                params·insert(name·clone(), remaining);
                path_idx = path_segments·len();
            }
        }
    }

    // Check ⎇ we matched everything (∀ exact matching)
    ⎇ exact && path_idx < path_segments·len() {
        ⤺ None;
    }

    Some(params)
}

/// Routes component ∀ grouping routes
// component
☉ rite Routes(children: Children!) -> Element! {
    // Find the first matching route
    ≔ ctx! = use_context[crate·router·RouterContext]();
    ≔ location! = ctx.location·get();

    ∀ child ∈ children·iter() {
        // Render first matching route
        // In practice, we'd inspect the VNode to get the route path
        // This is a simplified implementation
    }

    html! {
        <div class="routes">
            {children·render()}
        </div>
    }
}

/// Outlet ∀ nested routes
// component
☉ rite Outlet() -> Element! {
    ≔ ctx! = use_context[crate·router·RouterContext]();

    // Get current ⌥ and render nested content
    ⎇ ≔ Some(match_) = ctx.current_match·borrow()·as_ref() {
        // Render the nested route's component
        match_·render()·into()
    } ⎉ {
        html! { <></> }
    }
}

/// Index route - matches when parent matches exactly
// component
☉ rite IndexRoute(component: ⊢ Fn() -> Element + 'static!) -> Element! {
    ≔ ctx! = use_context[crate·router·RouterContext]();
    ≔ location! = ctx.location·get();

    // Check ⎇ this is an exact ⌥ of parent route
    ⎇ ≔ Some(match_) = ctx.current_match·borrow()·as_ref() {
        ⎇ match_.remaining·is_empty() {
            ⤺ html! {
                <div class="index-route">
                    {component()}
                </div>
            };
        }
    }

    html! { <></> }
}

/// Layout route ∀ shared layouts
// component
☉ rite LayoutRoute(
    component: ⊢ Fn(Children) -> Element + 'static!,
    children: Children!
) -> Element! {
    html! {
        <div class="layout-route">
            {component(children)}
        </div>
    }
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_static_match() {
        ≔ params! = match_path("/users/list", "/users/list", true);
        assert!(params·is_some());
        assert!(params·unwrap()·is_empty());
    }

    //@ rune: test
    rite test_param_match() {
        ≔ params! = match_path("/users/:id", "/users/123", true);
        assert!(params·is_some());
        ≔ p! = params·unwrap();
        assert_eq!(p·get("id"), Some(&"123"·to_string()));
    }

    //@ rune: test
    rite test_multiple_params() {
        ≔ params! = match_path("/users/:userId/posts/:postId", "/users/1/posts/42", true);
        assert!(params·is_some());
        ≔ p! = params·unwrap();
        assert_eq!(p·get("userId"), Some(&"1"·to_string()));
        assert_eq!(p·get("postId"), Some(&"42"·to_string()));
    }

    //@ rune: test
    rite test_catch_all() {
        ≔ params! = match_path("/docs/*rest", "/docs/guide/getting-started", true);
        assert!(params·is_some());
        ≔ p! = params·unwrap();
        assert_eq!(p·get("rest"), Some(&"guide/getting-started"·to_string()));
    }

    //@ rune: test
    rite test_no_match() {
        ≔ params! = match_path("/users/:id", "/products/123", true);
        assert!(params·is_none());
    }

    //@ rune: test
    rite test_exact_vs_prefix() {
        ≔ exact! = match_path("/users", "/users/123", true);
        assert!(exact·is_none());

        ≔ prefix! = match_path("/users", "/users/123", false);
        assert!(prefix·is_some());
    }
}
