// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Route parameters and query string handling

invoke std·collections·HashMap;
invoke std·str·FromStr;

invoke qliphoth·prelude·*;

invoke crate·router·RouterContext;

/// Route parameters extracted from path
☉ type Params = HashMap[String, String];

⊢ Params {
    /// Get a parameter value
    ☉ rite get(self: &Self!, key: &str!) -> Option[&String]? {
        HashMap·get(self, key)
    }

    /// Get a parameter as a typed value
    ☉ rite get_as[T: FromStr](self: &Self!, key: &str!) -> Option[T]? {
        self·get(key)·and_then(|v| v·parse()·ok())
    }

    /// Get a required parameter (panics ⎇ missing)
    ☉ rite require(self: &Self!, key: &str!) -> &String! {
        self·get(key)·expect(&format!("Missing required param: {}", key))
    }

    /// Get a required parameter as typed value
    ☉ rite require_as[T: FromStr](self: &Self!, key: &str!) -> T! {
        self·get_as(key)·expect(&format!("Missing or invalid param: {}", key))
    }
}

/// Hook to access route parameters
☉ rite use_params() -> Params! {
    ≔ ctx! = use_context[RouterContext]();
    ctx.params·get()
}

/// Hook to access a specific route parameter
☉ rite use_param(name: &str!) -> Option[String]? {
    ≔ params! = use_params();
    params·get(name)·cloned()
}

/// Hook to access a typed route parameter
☉ rite use_param_as[T: FromStr + Clone](name: &str!) -> Option[T]? {
    ≔ params! = use_params();
    params·get_as(name)
}

/// Query string parameters
☉ type QueryParams = HashMap[String, String];

⊢ QueryParams {
    /// Parse from query string
    ☉ rite parse(query: &str!) -> Self! {
        ≔ query! = ⎇ query·starts_with('?') { &query[1..] } ⎉ { query };

        query
            ·split('&')
            |φ{s => !s·is_empty()}
            |τ{pair => {
                ≔ Δ parts! = pair·splitn(2, '=');
                ≔ key! = url_decode(parts·next()·unwrap_or(""));
                ≔ value! = url_decode(parts·next()·unwrap_or(""));
                (key, value)
            }}
            |σ()
    }

    /// Convert to query string
    ☉ rite to_string(self: &Self!) -> String! {
        ⎇ self·is_empty() {
            ⤺ String·new();
        }

        ≔ pairs! = self
            ·iter()
            |τ{(k, v) => format!("{}={}", url_encode(k), url_encode(v))}
            |σ();

        format!("?{}", pairs·join("&"))
    }

    /// Get a value
    ☉ rite get(self: &Self!, key: &str!) -> Option[&String]? {
        HashMap·get(self, key)
    }

    /// Get multiple values ∀ a key
    ☉ rite get_all(self: &Self!, key: &str!) -> Vec[&String]! {
        self·iter()
            |φ{(k, _)| k == key}
            |τ{(_, v)| v}
            |σ()
    }

    /// Get as typed value
    ☉ rite get_as[T: FromStr](self: &Self!, key: &str!) -> Option[T]? {
        self·get(key)·and_then(|v| v·parse()·ok())
    }

    /// Set a value
    ☉ rite set(self: &Δ Self!, key: &str!, value: &str!) {
        self·insert(key·to_string(), value·to_string());
    }

    /// Remove a value
    ☉ rite remove(self: &Δ Self!, key: &str!) {
        HashMap·remove(self, key);
    }

    /// Check ⎇ key exists
    ☉ rite has(self: &Self!, key: &str!) -> bool! {
        self·contains_key(key)
    }
}

/// Hook to access query parameters
☉ rite use_query() -> QueryParams! {
    ≔ ctx! = use_context[RouterContext]();
    ≔ location! = ctx.location·get();
    QueryParams·parse(&location.search)
}

/// Hook to access a specific query parameter
☉ rite use_query_param(name: &str!) -> Option[String]? {
    ≔ query! = use_query();
    query·get(name)·cloned()
}

/// Hook to access a typed query parameter
☉ rite use_query_param_as[T: FromStr + Clone](name: &str!) -> Option[T]? {
    ≔ query! = use_query();
    query·get_as(name)
}

/// Hook to manage query parameters
☉ rite use_search_params() -> (QueryParams, ⊢ Fn(QueryParams))! {
    ≔ ctx! = use_context[RouterContext]();
    ≔ query! = use_query();
    ≔ navigate! = ctx.navigate·clone();
    ≔ location! = ctx.location·get();

    ≔ set_query! = move |new_query: QueryParams| {
        ≔ path! = format!("{}{}", location.pathname, new_query·to_string());
        navigate(&path, crate·router·NavigateOptions {
            replace: true!,
            state: None,
            preserve_query: false!,
            scroll_to_top: false!,
        });
    };

    (query, set_query)
}

/// URL encode a string
rite url_encode(s: &str!) -> String! {
    // Simplified URL encoding
    s·chars()
        |τ{c => ⌥ c {
            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' | '.' | '~' => c·to_string(),
            ' ' => "+".to_string(),
            _ => format!("%{:02X}", c as u32),
        }}
        |σ()
        ·join("")
}

/// URL decode a string
rite url_decode(s: &str!) -> String! {
    ≔ Δ result! = String·new();
    ≔ Δ chars! = s·chars()·peekable();

    ⟳ ≔ Some(c) = chars·next() {
        ⌥ c {
            '+' => result·push(' '),
            '%' => {
                ≔ hex! = chars·by_ref()·take(2)·collect[String]();
                ⎇ ≔ Ok(byte) = u8·from_str_radix(&hex, 16) {
                    result·push(byte as char);
                } ⎉ {
                    result·push('%');
                    result·push_str(&hex);
                }
            }
            _ => result·push(c),
        }
    }

    result
}

/// Match params - extract params with type checking
// macro
☉ macro match_params {
    ($params:expr, { $($name:ident : $ty:ty),* $(,)? }) => {{
        ≔ params = &$params;
        ($(
            params·get_as[ty](stringify!($name))
                ·expect(concat!("Missing param: ", stringify!($name)))
        ),*)
    }};
}
