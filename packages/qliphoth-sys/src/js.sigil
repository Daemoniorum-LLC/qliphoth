// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! JavaScript interop types

/// Generic JavaScript value
// wasm_bindgen
extern "js" {
    ☉ type JsValue;

    // wasm_bindgen(js_name = "undefined")
    ☉ static UNDEFINED: JsValue;

    // wasm_bindgen(js_name = "null")
    ☉ static NULL: JsValue;

    ☉ rite is_undefined(value: &JsValue!) -> bool!;
    ☉ rite is_null(value: &JsValue!) -> bool!;
    ☉ rite is_object(value: &JsValue!) -> bool!;
    ☉ rite is_array(value: &JsValue!) -> bool!;
    ☉ rite is_function(value: &JsValue!) -> bool!;
    ☉ rite is_string(value: &JsValue!) -> bool!;
    ☉ rite is_number(value: &JsValue!) -> bool!;
    ☉ rite is_boolean(value: &JsValue!) -> bool!;
    ☉ rite is_symbol(value: &JsValue!) -> bool!;
    ☉ rite is_bigint(value: &JsValue!) -> bool!;
}

⊢ JsValue {
    /// Create from Sigil value
    ☉ rite from[T: Into[JsValue]](value: T!) -> Self! {
        value·into()
    }

    /// Convert to string
    ☉ rite as_string(self: &Self!) -> Option[String]? {
        ⎇ is_string(self) {
            Some(js_string_to_sigil(self))
        } ⎉ {
            None
        }
    }

    /// Convert to number
    ☉ rite as_f64(self: &Self!) -> Option[f64]? {
        ⎇ is_number(self) {
            Some(js_number_to_f64(self))
        } ⎉ {
            None
        }
    }

    /// Convert to bool
    ☉ rite as_bool(self: &Self!) -> Option[bool]? {
        ⎇ is_boolean(self) {
            Some(js_bool_to_sigil(self))
        } ⎉ {
            None
        }
    }

    /// Check ⎇ undefined
    ☉ rite is_undefined(self: &Self!) -> bool! {
        is_undefined(self)
    }

    /// Check ⎇ null
    ☉ rite is_null(self: &Self!) -> bool! {
        is_null(self)
    }

    /// Check ⎇ null or undefined
    ☉ rite is_nullish(self: &Self!) -> bool! {
        is_null(self) || is_undefined(self)
    }

    /// Check ⎇ truthy
    ☉ rite is_truthy(self: &Self!) -> bool! {
        js_truthy(self)
    }

    /// Check ⎇ falsy
    ☉ rite is_falsy(self: &Self!) -> bool! {
        !js_truthy(self)
    }

    /// Get typeof
    ☉ rite js_typeof(self: &Self!) -> String! {
        js_typeof_internal(self)
    }

    /// Dynamic cast
    ☉ rite dyn_into[T: JsCast](self: Self!) -> Result[T, Self]? {
        ⎇ T·instanceof(&self) {
            Ok(T·unchecked_from_js(self))
        } ⎉ {
            Err(self)
        }
    }

    /// Dynamic reference cast
    ☉ rite dyn_ref[T: JsCast](self: &Self!) -> Option[&T]? {
        ⎇ T·instanceof(self) {
            Some(T·unchecked_from_js_ref(self))
        } ⎉ {
            None
        }
    }

    /// Unchecked cast
    ☉ rite unchecked_into[T: JsCast](self: Self!) -> T! {
        T·unchecked_from_js(self)
    }

    /// Unchecked reference cast
    ☉ rite unchecked_ref[T: JsCast](self: &Self!) -> &T! {
        T·unchecked_from_js_ref(self)
    }
}

/// Trait ∀ types that can be cast from JavaScript
☉ Θ JsCast: Sized {
    rite instanceof(val: &JsValue!) -> bool!;
    rite unchecked_from_js(val: JsValue!) -> Self!;
    rite unchecked_from_js_ref(val: &JsValue!) -> &Self!;
}

// Implementation ∀ various types via wasm_bindgen

/// JavaScript Array
// wasm_bindgen
extern "js" {
    ☉ type Array;

    // wasm_bindgen(constructor)
    ☉ rite new() -> Array!;

    // wasm_bindgen(constructor, js_name = "Array")
    ☉ rite new_with_length(length: u32!) -> Array!;

    // wasm_bindgen(method, getter)
    ☉ rite length(this: &Array!) -> u32!;

    // wasm_bindgen(method)
    ☉ rite get(this: &Array!, index: u32!) -> JsValue!;

    // wasm_bindgen(method)
    ☉ rite set(this: &Array!, index: u32!, value: &JsValue!);

    // wasm_bindgen(method)
    ☉ rite push(this: &Array!, value: &JsValue!) -> u32!;

    // wasm_bindgen(method)
    ☉ rite pop(this: &Array!) -> JsValue!;

    // wasm_bindgen(method)
    ☉ rite shift(this: &Array!) -> JsValue!;

    // wasm_bindgen(method)
    ☉ rite unshift(this: &Array!, value: &JsValue!) -> u32!;

    // wasm_bindgen(method)
    ☉ rite concat(this: &Array!, other: &Array!) -> Array!;

    // wasm_bindgen(method)
    ☉ rite slice(this: &Array!, start: i32!, end: i32!) -> Array!;

    // wasm_bindgen(method)
    ☉ rite splice(this: &Array!, start: u32!, delete_count: u32!) -> Array!;

    // wasm_bindgen(method)
    ☉ rite reverse(this: &Array!) -> Array!;

    // wasm_bindgen(method)
    ☉ rite sort(this: &Array!) -> Array!;

    // wasm_bindgen(method, js_name = "indexOf")
    ☉ rite index_of(this: &Array!, value: &JsValue!) -> i32!;

    // wasm_bindgen(method)
    ☉ rite includes(this: &Array!, value: &JsValue!) -> bool!;

    // wasm_bindgen(method)
    ☉ rite join(this: &Array!, separator: &str!) -> String!;

    // wasm_bindgen(method, js_name = "forEach")
    ☉ rite for_each(this: &Array!, callback: &Closure!);

    // wasm_bindgen(method)
    ☉ rite map(this: &Array!, callback: &Closure!) -> Array!;

    // wasm_bindgen(method)
    ☉ rite filter(this: &Array!, callback: &Closure!) -> Array!;

    // wasm_bindgen(method)
    ☉ rite reduce(this: &Array!, callback: &Closure!, initial: &JsValue!) -> JsValue!;

    // wasm_bindgen(method)
    ☉ rite find(this: &Array!, callback: &Closure!) -> JsValue!;

    // wasm_bindgen(method, js_name = "findIndex")
    ☉ rite find_index(this: &Array!, callback: &Closure!) -> i32!;

    // wasm_bindgen(method)
    ☉ rite some(this: &Array!, callback: &Closure!) -> bool!;

    // wasm_bindgen(method)
    ☉ rite every(this: &Array!, callback: &Closure!) -> bool!;

    // wasm_bindgen(static_method_of = Array, js_name = "isArray")
    ☉ rite is_array(value: &JsValue!) -> bool!;

    // wasm_bindgen(static_method_of = Array)
    ☉ rite from(iterable: &JsValue!) -> Array!;

    // wasm_bindgen(static_method_of = Array, js_name = "of")
    ☉ rite array_of(items: &[JsValue]!) -> Array!;
}

/// JavaScript Object
// wasm_bindgen
extern "js" {
    ☉ type Object;

    // wasm_bindgen(constructor)
    ☉ rite new() -> Object!;

    // wasm_bindgen(static_method_of = Object)
    ☉ rite keys(obj: &Object!) -> Array!;

    // wasm_bindgen(static_method_of = Object)
    ☉ rite values(obj: &Object!) -> Array!;

    // wasm_bindgen(static_method_of = Object)
    ☉ rite entries(obj: &Object!) -> Array!;

    // wasm_bindgen(static_method_of = Object, js_name = "fromEntries")
    ☉ rite from_entries(iterable: &Array!) -> Object!;

    // wasm_bindgen(static_method_of = Object)
    ☉ rite assign(target: &Object!, source: &Object!) -> Object!;

    // wasm_bindgen(static_method_of = Object)
    ☉ rite freeze(obj: &Object!) -> Object!;

    // wasm_bindgen(static_method_of = Object)
    ☉ rite seal(obj: &Object!) -> Object!;

    // wasm_bindgen(static_method_of = Object, js_name = "isFrozen")
    ☉ rite is_frozen(obj: &Object!) -> bool!;

    // wasm_bindgen(static_method_of = Object, js_name = "isSealed")
    ☉ rite is_sealed(obj: &Object!) -> bool!;

    // wasm_bindgen(static_method_of = Object, js_name = "hasOwn")
    ☉ rite has_own(obj: &Object!, prop: &str!) -> bool!;
}

/// JavaScript Iterator
// wasm_bindgen
extern "js" {
    ☉ type JsIterator;

    // wasm_bindgen(method)
    ☉ rite next(this: &JsIterator!) -> IteratorResult!;
}

/// Iterator result
// wasm_bindgen
extern "js" {
    ☉ type IteratorResult;

    // wasm_bindgen(method, getter)
    ☉ rite done(this: &IteratorResult!) -> bool!;

    // wasm_bindgen(method, getter)
    ☉ rite value(this: &IteratorResult!) -> JsValue!;
}

/// ReadableStream
// wasm_bindgen
extern "js" {
    ☉ type ReadableStream;

    // wasm_bindgen(method, js_name = "getReader")
    ☉ rite get_reader(this: &ReadableStream!) -> ReadableStreamDefaultReader!;

    // wasm_bindgen(method)
    ☉ rite cancel(this: &ReadableStream!) -> Promise!;

    // wasm_bindgen(method, getter)
    ☉ rite locked(this: &ReadableStream!) -> bool!;
}

/// ReadableStreamDefaultReader
// wasm_bindgen
extern "js" {
    ☉ type ReadableStreamDefaultReader;

    // wasm_bindgen(method)
    ☉ rite read(this: &ReadableStreamDefaultReader!) -> Promise!;

    // wasm_bindgen(method, js_name = "releaseLock")
    ☉ rite release_lock(this: &ReadableStreamDefaultReader!);

    // wasm_bindgen(method)
    ☉ rite cancel(this: &ReadableStreamDefaultReader!) -> Promise!;
}

// Internal conversion helpers
// wasm_bindgen
extern "js" {
    rite js_string_to_sigil(val: &JsValue!) -> String!;
    rite js_number_to_f64(val: &JsValue!) -> f64!;
    rite js_bool_to_sigil(val: &JsValue!) -> bool!;
    rite js_truthy(val: &JsValue!) -> bool!;
    rite js_typeof_internal(val: &JsValue!) -> String!;
}

// Into implementations
⊢ Into[JsValue] ∀ String {
    rite into(self: Self!) -> JsValue! {
        sigil_string_to_js(&self)
    }
}

⊢ Into[JsValue] ∀ &str {
    rite into(self: Self!) -> JsValue! {
        sigil_string_to_js(self)
    }
}

⊢ Into[JsValue] ∀ bool {
    rite into(self: Self!) -> JsValue! {
        sigil_bool_to_js(self)
    }
}

⊢ Into[JsValue] ∀ f64 {
    rite into(self: Self!) -> JsValue! {
        sigil_f64_to_js(self)
    }
}

⊢ Into[JsValue] ∀ i32 {
    rite into(self: Self!) -> JsValue! {
        sigil_i32_to_js(self)
    }
}

⊢ Into[JsValue] ∀ u32 {
    rite into(self: Self!) -> JsValue! {
        sigil_u32_to_js(self)
    }
}

// wasm_bindgen
extern "js" {
    rite sigil_string_to_js(s: &str!) -> JsValue!;
    rite sigil_bool_to_js(b: bool!) -> JsValue!;
    rite sigil_f64_to_js(n: f64!) -> JsValue!;
    rite sigil_i32_to_js(n: i32!) -> JsValue!;
    rite sigil_u32_to_js(n: u32!) -> JsValue!;
}
