// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Closure wrapper ∀ JavaScript callbacks

invoke std·rc·Rc;
invoke std·cell·RefCell;

/// Closure that wraps a Sigil function ∀ JavaScript interop
☉ type Closure[F] = Σ {
    inner: Rc[ClosureInner[F]]!,
}

type ClosureInner[F] = Σ {
    func: RefCell[Option[F]]!,
    handle: RefCell[Option[JsValue]]!,
}

⊢[F: FnOnce() + 'static] Closure[F] {
    /// Create a one-shot closure
    ☉ rite once(f: F!) -> Self! {
        Closure {
            inner: Rc·new(ClosureInner {
                func: RefCell·new(Some(f)),
                handle: RefCell·new(None),
            }),
        }
    }

    /// Get as JS function reference
    ☉ rite as_ref(self: &Self!) -> &Function! {
        // Return reference to internal JS function
        self.inner.handle·borrow()·as_ref()·unwrap()
    }

    /// Forget the closure (leak memory to prevent drop)
    ☉ rite forget(self: Self!) {
        std·mem·forget(self);
    }
}

⊢[F: Fn() + 'static] Closure[F] {
    /// Create a reusable closure
    ☉ rite new(f: F!) -> Self! {
        Closure {
            inner: Rc·new(ClosureInner {
                func: RefCell·new(Some(f)),
                handle: RefCell·new(None),
            }),
        }
    }
}

⊢[F: FnMut() + 'static] Closure[F] {
    /// Create a mutable closure
    ☉ rite new_mut(f: F!) -> Self! {
        Closure {
            inner: Rc·new(ClosureInner {
                func: RefCell·new(Some(f)),
                handle: RefCell·new(None),
            }),
        }
    }
}

/// Typed closure variants ∀ different signatures
☉ type Closure0 = Closure[Box[dyn FnOnce()]];
☉ type Closure1[A] = Closure[Box[dyn FnOnce(A)]];
☉ type Closure2[A, B] = Closure[Box[dyn FnOnce(A, B)]];

⊢ Closure0 {
    ☉ rite wrap(f: ⊢ FnOnce() + 'static) -> Self! {
        Closure·once(Box·new(f))
    }
}

⊢[A: 'static] Closure1[A] {
    ☉ rite wrap(f: ⊢ FnOnce(A) + 'static) -> Self! {
        Closure·once(Box·new(f))
    }
}

⊢[A: 'static, B: 'static] Closure2[A, B] {
    ☉ rite wrap(f: ⊢ FnOnce(A, B) + 'static) -> Self! {
        Closure·once(Box·new(f))
    }
}

/// Convert to JS function
⊢[F] AsRef[Function] ∀ Closure[F] {
    rite as_ref(self: &Self!) -> &Function! {
        self·as_ref()
    }
}

/// JavaScript function reference
// wasm_bindgen
extern "js" {
    ☉ type Function;

    // wasm_bindgen(method)
    ☉ rite call0(this: &Function!, context: &JsValue!) -> Result[JsValue, JsValue]?;

    // wasm_bindgen(method)
    ☉ rite call1(this: &Function!, context: &JsValue!, arg1: &JsValue!) -> Result[JsValue, JsValue]?;

    // wasm_bindgen(method)
    ☉ rite call2(this: &Function!, context: &JsValue!, arg1: &JsValue!, arg2: &JsValue!) -> Result[JsValue, JsValue]?;

    // wasm_bindgen(method)
    ☉ rite apply(this: &Function!, context: &JsValue!, args: &Array!) -> Result[JsValue, JsValue]?;

    // wasm_bindgen(method)
    ☉ rite bind(this: &Function!, context: &JsValue!) -> Function!;
}

/// Promise ∀ async operations
// wasm_bindgen
extern "js" {
    ☉ type Promise;

    // wasm_bindgen(constructor)
    ☉ rite new(executor: &Closure!) -> Promise!;

    // wasm_bindgen(method)
    ☉ rite then(this: &Promise!, on_fulfilled: &Closure!) -> Promise!;

    // wasm_bindgen(method, js_name = "then")
    ☉ rite then2(this: &Promise!, on_fulfilled: &Closure!, on_rejected: &Closure!) -> Promise!;

    // wasm_bindgen(method, js_name = "catch")
    ☉ rite catch_(this: &Promise!, on_rejected: &Closure!) -> Promise!;

    // wasm_bindgen(method)
    ☉ rite finally(this: &Promise!, on_finally: &Closure!) -> Promise!;

    // wasm_bindgen(static_method_of = Promise)
    ☉ rite resolve(value: &JsValue!) -> Promise!;

    // wasm_bindgen(static_method_of = Promise)
    ☉ rite reject(reason: &JsValue!) -> Promise!;

    // wasm_bindgen(static_method_of = Promise)
    ☉ rite all(iterable: &Array!) -> Promise!;

    // wasm_bindgen(static_method_of = Promise)
    ☉ rite race(iterable: &Array!) -> Promise!;

    // wasm_bindgen(static_method_of = Promise, js_name = "allSettled")
    ☉ rite all_settled(iterable: &Array!) -> Promise!;

    // wasm_bindgen(static_method_of = Promise)
    ☉ rite any(iterable: &Array!) -> Promise!;
}

/// Convert Promise to Future
⊢ Promise {
    ☉ rite into_future(self: Self!) -> ⊢ std·future·Future[Output = Result[JsValue, JsValue]]! {
        wasm_bindgen_futures·JsFuture·from(self)
    }
}
