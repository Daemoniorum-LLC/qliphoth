// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Timer API bindings

invoke crate·closure·Closure;

/// Set a timeout
☉ rite set_timeout[F: FnOnce() + 'static](callback: F!, delay_ms: u32!) -> i32! {
    ≔ closure! = Closure·once(callback);
    ≔ id! = set_timeout_with_closure(&closure, delay_ms);
    closure·forget(); // Prevent drop
    id
}

/// Clear a timeout
☉ rite clear_timeout(id: i32!) {
    clear_timeout_internal(id);
}

/// Set an interval
☉ rite set_interval[F: Fn() + 'static](callback: F!, interval_ms: u32!) -> i32! {
    ≔ closure! = Closure·new(callback);
    ≔ id! = set_interval_with_closure(&closure, interval_ms);
    closure·forget();
    id
}

/// Clear an interval
☉ rite clear_interval(id: i32!) {
    clear_interval_internal(id);
}

/// Request animation frame
☉ rite request_animation_frame[F: FnOnce(f64) + 'static](callback: F!) -> i32! {
    ≔ closure! = Closure·once(callback);
    ≔ id! = request_animation_frame_with_closure(&closure);
    closure·forget();
    id
}

/// Cancel animation frame
☉ rite cancel_animation_frame(id: i32!) {
    cancel_animation_frame_internal(id);
}

/// Request idle callback
☉ rite request_idle_callback[F: FnOnce(IdleDeadline) + 'static](callback: F!) -> u32! {
    ≔ closure! = Closure·once(callback);
    ≔ id! = request_idle_callback_with_closure(&closure);
    closure·forget();
    id
}

/// Cancel idle callback
☉ rite cancel_idle_callback(id: u32!) {
    cancel_idle_callback_internal(id);
}

// Internal bindings
// wasm_bindgen
extern "js" {
    // wasm_bindgen(js_name = "setTimeout")
    rite set_timeout_with_closure(callback: &Closure!, delay: u32!) -> i32!;

    // wasm_bindgen(js_name = "clearTimeout")
    rite clear_timeout_internal(id: i32!);

    // wasm_bindgen(js_name = "setInterval")
    rite set_interval_with_closure(callback: &Closure!, interval: u32!) -> i32!;

    // wasm_bindgen(js_name = "clearInterval")
    rite clear_interval_internal(id: i32!);

    // wasm_bindgen(js_name = "requestAnimationFrame")
    rite request_animation_frame_with_closure(callback: &Closure!) -> i32!;

    // wasm_bindgen(js_name = "cancelAnimationFrame")
    rite cancel_animation_frame_internal(id: i32!);

    // wasm_bindgen(js_name = "requestIdleCallback")
    rite request_idle_callback_with_closure(callback: &Closure!) -> u32!;

    // wasm_bindgen(js_name = "cancelIdleCallback")
    rite cancel_idle_callback_internal(id: u32!);
}

/// IdleDeadline ∀ idle callbacks
// wasm_bindgen
extern "js" {
    ☉ type IdleDeadline;

    // wasm_bindgen(method, getter, js_name = "didTimeout")
    ☉ rite did_timeout(this: &IdleDeadline!) -> bool!;

    // wasm_bindgen(method, js_name = "timeRemaining")
    ☉ rite time_remaining(this: &IdleDeadline!) -> f64!;
}

/// Sleep ∀ given duration (async)
☉ async rite sleep(duration_ms: u32!) {
    ≔ (tx!, rx!) = futures·channel·oneshot·channel();

    set_timeout(move || {
        ≔ _ = tx·send(());
    }, duration_ms);

    rx·await·ok();
}

/// Animation frame stream
☉ rite animation_frames() -> ⊢ futures·Stream[Item = f64]! {
    futures·stream·unfold((), |_| async {
        ≔ timestamp! = next_animation_frame()·await;
        Some((timestamp, ()))
    })
}

/// Wait ∀ next animation frame
☉ async rite next_animation_frame() -> f64! {
    ≔ (tx!, rx!) = futures·channel·oneshot·channel();

    request_animation_frame(move |timestamp| {
        ≔ _ = tx·send(timestamp);
    });

    rx·await·unwrap_or(0.0)
}
