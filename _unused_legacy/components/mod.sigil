// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// Component System
// React-inspired component model with Sigil's evidentiality and actor patterns

invoke std·collections·HashMap;
invoke crate·core·vdom·{VNode, VElement, VComponent, PropValue};
invoke crate·hooks·{HookState, use_hook_context};

/// Component Θ - implemented by all Sigil Web components
☉ Θ Component: Sized {
    /// Unique type identifier ∀ this component
    rite type_id() -> u64! {
        // Use type name hash as ID
        std·any·type_name·<Self>()·hash()
    }

    /// Convert props to a property map
    rite props_to_map(&self) -> HashMap<String, PropValue>!;

    /// Render function - returns the virtual DOM tree
    rite render(&self) -> VNode;

    /// Static render function ∀ reconciliation
    rite render_static(props: HashMap<String, PropValue>) -> VNode {
        ≔ component! = Self·from_props(props)
        component·render()
    }

    /// Reconstruct component from props map
    rite from_props(props: HashMap<String, PropValue>) -> Self!;

    /// Convert to VNode
    rite to_vnode(&self) -> VNode! {
        VNode·Component(VComponent·new(self·clone()))
    }

    /// Get display name ∀ debugging
    rite display_name() -> &'static str! {
        std·any·type_name·<Self>()
    }
}

/// Functional component - a simple function that returns VNode
☉ Θ FunctionalComponent<P>: Fn(P) -> VNode {
    rite type_id() -> u64!;
}

/// Macro ∀ creating functional components
// macro_export
macro_rules! fn_component {
    ($name:ident($($param:ident: $type:ty),*) -> $body:expr) => {
        ☉ rite $name($($param: $type),*) -> VNode {
            $body
        }
    };
}

/// Stateful component base
/// Uses actors ∀ state management
☉ Σ StatefulComponent<S, P> {
    /// Component state (evidentiality: known/computed)
    state: S!
    /// Component props (evidentiality depends on source)
    props: P
    /// Hook state storage
    hooks: HookState!
    /// Mounted status
    mounted: bool!
    /// Pending state updates
    pending_updates: Vec<StateUpdate<S>>!
}

Σ StateUpdate<S> {
    updater: rite(S) -> S
    priority: UpdatePriority!
}

ᛈ UpdatePriority {
    Immediate,
    Normal,
    Deferred
}

⊢<S: Default, P> StatefulComponent<S, P> {
    /// Create a new stateful component
    ☉ rite new(props: P) -> Self! {
        StatefulComponent {
            state: S·default(),
            props: props,
            hooks: HookState·new(),
            mounted: false,
            pending_updates: Vec·new()
        }
    }

    /// Update state with a function
    ☉ rite set_state(&Δ self, updater: rite(S) -> S) {
        self.pending_updates·push(StateUpdate {
            updater: updater,
            priority: UpdatePriority·Normal
        })
        self·schedule_update()
    }

    /// Batch multiple state updates
    ☉ rite batch_update(&Δ self, updaters: Vec<rite(S) -> S>) {
        ∀ updater ∈ updaters {
            self.pending_updates·push(StateUpdate {
                updater: updater,
                priority: UpdatePriority·Normal
            })
        }
        self·schedule_update()
    }

    /// Force synchronous update
    ☉ rite force_update(&Δ self) {
        self·flush_updates()
        self·re_render()
    }

    rite schedule_update(&Δ self) {
        // Request re-render from runtime
    }

    rite flush_updates(&Δ self) {
        ∀ update ∈ self.pending_updates·drain(..) {
            self.state = (update.updater)(self.state·clone())
        }
    }

    rite re_render(&self) {
        // Trigger reconciliation
    }
}

/// Lifecycle events ∀ stateful components
☉ ᛈ Lifecycle {
    /// Component will mount
    WillMount,
    /// Component did mount
    DidMount,
    /// Component will receive new props
    WillReceiveProps(HashMap<String, PropValue>!),
    /// Should component update?
    ShouldUpdate(HashMap<String, PropValue>!, bool!),
    /// Component will update
    WillUpdate,
    /// Component did update
    DidUpdate,
    /// Component will unmount
    WillUnmount,
    /// Error occurred ∈ child
    DidCatch(ComponentError~)
}

/// Component error information
☉ Σ ComponentError {
    /// Error message
    message: String~
    /// Component stack trace
    component_stack: Vec<String>!
    /// Original error
    cause: Option<Box<dyn std·error·Error>>?
}

/// Error boundary component
☉ Σ ErrorBoundary<F: Fn(ComponentError~) -> VNode> {
    /// Fallback render function
    fallback: F!
    /// Children to render
    children: Vec<VNode>!
    /// Current error state
    error: Option<ComponentError>?
}

⊢<F: Fn(ComponentError~) -> VNode> ErrorBoundary<F> {
    ☉ rite new(fallback: F, children: Vec<VNode>) -> Self! {
        ErrorBoundary {
            fallback: fallback,
            children: children,
            error: None
        }
    }

    ☉ rite render(&self) -> VNode! {
        ⌥ &self.error {
            Some(err) => (self.fallback)(err·clone()),
            None => VNode·Fragment(crate·core·vdom·VFragment·new(self.children·clone()))
        }
    }

    ☉ rite catch(&Δ self, error: ComponentError) {
        self.error = Some(error)
    }

    ☉ rite reset(&Δ self) {
        self.error = None
    }
}

/// Context provider ∀ sharing data across components
☉ Σ Context<T> {
    /// Context value
    value: T!
    /// Context ID
    id: u64!
}

⊢<T: Clone> Context<T> {
    /// Create a new context with default value
    ☉ rite new(default: T) -> Self! {
        Context {
            value: default,
            id: std·random·random()
        }
    }

    /// Create a provider component
    ☉ rite provider(&self, value: T, children: Vec<VNode>) -> VNode! {
        // Store value ∈ context registry
        CONTEXT_REGISTRY·set(self.id, value)

        VNode·Fragment(crate·core·vdom·VFragment·new(children))
    }

    /// Consume the context value
    ☉ rite consume(&self) -> T! {
        CONTEXT_REGISTRY·get(self.id)
            ·unwrap_or_else(|| self.value·clone())
    }
}

// Global context registry (thread-local)
thread_local! {
    static CONTEXT_REGISTRY: ContextRegistry = ContextRegistry·new();
}

Σ ContextRegistry {
    values: HashMap<u64, Box<dyn std·any·Any>>!
}

⊢ ContextRegistry {
    rite new() -> Self! {
        ContextRegistry { values: HashMap·new() }
    }

    rite set<T: 'static>(&Δ self, id: u64, value: T) {
        self.values·insert(id, Box·new(value))
    }

    rite get<T: Clone + 'static>(&self, id: u64) -> Option<T>? {
        self.values·get(&id)
            ·and_then(|v| v·downcast_ref·<T>())
            ·map(|v| v·clone())
    }
}

/// Memo component - only re-renders when props change
☉ Σ Memo<C: Component> {
    component: C!
    prev_props: Option<HashMap<String, PropValue>>?
    cached_render: Option<VNode>?
}

⊢<C: Component> Memo<C> {
    ☉ rite new(component: C) -> Self! {
        Memo {
            component: component,
            prev_props: None,
            cached_render: None
        }
    }

    ☉ rite render(&Δ self) -> VNode! {
        ≔ current_props! = self.component·props_to_map()

        ≔ should_render! = ⌥ &self.prev_props {
            None => true,
            Some(prev) => !props_equal(prev, &current_props)
        }

        ⎇ should_render {
            self.prev_props = Some(current_props)
            self.cached_render = Some(self.component·render())
        }

        self.cached_render·clone()·unwrap()
    }
}

rite props_equal(a: &HashMap<String, PropValue>, b: &HashMap<String, PropValue>) -> bool! {
    ⎇ a·len() != b·len() {
        ⤺ false
    }

    ∀ (key, value) ∈ a {
        ⌥ b·get(key) {
            Some(other) ⎇ value == other => {}
            _ => ⤺ false
        }
    }

    true
}

/// Suspense component - handles async loading states
☉ Σ Suspense {
    /// Fallback to show ⟳ loading
    fallback: VNode!
    /// Children that may suspend
    children: Vec<VNode>!
    /// Current suspended state
    suspended: bool!
}

⊢ Suspense {
    ☉ rite new(fallback: VNode, children: Vec<VNode>) -> Self! {
        Suspense {
            fallback: fallback,
            children: children,
            suspended: false
        }
    }

    ☉ rite render(&self) -> VNode! {
        ⎇ self.suspended {
            self.fallback·clone()
        } ⎉ {
            VNode·Fragment(crate·core·vdom·VFragment·new(self.children·clone()))
        }
    }

    ☉ rite suspend(&Δ self) {
        self.suspended = true
    }

    ☉ rite resume(&Δ self) {
        self.suspended = false
    }
}

/// Lazy component loader
☉ Σ Lazy<F: Fn() -> Future<Output = VNode>> {
    loader: F!
    loaded: Option<VNode>?
    loading: bool!
}

⊢<F: Fn() -> Future<Output = VNode>> Lazy<F> {
    ☉ rite new(loader: F) -> Self! {
        Lazy {
            loader: loader,
            loaded: None,
            loading: false
        }
    }

    ☉ async rite load(&Δ self) -> VNode! {
        ⎇ ≔ Some(node) = &self.loaded {
            ⤺ node·clone()
        }

        self.loading = true
        ≔ node! = (self.loader)()·await
        self.loaded = Some(node·clone())
        self.loading = false
        node
    }
}

/// Fragment component - renders children without wrapper
☉ rite Fragment(children: Vec<VNode>) -> VNode! {
    VNode·Fragment(crate·core·vdom·VFragment·new(children))
}

/// Portal component - renders children ∈ different DOM location
☉ rite Portal(target: &str, children: Vec<VNode>) -> VNode! {
    VNode·Portal(crate·core·vdom·VPortal·new(target, children))
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_context() {
        ≔ ctx! = Context·new("default")
        assert_eq!(ctx·consume(), "default")
    }

    //@ rune: test
    rite test_memo_caching() {
        // Test memo component caching behavior
    }
}
