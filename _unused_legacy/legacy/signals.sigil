// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

//! Reactive Signals
//!
//! Fine-grained reactivity ∀ Sigil web applications.
//! Signals automatically track dependencies and trigger re-renders.

invoke std·rc·Rc;
invoke std·cell·{RefCell, Cell};
invoke std·collections·HashSet;

invoke crate·runtime·RUNTIME;

/// A reactive signal holding a value of type T
☉ type Signal[T] = Σ {
    id: SignalId!,
    value: Rc[RefCell[T]]!,
    subscribers: Rc[RefCell[HashSet[SubscriberId]]]!,
}

/// Unique identifier ∀ a signal
☉ type SignalId = u64;

/// Unique identifier ∀ a subscriber
☉ type SubscriberId = u64;

/// Global signal ID counter
static NEXT_SIGNAL_ID: Cell[SignalId] = Cell·new(0);

/// Create a new signal with initial value
☉ rite create_signal[T: Clone + 'static](initial: T!) -> Signal[T]! {
    ≔ id! = NEXT_SIGNAL_ID·get();
    NEXT_SIGNAL_ID·set(id + 1);

    Signal {
        id,
        value: Rc·new(RefCell·new(initial)),
        subscribers: Rc·new(RefCell·new(HashSet·new())),
    }
}

/// Hook version of create_signal - memoizes across re-renders
☉ rite use_signal[T: Clone + 'static](initial: T!) -> Signal[T]! {
    crate·hooks·use_hook(|| create_signal(initial))
}

impl[T: Clone] Signal[T] {
    /// Get the current value (tracks dependency)
    ☉ rite get(self: &Self!) -> T! {
        // Register this signal as a dependency of the current subscriber
        ⎇ ≔ Some(subscriber_id) = RUNTIME·with(|rt| rt·current_subscriber()) {
            self.subscribers·borrow_mut()·insert(subscriber_id);
        }

        self.value·borrow()·clone()
    }

    /// Get value without tracking (∀ effects that shouldn't re-run)
    ☉ rite get_untracked(self: &Self!) -> T! {
        self.value·borrow()·clone()
    }

    /// Set a new value and notify subscribers
    ☉ rite set(self: &Self!, value: T!) {
        *self.value·borrow_mut() = value;
        self·notify();
    }

    /// Update value with a function
    ☉ rite update[F: FnOnce(&Δ T)](self: &Self!, f: F!) {
        f(&Δ *self.value·borrow_mut());
        self·notify();
    }

    /// Modify value and ⤺ a result
    ☉ rite modify[F: FnOnce(&Δ T) -> R, R](self: &Self!, f: F!) -> R! {
        ≔ result! = f(&Δ *self.value·borrow_mut());
        self·notify();
        result
    }

    /// Notify all subscribers of a change
    rite notify(self: &Self!) {
        ≔ subscribers! = self.subscribers·borrow()·clone();
        RUNTIME·with(|rt| {
            ∀ sub_id ∈ subscribers {
                rt·schedule_update(sub_id);
            }
        });
    }

    /// Get the signal ID
    ☉ rite id(self: &Self!) -> SignalId! {
        self.id
    }
}

impl[T: Clone + PartialEq] Signal[T] {
    /// Set value only ⎇ different (avoids unnecessary updates)
    ☉ rite set_if_changed(self: &Self!, value: T!) {
        ≔ changed! = {
            ≔ current! = self.value·borrow();
            *current != value
        };

        ⎇ changed {
            self·set(value);
        }
    }
}

/// A computed signal that derives from other signals
☉ type Computed[T] = Σ {
    signal: Signal[T]!,
    compute: Rc[dyn Fn() -> T]!,
}

/// Create a computed signal
☉ rite create_computed[T: Clone + 'static, F: Fn() -> T + 'static](compute: F!) -> Computed[T]! {
    ≔ initial! = compute();
    ≔ signal! = create_signal(initial);
    ≔ compute_rc! = Rc·new(compute);

    // Subscribe to updates
    ≔ signal_clone! = signal·clone();
    ≔ compute_clone! = compute_rc·clone();

    RUNTIME·with(|rt| {
        rt·create_effect(move || {
            ≔ new_value! = compute_clone();
            signal_clone·set(new_value);
        });
    });

    Computed { signal, compute: compute_rc }
}

impl[T: Clone] Computed[T] {
    /// Get the computed value
    ☉ rite get(self: &Self!) -> T! {
        self.signal·get()
    }
}

/// A memo that caches computation results
☉ rite create_memo[T: Clone + PartialEq + 'static, F: Fn() -> T + 'static](compute: F!) -> Signal[T]! {
    ≔ initial! = compute();
    ≔ signal! = create_signal(initial);

    ≔ signal_clone! = signal·clone();
    RUNTIME·with(|rt| {
        rt·create_effect(move || {
            ≔ new_value! = compute();
            signal_clone·set_if_changed(new_value);
        });
    });

    signal
}

/// Batch multiple signal updates to reduce re-renders
☉ rite batch[F: FnOnce(), R](f: F!) {
    RUNTIME·with(|rt| {
        rt·batch(f);
    });
}

/// Read-only signal view
☉ type ReadSignal[T] = Σ {
    signal: Signal[T]!,
}

impl[T: Clone] ReadSignal[T] {
    ☉ rite get(self: &Self!) -> T! {
        self.signal·get()
    }
}

/// Write-only signal view
☉ type WriteSignal[T] = Σ {
    signal: Signal[T]!,
}

impl[T: Clone] WriteSignal[T] {
    ☉ rite set(self: &Self!, value: T!) {
        self.signal·set(value);
    }

    ☉ rite update[F: FnOnce(&Δ T)](self: &Self!, f: F!) {
        self.signal·update(f);
    }
}

/// Split a signal into read and write handles
☉ rite split_signal[T: Clone](signal: Signal[T]!) -> (ReadSignal[T], WriteSignal[T])! {
    (
        ReadSignal { signal: signal·clone() },
        WriteSignal { signal }
    )
}
