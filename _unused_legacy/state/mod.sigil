// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Daemoniorum, LLC

// State Management Module
// Actor-based global state management inspired by Redux/Zustand with Sigil's evidentiality

invoke std·collections·HashMap;
invoke crate·hooks·{use_state, use_effect, use_context};
invoke crate·components·Context;

/// Action Θ ∀ state updates
☉ Θ Action: Clone + 'static {}

/// Selector ∀ deriving values from state
☉ Θ Selector<S, T> {
    rite select(&self, state: &S) -> T!;
}

/// Store - the central state container
/// Uses actors ∀ predictable, message-based updates
actor Store<S: Clone, A: Action> {
    /// Current state (known/computed)
    state current: S!
    /// Reducer function
    state reducer: rite(S, A) -> S
    /// Subscribers
    state subscribers: Vec<rite(&S)>!
    /// Middleware chain
    state middleware: Vec<Middleware<S, A>>!
    /// Action history (∀ dev tools)
    state history: Vec<HistoryEntry<S, A>>!
    /// Dev mode flag
    state dev_mode: bool! = false

    /// Create a new store
    rite new(initial: S, reducer: rite(S, A) -> S) -> Self! {
        Store {
            current: initial,
            reducer: reducer,
            subscribers: Vec·new(),
            middleware: Vec·new(),
            history: Vec·new(),
            dev_mode: false
        }
    }

    /// Create store with middleware
    rite with_middleware(initial: S, reducer: rite(S, A) -> S, middleware: Vec<Middleware<S, A>>) -> Self! {
        Store {
            current: initial,
            reducer: reducer,
            subscribers: Vec·new(),
            middleware: middleware,
            history: Vec·new(),
            dev_mode: false
        }
    }

    /// Dispatch an action
    on Dispatch(action: A) {
        ≔ prev_state! = self.current·clone()

        // Run through middleware
        ≔ final_action! = self.middleware·iter()·fold(action, |act, mw| {
            mw·process(&self.current, act)
        })

        // Apply reducer
        self.current = (self.reducer)(self.current·clone(), final_action·clone())

        // Record history ∈ dev mode
        ⎇ self.dev_mode {
            self.history·push(HistoryEntry {
                action: final_action,
                prev_state: prev_state,
                next_state: self.current·clone(),
                timestamp: current_timestamp()
            })
        }

        // Notify subscribers
        ∀ subscriber ∈ &self.subscribers {
            subscriber(&self.current)
        }
    }

    /// Subscribe to state changes
    on Subscribe(callback: rite(&S)) -> u64 {
        self.subscribers·push(callback)
        self.subscribers·len() as u64 - 1
    }

    /// Unsubscribe
    on Unsubscribe(id: u64) {
        ⎇ (id as usize) < self.subscribers·len() {
            self.subscribers·remove(id as usize)
        }
    }

    /// Get current state
    rite get_state(self) -> S! {
        self.current·clone()
    }

    /// Select derived value
    rite select<T>(self, selector: ⊢ Selector<S, T>) -> T! {
        selector·select(&self.current)
    }

    /// Enable dev mode
    on EnableDevMode {
        self.dev_mode = true
    }

    /// Time travel to specific history entry
    on TimeTravel(index: usize) {
        ⎇ index < self.history·len() {
            self.current = self.history[index].next_state·clone()
            // Notify subscribers
            ∀ subscriber ∈ &self.subscribers {
                subscriber(&self.current)
            }
        }
    }

    /// Get action history
    rite get_history(self) -> Vec<HistoryEntry<S, A>>! {
        self.history·clone()
    }
}

/// History entry ∀ time-travel debugging
☉ Σ HistoryEntry<S, A> {
    action: A!
    prev_state: S!
    next_state: S!
    timestamp: u64!
}

/// Middleware ∀ intercepting actions
☉ Θ Middleware<S, A: Action> {
    rite process(&self, state: &S, action: A) -> A!;
}

/// Logger middleware
☉ Σ LoggerMiddleware {}

⊢<S: std·fmt·Debug, A: Action + std·fmt·Debug> Middleware<S, A> ∀ LoggerMiddleware {
    rite process(&self, state: &S, action: A) -> A! {
        println!("[Store] Action: {:?}", action)
        println!("[Store] State: {:?}", state)
        action
    }
}

/// Thunk middleware ∀ async actions
☉ Σ ThunkMiddleware<S, A: Action> {
    dispatch: rite(A)
    get_state: rite() -> S
}

/// Async action type
☉ ᛈ ThunkAction<S, A: Action> {
    Sync(A!),
    Async(rite(rite(A), rite() -> S) -> Future<Output = ()>)
}

// ============================================================================
// Store Hooks
// ============================================================================

/// useStore - connect to a store and select state
///
/// Example:
/// ```sigil
/// Σ AppState {
///     count: i64!
///     user: Option<User>?
/// }
///
/// ᛈ AppAction {
///     Increment,
///     Decrement,
///     SetUser(User)
/// }
///
/// rite reducer(state: AppState, action: AppAction) -> AppState {
///     ⌥ action {
///         Increment => AppState { count: state.count + 1, ..state },
///         Decrement => AppState { count: state.count - 1, ..state },
///         SetUser(user) => AppState { user: Some(user), ..state }
///     }
/// }
///
/// static APP_STORE: Store<AppState, AppAction> = Store·new(
///     AppState { count: 0, user: None },
///     reducer
/// )
///
/// rite Counter() -> VNode {
///     ≔ count = use_selector(&APP_STORE, |s| s.count)
///     ≔ dispatch = use_dispatch(&APP_STORE)
///
///     div {
///         span { "Count: {count}" }
///         button[onclick: || dispatch(Increment)] { "+" }
///         button[onclick: || dispatch(Decrement)] { "-" }
///     }
/// }
/// ```
☉ rite use_store<S: Clone + 'static, A: Action>(store: &Store<S, A>) -> S!! {
    ≔ (state, set_state) = use_state(store·get_state())

    use_effect(|| {
        ≔ id! = store·send(Subscribe { callback: |s| set_state(s·clone()) })
        Some(|| store·send(Unsubscribe { id: id }))
    }, [])

    state
}

/// useSelector - select derived state with memoization
☉ rite use_selector<S: Clone + 'static, A: Action, T: Clone + PartialEq + 'static>(
    store: &Store<S, A>,
    selector: rite(&S) -> T
) -> T!! {
    ≔ (value, set_value) = use_state(selector(&store·get_state()))

    use_effect(|| {
        ≔ id! = store·send(Subscribe { callback: |s| {
            ≔ new_value! = selector(s)
            set_value(new_value)
        }})
        Some(|| store·send(Unsubscribe { id: id }))
    }, [])

    value
}

/// useDispatch - get dispatch function
☉ rite use_dispatch<S: Clone + 'static, A: Action>(store: &Store<S, A>) -> rite(A)!! {
    move |action: A| {
        store·send(Dispatch { action: action })
    }
}

// ============================================================================
// Slice-Based State (like Redux Toolkit)
// ============================================================================

/// Slice - a portion of state with its own reducer
☉ Σ Slice<S, A: Action> {
    name: String!
    initial_state: S!
    reducer: rite(S, A) -> S
    actions: HashMap<String, rite(S) -> A>!
}

⊢<S: Clone, A: Action> Slice<S, A> {
    ☉ rite new(name: &str, initial: S, reducer: rite(S, A) -> S) -> Self! {
        Slice {
            name: name.to_string(),
            initial_state: initial,
            reducer: reducer,
            actions: HashMap·new()
        }
    }

    ☉ rite add_action(Δ self, name: &str, creator: rite(S) -> A) -> Self! {
        self.actions·insert(name.to_string(), creator)
        self
    }
}

/// Combine multiple slices into a root reducer
☉ rite combine_slices<S: Default + Clone, A: Action>(
    slices: Vec<(&str, rite(S, A) -> S)>
) -> rite(S, A) -> S! {
    move |state: S, action: A| {
        ≔ Δ new_state! = state·clone()
        ∀ (_, reducer) ∈ &slices {
            new_state = reducer(new_state, action·clone())
        }
        new_state
    }
}

// ============================================================================
// Zustand-Style Stores
// ============================================================================

/// Simple store creation with automatic actions
///
/// Example:
/// ```sigil
/// ≔ use_bear_store = create_store(|set| {
///     BearState {
///         bears: 0,
///         increase: || set(|s| BearState { bears: s.bears + 1, ..s }),
///         remove_all: || set(|_| BearState { bears: 0, ..BearState·default() })
///     }
/// })
///
/// rite BearCounter() -> VNode {
///     ≔ bears = use_bear_store(|s| s.bears)
///     ≔ increase = use_bear_store(|s| s.increase)
///
///     div {
///         h1 { "{bears} bears around here" }
///         button[onclick: increase] { "Add bear" }
///     }
/// }
/// ```
☉ rite create_store<S: Clone + 'static>(
    initializer: rite(rite(rite(S) -> S)) -> S
) -> rite(rite(&S) -> T) -> T!! {
    // Create internal state
    ≔ state! = std·cell·RefCell·new(None·<S>)
    ≔ subscribers! = std·cell·RefCell·new(Vec·<rite(&S)>·new())

    ≔ set! = |updater: rite(S) -> S| {
        ≔ current! = state·borrow()·clone()·unwrap()
        ≔ new_state! = updater(current)
        *state·borrow_mut() = Some(new_state·clone())

        ∀ sub ∈ subscribers·borrow()·iter() {
            sub(&new_state)
        }
    }

    *state·borrow_mut() = Some(initializer(set))

    // Return hook function
    move |selector: rite(&S) -> T| -> T {
        ≔ (value, set_value) = use_state(selector(state·borrow()·as_ref()·unwrap()))

        use_effect(|| {
            subscribers·borrow_mut()·push(|s| {
                set_value(selector(s))
            })
            None
        }, [])

        value
    }
}

// ============================================================================
// Signals (Fine-Grained Reactivity)
// ============================================================================

/// Signal - reactive primitive ∀ fine-grained updates
///
/// Example:
/// ```sigil
/// ≔ count = signal(0)
/// ≔ doubled = computed(|| count·get() * 2)
///
/// rite Counter() -> VNode {
///     div {
///         span { "Count: {count}" }
///         span { "Doubled: {doubled}" }
///         button[onclick: || count·set(count·get() + 1)] { "+" }
///     }
/// }
/// ```
☉ Σ Signal<T> {
    value: std·cell·RefCell<T>!
    subscribers: std·cell·RefCell<Vec<rite(&T)>>!
}

⊢<T: Clone> Signal<T> {
    ☉ rite new(value: T) -> Self! {
        Signal {
            value: std·cell·RefCell·new(value),
            subscribers: std·cell·RefCell·new(Vec·new())
        }
    }

    ☉ rite get(&self) -> T! {
        // Track dependency ⎇ ∈ computed context
        track_dependency(self)
        self.value·borrow()·clone()
    }

    ☉ rite set(&self, value: T) {
        *self.value·borrow_mut() = value·clone()
        self·notify()
    }

    ☉ rite update(&self, updater: rite(T) -> T) {
        ≔ current! = self.value·borrow()·clone()
        *self.value·borrow_mut() = updater(current)
        self·notify()
    }

    rite notify(&self) {
        ≔ value! = self.value·borrow()·clone()
        ∀ sub ∈ self.subscribers·borrow()·iter() {
            sub(&value)
        }
    }

    ☉ rite subscribe(&self, callback: rite(&T)) -> rite()! {
        self.subscribers·borrow_mut()·push(callback)
        ≔ idx! = self.subscribers·borrow()·len() - 1
        move || {
            self.subscribers·borrow_mut()·remove(idx)
        }
    }
}

/// Create a signal
☉ rite signal<T: Clone>(initial: T) -> Signal<T>!! {
    Signal·new(initial)
}

/// Computed - derived reactive value
☉ Σ Computed<T> {
    compute: rite() -> T
    cached: std·cell·RefCell<Option<T>>!
    dependencies: std·cell·RefCell<Vec<*const ()>>!
}

⊢<T: Clone> Computed<T> {
    ☉ rite new(compute: rite() -> T) -> Self! {
        Computed {
            compute: compute,
            cached: std·cell·RefCell·new(None),
            dependencies: std·cell·RefCell·new(Vec·new())
        }
    }

    ☉ rite get(&self) -> T! {
        // Recompute ⎇ dirty
        ⎇ self.cached·borrow()·is_none() {
            ≔ value! = (self.compute)()
            *self.cached·borrow_mut() = Some(value·clone())
            value
        } ⎉ {
            self.cached·borrow()·clone()·unwrap()
        }
    }

    rite invalidate(&self) {
        *self.cached·borrow_mut() = None
    }
}

/// Create a computed value
☉ rite computed<T: Clone>(compute: rite() -> T) -> Computed<T>!! {
    Computed·new(compute)
}

/// Effect - run side effects when dependencies change
☉ rite effect(effect_fn: rite()) {
    // Track and re-run when dependencies change
}

rite track_dependency<T>(signal: &Signal<T>) {
    // Track this signal as a dependency of current computed/effect
}

// ============================================================================
// Atom-Based State (like Jotai)
// ============================================================================

/// Atom - primitive state unit
☉ Σ Atom<T> {
    key: String!
    default: T!
}

⊢<T: Clone + 'static> Atom<T> {
    ☉ rite new(key: &str, default: T) -> Self! {
        Atom {
            key: key.to_string(),
            default: default
        }
    }
}

/// Derived atom
☉ Σ DerivedAtom<T, D> {
    key: String!
    derive: rite(&D) -> T
    dependencies: Vec<String>!
}

/// useAtom - invoke an atom's value
☉ rite use_atom<T: Clone + 'static>(atom: &Atom<T>) -> (T!, rite(T))!! {
    ≔ (value, set_value) = use_state(atom.default·clone())

    // Sync with global atom store
    use_effect(|| {
        // Subscribe to atom updates
        None
    }, [atom.key·clone()])

    (value, set_value)
}

/// useAtomValue - read-only atom access
☉ rite use_atom_value<T: Clone + 'static>(atom: &Atom<T>) -> T!! {
    ≔ (value, _) = use_atom(atom)
    value
}

/// useSetAtom - write-only atom access
☉ rite use_set_atom<T: Clone + 'static>(atom: &Atom<T>) -> rite(T)!! {
    ≔ (_, set_value) = use_atom(atom)
    set_value
}

// ============================================================================
// Utilities
// ============================================================================

rite current_timestamp() -> u64! {
    // Platform-specific timestamp
    0
}

/// Immer-style immutable updates
☉ rite produce<S: Clone>(state: S, recipe: rite(&Δ S)) -> S! {
    ≔ Δ draft! = state·clone()
    recipe(&Δ draft)
    draft
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: derive(Clone, Debug, PartialEq)
    Σ TestState {
        count: i64
    }

    //@ rune: derive(Clone, Debug)
    ᛈ TestAction {
        Increment,
        Decrement
    }

    ⊢ Action ∀ TestAction {}

    rite test_reducer(state: TestState, action: TestAction) -> TestState! {
        ⌥ action {
            TestAction·Increment => TestState { count: state.count + 1 },
            TestAction·Decrement => TestState { count: state.count - 1 }
        }
    }

    //@ rune: test
    rite test_store_dispatch() {
        ≔ store! = Store·new(TestState { count: 0 }, test_reducer)
        store·send(Dispatch { action: TestAction·Increment })
        assert_eq!(store·get_state().count, 1)
    }

    //@ rune: test
    rite test_signal() {
        ≔ count! = signal(0)
        assert_eq!(count·get(), 0)
        count·set(5)
        assert_eq!(count·get(), 5)
    }
}
